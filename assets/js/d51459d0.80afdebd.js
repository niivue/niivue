"use strict";(self.webpackChunk_niivue_docs=self.webpackChunk_niivue_docs||[]).push([[3251],{1184:(t,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var s=i(4041);const r={},n=s.createContext(r);function o(t){const e=s.useContext(n);return s.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function a(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:o(t.components),s.createElement(n.Provider,{value:e},t.children)}},2261:(t,e,i)=>{i.d(e,{A:()=>n});var s=i(7565),r=i(1085);const n=t=>{let{children:e}=t;return(0,r.jsx)(s.A,{fallback:(0,r.jsx)("div",{children:"Loading..."}),children:()=>e})}},7855:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>f,contentTitle:()=>u,default:()=>p,frontMatter:()=>m,metadata:()=>s,toc:()=>g});const s=JSON.parse('{"id":"gestures","title":"Gestures","description":"NiiVue supports a wide range of interactive gestures for image manipulation using input devices such as a mouse, touchscreen, or stylus. Some gestures are input-specific\u2014for example, pinch-to-zoom on touchscreens or scroll wheel zoom with a mouse. Gesture behaviors are also configurable to suit different tasks. By default, the primary drag gesture (typically left-click and drag) adjusts image contrast, while the secondary drag gesture (usually right-click and drag) selects a region to automatically optimize contrast. The primary drag can also be configured to control the colormap window (i.e., brightness and contrast). The secondary drag is customizable as well\u2014it can be set to pan the image, zoom, measure distances, or be disabled entirely. Developers can also define custom drag behavior by assigning a callback function, as demonstrated in the drag callback live demo.","source":"@site/docs/gestures.mdx","sourceDirName":".","slug":"/gestures","permalink":"/docs/gestures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":13,"frontMatter":{"title":"Gestures","sidebar_position":13},"sidebar":"tutorialSidebar","previous":{"title":"Fonts","permalink":"/docs/fonts"},"next":{"title":"DICOM","permalink":"/docs/dicom"}}');var r=i(1085),n=i(1184),o=i(8e3),a=i(4041);const l=[{url:"https://niivue.github.io/niivue-demo-images/mni152.nii.gz"}],h={isColorbar:!0,logLevel:"info"},c=t=>{let{images:e=l,nvOpts:i={}}=t;const s=(0,a.useRef)(null),n=(0,a.useRef)(null),c={...h,...i};(0,a.useEffect)((()=>((async()=>{if(!n.current&&s.current){const t=new o.FM(c);n.current=t,await t.attachToCanvas(s.current),t.setSliceType(t.sliceTypeAxial),await t.loadVolumes(e)}})(),()=>{n.current=null})),[]);return(0,r.jsxs)("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",gap:"8px",padding:"8px"},children:[(0,r.jsx)("div",{style:{width:640,height:480},children:(0,r.jsx)("canvas",{ref:s,width:640,height:480,style:{width:"100%",height:"100%"}})}),(0,r.jsxs)("div",{style:{display:"flex",gap:"12px",alignItems:"center"},children:[(0,r.jsxs)("label",{children:["Primary Drag \xa0",(0,r.jsxs)("select",{onChange:t=>{const e=1===t.target.selectedIndex;n.current.opts.dragModePrimary=e?1:0},children:[(0,r.jsx)("option",{children:"crosshair"}),(0,r.jsx)("option",{children:"brightness/contrast"})]})]}),"\xa0\xa0",(0,r.jsxs)("label",{children:["Secondary Drag \xa0",(0,r.jsxs)("select",{onChange:t=>{const e=t.target.value;n.current.dragModes[e]&&(n.current.opts.dragMode=n.current.dragModes[e])},children:[(0,r.jsx)("option",{children:"contrast"}),(0,r.jsx)("option",{children:"pan"}),(0,r.jsx)("option",{children:"measurement"}),(0,r.jsx)("option",{children:"slicer3D"}),(0,r.jsx)("option",{children:"none"})]})]})]})]})};var d=i(2261);const m={title:"Gestures",sidebar_position:13},u=void 0,f={},g=[];function A(t){const e={a:"a",p:"p",...(0,n.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:["NiiVue supports a wide range of interactive gestures for image manipulation using input devices such as a mouse, touchscreen, or stylus. Some gestures are input-specific\u2014for example, pinch-to-zoom on touchscreens or scroll wheel zoom with a mouse. Gesture behaviors are also configurable to suit different tasks. By default, the primary drag gesture (typically left-click and drag) adjusts image contrast, while the secondary drag gesture (usually right-click and drag) selects a region to automatically optimize contrast. The primary drag can also be configured to control the colormap window (i.e., brightness and contrast). The secondary drag is customizable as well\u2014it can be set to pan the image, zoom, measure distances, or be disabled entirely. Developers can also define custom drag behavior by assigning a callback function, as demonstrated in the ",(0,r.jsx)(e.a,{href:"https://niivue.com/demos/features/dragCallback.html",children:"drag callback live demo"}),"."]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(c,{})})]})}function p(t={}){const{wrapper:e}={...(0,n.R)(),...t.components};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(A,{...t})}):A(t)}},8e3:(t,e,i)=>{i.d(e,{FM:()=>is,dq:()=>Re,gS:()=>Ue,v6:()=>Ne});var s=i(911),r=i(4062),n=i(9095),o=i(333),a=i(9659),l=i(5806),h=i(5798),c=i(2651),d=i(2859),m=i(4990),u=i(8044),f=i(1959),g=i(9247),A=i(7687),p=i(6428),v=i(543),x=i(5878),w=i(9302),b=Object.defineProperty,y=t=>{throw TypeError(t)},C=(t,e)=>{for(var i in e)b(t,i,{get:e[i],enumerable:!0})},M=(t,e,i)=>((t,e,i)=>e in t?b(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i)(t,"symbol"!=typeof e?e+"":e,i),D=(t,e,i)=>e.has(t)||y("Cannot "+i),I=(t,e,i)=>(D(t,e,"read from private field"),i?i.call(t):e.get(t)),T=(t,e,i)=>e.has(t)?y("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,i),S=(t,e,i,s)=>(D(t,e,"write to private field"),s?s.call(t,i):e.set(t,i),i),F=new Float32Array([-1,-1,-1,.28,.28,.28,-1,-1,-1,.28,.28,.28,-1,1,-1,.28,.28,.28,1,-1,-1,.28,.28,.28,1,1,-1,.28,.28,.28,1,1,-1,.28,.28,.28,-1,-1,1,.8,.8,.8,-1,-1,1,.8,.8,.8,1,-1,1,.8,.8,.8,-1,1,1,.8,.8,.8,1,1,1,.8,.8,.8,1,1,1,.8,.8,.8,-1,1,-1,0,0,.74,-1,1,-1,0,0,.74,-1,1,1,0,0,.74,1,1,-1,0,0,.74,1,1,1,0,0,.74,1,1,1,0,0,.74,-1,-1,-1,.42,0,.42,-1,-1,-1,.42,0,.42,1,-1,-1,.42,0,.42,-1,-1,1,.42,0,.42,1,-1,1,.42,0,.42,1,-1,1,.42,0,.42,-1,-1,-1,.64,0,0,-1,-1,-1,.64,0,0,-1,-1,1,.64,0,0,-1,1,-1,.64,0,0,-1,1,1,.64,0,0,-1,1,1,.64,0,0,1,-1,-1,0,.5,0,1,-1,-1,0,.5,0,1,1,-1,0,.5,0,1,-1,1,0,.5,0,1,1,1,0,.5,0,1,1,1,0,.5,0,-.45,1,-.8,0,0,0,-.45,1,-.8,0,0,0,-.45,1,.8,0,0,0,-.25,1,-.8,0,0,0,-.25,1,.8,0,0,0,-.25,1,.8,0,0,0,-.25,1,.6,0,0,0,-.25,1,.6,0,0,0,-.25,1,.8,0,0,0,.45,1,.6,0,0,0,.25,1,.8,0,0,0,.25,1,.8,0,0,0,.25,1,.1,0,0,0,.25,1,.1,0,0,0,.25,1,.6,0,0,0,.45,1,.1,0,0,0,.45,1,.6,0,0,0,.45,1,.6,0,0,0,-.25,1,-.1,0,0,0,-.25,1,-.1,0,0,0,-.25,1,.1,0,0,0,.25,1,-.1,0,0,0,.45,1,.1,0,0,0,.45,1,.1,0,0,0,.45,-1,-.8,0,0,0,.45,-1,-.8,0,0,0,.05,-1,.8,0,0,0,.25,-1,-.8,0,0,0,-.15,-1,.8,0,0,0,-.15,-1,.8,0,0,0,-.25,-1,-.8,0,0,0,-.25,-1,-.8,0,0,0,.05,-1,.8,0,0,0,-.45,-1,-.8,0,0,0,-.15,-1,.8,0,0,0,-.15,-1,.8,0,0,0,.13,-1,-.3,0,0,0,.13,-1,-.3,0,0,0,.07,-1,-.1,0,0,0,-.33,-1,-.3,0,0,0,-.27,-1,-.1,0,0,0,-.27,-1,-.1,0,0,0,-.45,.6,1,0,0,0,-.45,.6,1,0,0,0,-.45,.4,1,0,0,0,-.25,.8,1,0,0,0,-.25,.4,1,0,0,0,-.25,.4,1,0,0,0,-.25,.8,1,0,0,0,-.25,.8,1,0,0,0,-.25,.6,1,0,0,0,.25,.8,1,0,0,0,.45,.6,1,0,0,0,.45,.6,1,0,0,0,.25,.8,1,0,0,0,.25,.8,1,0,0,0,.25,-.1,1,0,0,0,.45,.6,1,0,0,0,.45,.1,1,0,0,0,.45,.1,1,0,0,0,-.25,.1,1,0,0,0,-.25,.1,1,0,0,0,-.45,-.1,1,0,0,0,.25,.1,1,0,0,0,.25,-.1,1,0,0,0,.25,-.1,1,0,0,0,-.45,-.1,1,0,0,0,-.45,-.1,1,0,0,0,-.45,-.6,1,0,0,0,-.25,-.1,1,0,0,0,-.25,-.8,1,0,0,0,-.25,-.8,1,0,0,0,-.25,-.6,1,0,0,0,-.25,-.6,1,0,0,0,-.25,-.8,1,0,0,0,.45,-.6,1,0,0,0,.25,-.8,1,0,0,0,.25,-.8,1,0,0,0,.25,-.4,1,0,0,0,.25,-.4,1,0,0,0,.25,-.6,1,0,0,0,.45,-.4,1,0,0,0,.45,-.6,1,0,0,0,.45,-.6,1,0,0,0,-.1,-.8,-1,0,0,0,-.1,-.8,-1,0,0,0,-.1,.8,-1,0,0,0,.1,-.8,-1,0,0,0,.1,.8,-1,0,0,0,.1,.8,-1,0,0,0,-1,-.45,-.8,0,0,0,-1,-.45,-.8,0,0,0,-1,-.45,.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,.8,0,0,0,-1,-.25,.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,-.8,0,0,0,-1,-.25,-.6,0,0,0,-1,.45,-.8,0,0,0,-1,.45,-.6,0,0,0,-1,.45,-.6,0,0,0,1,.45,-.8,0,0,0,1,.45,-.8,0,0,0,1,.45,.8,0,0,0,1,.25,-.8,0,0,0,1,.25,.8,0,0,0,1,.25,.8,0,0,0,1,.25,.6,0,0,0,1,.25,.6,0,0,0,1,.25,.8,0,0,0,1,-.45,.6,0,0,0,1,-.25,.8,0,0,0,1,-.25,.8,0,0,0,1,-.25,.1,0,0,0,1,-.25,.1,0,0,0,1,-.25,.6,0,0,0,1,-.45,.1,0,0,0,1,-.45,.6,0,0,0,1,-.45,.6,0,0,0,1,.25,-.1,0,0,0,1,.25,-.1,0,0,0,1,.25,.1,0,0,0,1,-.25,-.1,0,0,0,1,-.45,.1,0,0,0,1,-.45,.1,0,0,0,1,-.25,-.8,0,0,0,1,-.25,-.8,0,0,0,1,-.05,-.1,0,0,0,1,-.45,-.8,0,0,0,1,-.25,-.1,0,0,0,1,-.25,-.1,0,0,0]),E=class{constructor(t,e,i,s,r,o){void 0===r&&(r=null),void 0===o&&(o=null),M(this,"sphereIdx",[]),M(this,"sphereVtx",[]),M(this,"renderShaders",[]),M(this,"isVisible",!0),M(this,"isPickable",!0),M(this,"vertexBuffer"),M(this,"indexCount"),M(this,"indexBuffer"),M(this,"vao"),M(this,"mode"),M(this,"glFlags",0),M(this,"id"),M(this,"colorId"),M(this,"modelMatrix",n.vt()),M(this,"scale",[1,1,1]),M(this,"position",[0,0,0]),M(this,"rotation",[0,0,0]),M(this,"rotationRadians",0),M(this,"extentsMin",[]),M(this,"extentsMax",[]),M(this,"furthestVertexFromOrigin"),M(this,"originNegate"),M(this,"fieldOfViewDeObliqueMM"),M(this,"mm"),this.vertexBuffer=e,this.indexCount=s,this.indexBuffer=r,this.vao=o,this.mode=i,this.id=t,this.colorId=[(255&t)/255,(t>>8&255)/255,(t>>16&255)/255,(t>>24&255)/255]}};M(E,"BLEND",1),M(E,"CULL_FACE",2),M(E,"CULL_FRONT",4),M(E,"CULL_BACK",8),M(E,"ENABLE_DEPTH_TEST",16),M(E,"generateCrosshairs",(function(t,e,i,s,r,n,o,a){void 0===o&&(o=20),void 0===a&&(a=0);const l=E.generateCrosshairsGeometry(t,i,s,r,n,o,a);return new E(e,l.vertexBuffer,t.TRIANGLES,l.indexCount,l.indexBuffer,l.vao)})),M(E,"generateCrosshairsGeometry",(function(t,e,i,s,n,o,a){void 0===o&&(o=20),void 0===a&&(a=0);const l=[],h=[],c=n*a;if(c<=0){let t=r.fA(i[0],e[1],e[2]),a=r.fA(s[0],e[1],e[2]);E.makeCylinder(l,h,t,a,n,o),t=r.fA(e[0],i[1],e[2]),a=r.fA(e[0],s[1],e[2]),E.makeCylinder(l,h,t,a,n,o),t=r.fA(e[0],e[1],i[2]),a=r.fA(e[0],e[1],s[2]),E.makeCylinder(l,h,t,a,n,o)}else{let t=r.fA(i[0],e[1],e[2]),a=r.fA(e[0]-c,e[1],e[2]);E.makeCylinder(l,h,t,a,n,o,!1),t=r.fA(e[0]+c,e[1],e[2]),a=r.fA(s[0],e[1],e[2]),E.makeCylinder(l,h,t,a,n,o,!1),t=r.fA(e[0],i[1],e[2]),a=r.fA(e[0],e[1]-c,e[2]),E.makeCylinder(l,h,t,a,n,o,!1),t=r.fA(e[0],e[1]+c,e[2]),a=r.fA(e[0],s[1],e[2]),E.makeCylinder(l,h,t,a,n,o,!1),t=r.fA(e[0],e[1],i[2]),a=r.fA(e[0],e[1],e[2]-c),E.makeCylinder(l,h,t,a,n,o,!1),t=r.fA(e[0],e[1],e[2]+c),a=r.fA(e[0],e[1],s[2]),E.makeCylinder(l,h,t,a,n,o,!1)}const d=t.createBuffer();if(null===d)throw new Error("could not instantiate vertex buffer");t.bindBuffer(t.ARRAY_BUFFER,d),t.bufferData(t.ARRAY_BUFFER,new Float32Array(l),t.STATIC_DRAW);const m=t.createBuffer();if(null===m)throw new Error("could not instantiate index buffer");t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,m),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint32Array(h),t.STATIC_DRAW);const u=t.createVertexArray();return t.bindVertexArray(u),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,m),t.bindBuffer(t.ARRAY_BUFFER,d),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,3,t.FLOAT,!1,0,0),t.bindVertexArray(null),{vertexBuffer:d,indexBuffer:m,indexCount:h.length,vao:u}})),M(E,"getFirstPerpVector",(function(t){const e=r.fA(0,0,0);return 0===t[0]?e[0]=1:0===t[1]?e[1]=1:0===t[2]?e[2]=1:(e[0]=t[2],e[1]=t[2],e[2]=-(t[0]+t[1]),r.S8(e,e)),e})),M(E,"subdivide",(function(t,e){let i=t.length/3,s=e.length/3;const n=s,o=r.vt(),a=r.vt();for(let l=0;l<n;l++){const n=e[3*l+0],h=e[3*l+1],c=e[3*l+2],d=r.fA(t[3*n+0],t[3*n+1],t[3*n+2]),m=r.fA(t[3*h+0],t[3*h+1],t[3*h+2]),u=r.fA(t[3*c+0],t[3*c+1],t[3*c+2]);r.WQ(o,d,m),r.S8(a,o),t.push(...a),r.WQ(o,m,u),r.S8(a,o),t.push(...a),r.WQ(o,d,u),r.S8(a,o),t.push(...a);let f=[i,i+1,i+2];e.push(...f),f=[n,i,i+2],e.push(...f),f=[i,h,i+1],e.push(...f),e[3*l+0]=i+2,e[3*l+1]=i+1,e[3*l+2]=c,s+=3,i+=3}})),M(E,"weldVertices",(function(t,e){const i=t.length/3;let s=0;const r=new Int32Array(i);for(let a=0;a<i-1;a++){if(0!==r[a])continue;r[a]=s;let e=3*a;const n=t[e],o=t[e+1],l=t[e+2];for(let h=a+1;h<i;h++)e+=3,n===t[e]&&o===t[e+1]&&l===t[e+2]&&(r[h]=s);s++}if(s===i)return t;const n=e.length;for(let a=0;a<n;a++)e[a]=r[e[a]];const o=t.slice(0,3*s-1);for(let a=0;a<i-1;a++){const e=3*a,i=3*r[a];o[i]=t[e],o[i+1]=t[e+1],o[i+2]=t[e+2]}return o})),M(E,"makeSphere",(function(t,e,i,s){void 0===s&&(s=[0,0,0]);let r=[0,0,1,.894,0,.447,.276,.851,.447,-.724,.526,.447,-.724,-.526,.447,.276,-.851,.447,.724,.526,-.447,-.276,.851,-.447,-.894,0,-.447,-.276,-.851,-.447,.724,-.526,-.447,0,0,-1];const n=[0,1,2,0,2,3,0,3,4,0,4,5,0,5,1,7,6,11,8,7,11,9,8,11,10,9,11,6,10,11,6,2,1,7,3,2,8,4,3,9,5,4,10,1,5,6,7,2,7,8,3,8,9,4,9,10,5,10,6,1];E.subdivide(r,n),E.subdivide(r,n),r=E.weldVertices(r,n);for(let h=0;h<r.length;h++)r[h]=r[h]*i;const o=r.length/3;let a=0;for(let h=0;h<o;h++)r[a]=r[a]+s[0],a++,r[a]=r[a]+s[1],a++,r[a]=r[a]+s[2],a++;const l=Math.floor(t.length/3);for(let h=0;h<n.length;h++)n[h]=n[h]+l;e.push(...n),t.push(...r)})),M(E,"makeCylinder",(function(t,e,i,s,n,o,a){void 0===o&&(o=20),void 0===a&&(a=!0),o<3&&(o=3);const l=r.vt();r.Re(l,s,i),r.S8(l,l);const h=E.getFirstPerpVector(l),c=r.vt();r.$A(c,l,h),r.S8(c,c);let d=2*o,m=2*o;a&&(m+=2*o,d+=2);const u=Math.floor(t.length/3),f=new Uint32Array(3*m),g=new Float32Array(3*d);function A(t,e){g[3*t+0]=e[0],g[3*t+1]=e[1],g[3*t+2]=e[2]}function p(t,e,i,s){f[3*t+0]=e+u,f[3*t+1]=i+u,f[3*t+2]=s+u}const v=2*o,x=v+1;a&&(A(v,i),A(x,s));const w=r.vt(),b=r.vt();for(let y=0;y<o;y++){const t=Math.cos(y/o*2*Math.PI),e=Math.sin(y/o*2*Math.PI);w[0]=n*(t*h[0]+e*c[0]),w[1]=n*(t*h[1]+e*c[1]),w[2]=n*(t*h[2]+e*c[2]),r.WQ(b,i,w),A(y,b),r.WQ(b,s,w),A(y+o,b);let l=0;y<o-1&&(l=y+1),p(2*y,y,l,y+o),p(2*y+1,l,l+o,y+o),a&&(p(2*o+y,y,v,l),p(2*o+y+o,x,y+o,l+o))}e.push(...f),t.push(...g)})),M(E,"makeColoredCylinder",(function(t,e,i,s,r,n,o,a,l){void 0===o&&(o=[192,0,0,255]),void 0===a&&(a=20),void 0===l&&(l=!1);let h=t.length/3;E.makeCylinder(t,e,s,r,n,a,l),h=t.length/3-h;const c=[];for(let d=0;d<4*h-1;d+=4)c[d]=o[0],c[d+1]=o[1],c[d+2]=o[2],c[d+3]=o[3];i.push(...c)})),M(E,"makeColoredSphere",(function(t,e,i,s,r,n){void 0===r&&(r=[0,0,0]),void 0===n&&(n=[0,0,192,255]);let o=t.length/3;E.makeSphere(t,e,s,r),o=t.length/3-o;const a=[];for(let l=0;l<4*o-1;l+=4)a[l]=n[0],a[l+1]=n[1],a[l+2]=n[2],a[l+3]=n[3];i.push(...a)}));var B=E,V=class t{constructor(t){let{name:e="niivue",level:i="info"}=void 0===t?{}:t;M(this,"level"),M(this,"name"),this.name=`${e}`,this.level=i}debug(){if(!(t.levels[this.level]>t.levels.debug)){for(var e=arguments.length,i=new Array(e),s=0;s<e;s++)i[s]=arguments[s];console.debug(`${this.name}-debug`,...i)}}info(){if(!(t.levels[this.level]>t.levels.info)){for(var e=arguments.length,i=new Array(e),s=0;s<e;s++)i[s]=arguments[s];console.info(`${this.name}-info`,...i)}}warn(){if(!(t.levels[this.level]>t.levels.warn)){for(var e=arguments.length,i=new Array(e),s=0;s<e;s++)i[s]=arguments[s];console.warn(`${this.name}-warn`,...i)}}error(){if(!(t.levels[this.level]>t.levels.error)){for(var e=arguments.length,i=new Array(e),s=0;s<e;s++)i[s]=arguments[s];console.error(`${this.name}-error`,...i)}}fatal(){if(!(t.levels[this.level]>t.levels.fatal)){for(var e=arguments.length,i=new Array(e),s=0;s<e;s++)i[s]=arguments[s];console.error(`${this.name}-fatal`,...i)}}setLogLevel(t){this.level=t}setName(t){this.name=t}};M(V,"levels",{debug:0,info:1,warn:2,error:3,fatal:4,silent:1/0});var U=new V({name:"niivue",level:"info"}),R={};C(R,{$itksnap:()=>Y,$slicer3d:()=>G,actc:()=>W,afni_blues_inv:()=>ee,afni_reds_inv:()=>ie,batlow:()=>K,bcgwhw:()=>Q,bcgwhw_dark:()=>z,blue:()=>j,blue2cyan:()=>q,blue2magenta:()=>H,blue2red:()=>X,bluegrn:()=>Z,bone:()=>J,bronze:()=>_,cet_l17:()=>$,cividis:()=>tt,cool:()=>et,copper:()=>st,copper2:()=>it,ct_airways:()=>rt,ct_artery:()=>nt,ct_bones:()=>ot,ct_brain:()=>lt,ct_brain_gray:()=>at,ct_cardiac:()=>ht,ct_head:()=>ct,ct_kidneys:()=>dt,ct_liver:()=>mt,ct_muscles:()=>ut,ct_scalp:()=>ft,ct_skull:()=>gt,ct_soft:()=>At,ct_soft_tissue:()=>pt,ct_surface:()=>vt,ct_vessels:()=>xt,ct_w_contrast:()=>wt,cubehelix:()=>bt,electric_blue:()=>yt,freesurfer:()=>Ct,ge_color:()=>Mt,gold:()=>Dt,gray:()=>It,green:()=>Tt,green2cyan:()=>St,green2orange:()=>Ft,hot:()=>Bt,hotiron:()=>Et,hsv:()=>Vt,inferno:()=>Ut,jet:()=>Rt,kry:()=>Nt,linspecer:()=>Pt,lipari:()=>Lt,magma:()=>kt,mako:()=>Ot,navia:()=>Yt,nih:()=>Gt,plasma:()=>Wt,random:()=>Kt,red:()=>zt,redyell:()=>Qt,rocket:()=>Xt,roi_i256:()=>se,surface:()=>Ht,thermal:()=>qt,turbo:()=>Zt,violet:()=>jt,viridis:()=>Jt,warm:()=>_t,winter:()=>$t,x_rain:()=>te});var N,P,L,k,O,Y={R:[0,255,0,0,255,0,255,255,0,205,210,102,0,0,46,255,106,221,233,165,255,147,218,75,255,60,255,255,218,0,188,255,255,222,127,139,124,255,70,0,238,238,240,245,184,32,255,25,112,34,248,245,255,144,173,65,255,250,128,50,244,255,123,255,173,255,127,255,143,220,253,255,0,0,128,255,250,148,178,255,135,100,240,250,255,107,135,0,139,245,186,255,255,0,210,255,47,72,175,128,176,255,139,240,255,216,119,219,72,255,199,154,189,240,230,0,85,64,153,205,250,95,0,255,224,176,138,30,240,152,160],G:[0,0,255,0,255,255,0,239,0,133,180,205,0,139,139,228,90,160,150,42,250,112,112,0,182,179,235,228,165,128,143,105,218,184,255,69,252,255,130,100,130,232,255,222,134,178,20,25,128,139,248,255,160,238,255,105,99,240,0,205,164,255,104,165,216,192,255,140,188,20,245,250,206,255,0,250,128,0,34,127,206,149,230,235,245,142,206,0,0,245,85,228,222,191,105,248,79,61,238,128,224,240,0,255,215,191,136,112,209,0,21,205,183,248,230,250,107,224,50,92,250,158,128,69,255,196,43,144,128,251,82],B:[0,0,0,255,0,255,255,213,205,63,140,170,128,139,87,225,205,221,122,42,250,219,214,130,193,113,205,196,32,128,143,180,185,135,0,19,0,224,180,0,238,170,240,179,11,170,147,112,144,34,255,250,122,144,47,225,71,230,0,50,96,240,238,0,230,203,212,0,143,60,230,240,209,127,128,205,114,211,34,80,235,237,140,215,238,35,250,139,139,220,211,181,173,255,30,220,79,139,238,0,230,245,0,255,0,216,153,147,204,255,133,50,107,255,250,154,47,208,204,92,210,160,0,0,255,222,226,255,128,152,45],A:[0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130]},G={labels:["background","tissue","bone","skin","connective tissue","blood","organ","mass","muscle","foreign object","waste","teeth","fat","gray matter","white matter","nerve","vein","artery","capillary","ligament","tendon","cartilage","meniscus","lymph node","lymphatic vessel","cerebro-spinal fluid","bile","urine","feces","gas","fluid","edema","bleeding","necrosis","clot","embolism","head","central nervous system","brain","gray matter of brain","telencephalon","cerebral cortex","right frontal lobe","left frontal lobe","right temporal lobe","left temporal lobe","right parietal lobe","left parietal lobe","right occipital lobe","left occipital lobe","right insular lobe","left insular lobe","right limbic lobe","left limbic lobe","right striatum","left striatum","right caudate nucleus","left caudate nucleus","right putamen","left putamen","right pallidum","left pallidum","right amygdaloid complex","left amygdaloid complex","diencephalon","thalamus","right thalamus","left thalamus","pineal gland","midbrain","substantia nigra","right substantia nigra","left substantia nigra","cerebral white matter","right superior longitudinal fasciculus","left superior longitudinal fasciculus","right inferior longitudinal fasciculus","left inferior longitudinal fasciculus","right arcuate fasciculus","left arcuate fasciculus","right uncinate fasciculus","left uncinate fasciculus","right cingulum bundle","left cingulum bundle","projection fibers","right corticospinal tract","left corticospinal tract","right optic radiation","left optic radiation","right medial lemniscus","left medial lemniscus","right superior cerebellar peduncle","left superior cerebellar peduncle","right middle cerebellar peduncle","left middle cerebellar peduncle","right inferior cerebellar peduncle","left inferior cerebellar peduncle","optic chiasm","right optic tract","left optic tract","right fornix","left fornix","commissural fibers","corpus callosum","posterior commissure","cerebellar white matter","CSF space","ventricles of brain","right lateral ventricle","left lateral ventricle","right third ventricle","left third ventricle","cerebral aqueduct","fourth ventricle","subarachnoid space","spinal cord","gray matter of spinal cord","white matter of spinal cord","endocrine system of brain","pituitary gland","adenohypophysis","neurohypophysis","meninges","dura mater","arachnoid","pia mater","muscles of head","salivary glands","lips","nose","tongue","soft palate","right inner ear","left inner ear","right external ear","left external ear","right middle ear","left middle ear","right eyeball","left eyeball","skull","right frontal bone","left frontal bone","right parietal bone","left parietal bone","right temporal bone","left temporal bone","right sphenoid bone","left sphenoid bone","right ethmoid bone","left ethmoid bone","occipital bone","maxilla","right zygomatic bone","right lacrimal bone","vomer bone","right palatine bone","left palatine bone","mandible","neck","muscles of neck","pharynx","larynx","thyroid gland","right parathyroid glands","left parathyroid glands","skeleton of neck","hyoid bone","cervical vertebral column","thorax","trachea","bronchi","right lung","left lung","superior lobe of right lung","superior lobe of left lung","middle lobe of right lung","inferior lobe of right lung","inferior lobe of left lung","pleura","heart","right atrium","left atrium","atrial septum","ventricular septum","right ventricle of heart","left ventricle of heart","mitral valve","tricuspid valve","aortic valve","pulmonary valve","aorta","pericardium","pericardial cavity","esophagus","thymus","mediastinum","skin of thoracic wall","muscles of thoracic wall","skeleton of thorax","thoracic vertebral column","ribs","sternum","right clavicle","left clavicle","abdominal cavity","abdomen","peritoneum","omentum","peritoneal cavity","retroperitoneal space","stomach","duodenum","small bowel","colon","anus","liver","biliary tree","gallbladder","pancreas","spleen","urinary system","right kidney","left kidney","right ureter","left ureter","urinary bladder","urethra","right adrenal gland","left adrenal gland","female internal genitalia","uterus","right fallopian tube","left fallopian tube","right ovary","left ovary","vagina","male internal genitalia","prostate","right seminal vesicle","left seminal vesicle","right deferent duct","left deferent duct","skin of abdominal wall","muscles of abdominal wall","skeleton of abdomen","lumbar vertebral column","female external genitalia","male external genitalia","skeleton of upper limb","muscles of upper limb","right upper limb","left upper limb","right shoulder","left shoulder","right arm"],R:[0,128,241,177,111,216,221,144,192,220,78,255,230,200,250,244,0,216,183,183,152,111,178,68,111,85,0,214,78,218,170,140,188,216,145,150,177,244,250,200,68,128,83,83,162,162,141,141,182,182,188,188,154,154,177,177,30,30,210,210,48,48,98,98,69,166,122,122,253,145,46,0,0,250,127,127,159,159,125,125,106,106,154,154,126,201,201,78,78,174,174,139,139,148,148,186,186,99,156,156,64,64,138,97,126,194,85,88,88,88,88,88,88,88,88,244,200,250,82,57,60,92,255,255,255,255,201,70,188,177,166,182,229,229,174,174,201,201,194,194,241,203,203,229,229,255,255,209,209,248,248,255,196,255,255,255,242,242,222,177,213,184,150,62,62,62,242,250,255,177,182,175,197,197,172,172,202,224,224,255,206,210,203,233,195,181,152,159,166,218,225,224,255,184,211,47,255,173,188,255,226,253,244,205,205,186,177,255,234,204,180,216,255,205,204,255,221,0,139,249,157,203,185,185,247,247,222,124,249,249,244,255,255,227,213,213,193,216,230,245,245,241,241,177,171,217,212,185,185,198,194,177,177,177,177,177],G:[0,174,214,122,184,101,130,238,104,245,63,250,220,200,250,214,151,101,156,214,189,184,212,172,197,188,145,230,63,255,250,224,65,191,60,98,122,214,250,200,131,174,146,146,115,115,93,93,166,166,135,135,150,150,140,140,111,111,157,157,129,129,153,153,110,113,101,101,135,92,101,108,108,250,150,150,116,116,102,102,174,174,146,146,126,160,160,152,152,140,140,126,126,120,120,135,135,106,171,171,123,123,95,113,161,195,188,106,106,106,106,106,106,106,106,214,200,250,174,157,143,162,244,244,244,244,121,163,91,122,84,105,147,147,122,122,112,112,142,142,213,179,179,204,204,243,243,185,185,223,223,230,172,255,250,237,217,217,198,122,124,105,208,162,162,162,206,210,255,122,228,216,165,165,138,138,164,186,186,245,110,115,108,138,100,85,55,63,70,123,130,97,244,122,171,150,244,121,95,239,202,232,217,179,179,124,122,255,234,142,119,132,253,167,168,224,130,145,150,180,108,136,102,102,182,182,154,186,186,186,170,181,190,153,141,141,123,146,158,172,172,172,172,124,85,198,188,135,135,175,98,122,122,122,122,122],B:[0,128,145,101,210,79,101,144,88,20,0,220,70,235,210,49,206,79,220,211,207,210,242,100,131,255,30,130,0,255,250,228,28,216,66,83,101,49,225,215,98,128,164,164,105,105,137,137,110,110,166,166,201,201,190,190,85,85,166,166,126,126,112,112,53,137,38,38,192,109,131,112,112,225,88,88,163,163,154,154,155,155,83,83,55,133,133,141,141,103,103,177,177,72,72,135,135,24,108,108,147,147,74,158,197,164,255,215,215,215,215,215,215,215,215,49,215,225,128,110,83,109,209,209,209,209,77,117,95,101,94,107,118,118,90,90,73,73,0,0,144,77,77,109,109,152,152,85,85,131,131,138,68,167,160,145,123,123,101,101,109,108,243,114,114,114,142,139,207,101,255,244,145,145,115,115,140,162,162,217,84,89,81,112,73,57,13,27,38,97,104,76,209,154,143,103,209,88,76,172,134,158,154,108,108,161,101,220,194,178,153,105,229,142,143,199,101,30,98,111,162,116,83,83,164,164,132,223,150,150,147,158,165,130,113,113,103,127,140,147,147,151,151,92,68,131,102,134,134,125,79,101,101,101,101,101],A:[0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},W={R:[0,0,24,248,255],G:[0,0,177,254,0],B:[0,136,0,0,0],A:[0,32,64,78,128],I:[0,64,128,156,255]},K={R:[1,10,15,17,21,27,36,49,65,82,99,118,140,161,183,203,222,238,248,253,253,253,252,250],G:[25,42,56,68,79,88,97,105,111,116,122,127,133,138,142,146,150,155,162,170,178,186,195,204],B:[89,92,95,96,98,98,96,91,83,74,64,55,46,43,49,62,79,100,126,151,175,199,223,250],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},z={R:[0,248,242,235,229,222,212,202,193,183,173,145,117,78,39,0,0,0,0,0,0,64,128,191,255,255,255,255,255,238,221,204,214,224,235,245,255,249,242,236,229,223,217,210,204,197,191,184,176,169,161,154,146,139,132,124,117,109,102,0],G:[0,251,247,243,239,235,235,235,235,235,235,216,197,174,150,127,153,178,204,229,255,255,255,255,255,220,185,150,115,77,38,0,31,61,92,122,153,138,122,107,92,77,61,46,31,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0],B:[0,254,253,252,251,250,251,252,253,254,255,226,198,132,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,80,120,160,200,199,198,197,196,196,195,194,193,192,191,184,176,169,161,154,146,139,132,124,117,109,102,0],A:[256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256],I:[0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,255]},Q={R:[255,248,242,235,229,222,212,202,193,183,173,145,117,78,39,0,0,0,0,0,0,64,128,191,255,255,255,255,255,238,221,204,214,224,235,245,255,249,242,236,229,223,217,210,204,197,191,184,176,169,161,154,146,139,132,124,117,109,102,0],G:[255,251,247,243,239,235,235,235,235,235,235,216,197,174,150,127,153,178,204,229,255,255,255,255,255,220,185,150,115,77,38,0,31,61,92,122,153,138,122,107,92,77,61,46,31,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0],B:[255,254,253,252,251,250,251,252,253,254,255,226,198,132,66,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,80,120,160,200,199,198,197,196,196,195,194,193,192,191,184,176,169,161,154,146,139,132,124,117,109,102,0],A:[256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256],I:[0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,140,144,148,152,156,160,164,168,172,176,180,184,188,192,196,200,204,208,212,216,220,224,228,232,236,240,244,248,255]},X={R:[0,0,0,0,196,255],G:[0,32,128,128,128,32],B:[0,255,196,0,0,0],A:[0,128,64,64,64,128],I:[0,1,64,128,192,255]},H={R:[0,255],G:[0,0],B:[255,255],A:[0,128],I:[0,255]},q={R:[0,0],G:[0,255],B:[255,255],A:[0,128],I:[0,255]},Z={R:[0,0,0,0],G:[0,1,128,255],B:[0,222,127,32],A:[0,0,64,128],I:[0,1,128,255]},j={R:[0,0,0],G:[0,0,0],B:[0,128,255],A:[0,64,128],I:[0,128,255]},J={R:[0,103,255],G:[0,126,255],B:[0,165,255],A:[0,76,128],I:[0,153,255]},_={R:[0,43,103,199,216,255],G:[0,0,37,155,213,255],B:[0,0,20,97,201,255],A:[0,44,48,54,56,56],I:[0,64,128,196,240,255]},$={R:[0,9,24,33,40,46,52,57,62,66,70,74,78,81,85,88,91,94,98,101,103,106,109,112,114,117,119,121,124,126,128,130,133,135,137,139,141,143,145,147,149,151,153,155,157,159,161,163,164,166,168,169,171,172,174,175,177,178,180,181,183,184,186,187,189,190,191,193,194,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,222,223,224,224,225,226,226,227,228,228,229,229,230,231,231,232,233,233,234,234,235,235,236,236,236,237,237,237,238,238,238,239,239,239,240,240,240,241,241,241,242,242,242,243,243,243,243,243,243,243,243,244,244,244,244,244,244,244,244,244,244,244,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,245,244,244,244,244,244,244,244,244,244,244,244,244,244,244,244,243,243,243,243,243,243,243,243,243,243,243,243,242,242,242,242,242,242,242,242,241,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,242,243,243,244,244,245,246,246,247,247,248,249,249,250,250,251,251,252,252,253,253,254,254,254],G:[42,41,41,41,40,40,40,39,39,39,38,38,37,37,36,36,35,35,34,34,33,32,32,31,30,30,30,30,29,29,29,29,28,28,28,27,27,27,26,26,26,25,25,25,24,24,24,24,24,25,25,26,27,27,28,28,29,30,30,31,31,32,33,33,34,34,35,36,36,37,38,39,40,42,43,44,45,47,48,49,50,51,53,54,55,56,57,58,59,60,62,63,64,65,66,68,69,71,72,73,75,76,77,79,80,81,83,84,85,87,88,89,90,92,93,94,95,97,98,100,101,102,104,105,107,108,109,111,112,113,115,116,117,119,120,121,122,124,125,126,128,129,130,132,133,134,136,137,138,140,141,142,144,145,146,147,149,150,151,153,154,155,156,158,159,160,161,163,164,165,167,168,169,170,172,173,174,175,176,178,179,180,181,183,184,185,186,187,189,190,191,192,193,194,196,197,198,199,200,201,203,204,205,206,207,208,209,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,228,229,230,231,232,233,234,235,236,237,238,238,239,240,241,241,242,243,244,244,245,246,247,248,248,249,250,251,251,252,253,254,255],B:[167,167,166,166,166,165,165,165,164,164,164,163,163,162,162,162,161,161,161,160,160,160,159,159,158,158,157,157,156,155,155,154,154,153,153,152,151,151,150,150,149,149,148,147,147,146,146,145,144,144,143,143,142,141,141,140,139,139,138,137,137,136,135,135,134,133,133,132,131,131,130,130,129,128,128,127,127,126,125,125,124,124,123,123,122,121,121,120,119,119,118,118,117,116,116,116,115,115,114,114,113,113,113,112,112,111,111,110,110,109,109,109,108,108,107,107,106,106,106,106,106,105,105,105,105,105,105,105,104,104,104,104,104,103,103,103,103,103,102,102,102,103,103,103,103,104,104,104,104,104,105,105,105,105,106,106,106,106,106,107,107,107,107,108,108,109,110,111,111,112,113,113,114,115,115,116,117,117,118,119,120,120,121,122,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,140,141,142,143,144,146,147,148,149,150,152,153,155,157,158,160,162,163,165,167,168,170,172,173,175,177,178,180,182,183,185,187,188,190,193,196,199,201,204,207,210,212,215,218,221,224,226,229,232,235,238,240,243,246,249,252,255],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},tt={R:[0,86,166,255],G:[32,92,156,233],B:[76,108,117,69],A:[0,56,80,88],I:[0,64,192,255]},et={R:[0,0,0],G:[127,196,254],B:[255,255,255],A:[0,64,128],I:[0,128,255]},it={R:[0,61,122,183,244,255],G:[0,41,81,122,163,255],B:[0,25,51,76,102,255],A:[0,25,51,71,102,128],I:[0,51,102,153,204,255]},st={R:[0,61,122,183,244,255],G:[0,41,81,122,163,203],B:[0,25,51,76,102,127],A:[0,25,51,71,102,128],I:[0,51,102,153,204,255]},rt={min:-643,max:-235,R:[0,0,0],G:[154,154,154],B:[179,179,101],A:[0,32,0],I:[0,163,255]},nt={min:114,max:800,R:[0,255,255,255],G:[0,0,129,255],B:[0,0,0,255],A:[0,64,88,228],I:[0,80,160,255]},ot={min:180,max:600,R:[0,0,113,255],G:[0,0,109,250],B:[0,0,101,245],A:[0,0,100,160],I:[0,1,128,255]},at={min:-10,max:110,R:[0,127,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},lt={min:-10,max:110,R:[0,199,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},ht={min:-80,max:1e3,R:[0,189,150,150,150,150,255],G:[0,169,54,54,54,54,240],B:[0,153,52,52,52,52,242],A:[0,32,64,0,0,64,64],I:[0,1,82,92,234,242,255]},ct={min:-590,max:600,R:[0,241,241,248,248,178,178,232,255,255,255],G:[0,156,156,222,222,36,36,51,255,255,255],B:[0,130,130,169,169,24,24,37,255,255,255],A:[0,8,0,0,0,64,64,0,0,222,222],I:[0,2,3,64,122,142,172,182,252,253,255]},dt={min:114,max:302,R:[0,255,255],G:[0,129,255],B:[0,0,255],A:[0,88,228],I:[0,103,255]},mt={min:-23,max:246,R:[0,44,255,255,255],G:[0,128,90,255,255],B:[0,0,70,0,255],A:[0,0,82,184,228],I:[0,64,131,196,255]},ut={min:-100,max:246,R:[0,128,159,255,255,255,255],G:[0,0,56,90,0,255,255],B:[0,0,41,70,0,0,255],A:[0,63,105,135,167,184,228],I:[0,100,128,155,180,209,255]},ft={min:-590,max:600,R:[0,241,241,248,248,178,232,255,255],G:[0,156,156,222,222,36,51,255,255],B:[0,130,130,169,169,24,37,255,255],A:[0,63,105,135,167,184,228,228,228],I:[0,1,52,127,137,162,172,252,255]},gt={min:140,max:1024,R:[0,2,113,255],G:[0,1,109,250],B:[0,1,101,245],A:[0,1,96,168],I:[0,1,128,255]},At={min:-923,max:679,R:[0,0,0,0,0,255,255,255],G:[154,154,154,154,0,0,254,255],B:[179,179,179,179,0,0,0,255],A:[0,3,8,0,0,10,15,20],I:[0,30,62,88,170,200,232,255]},pt={min:-10,max:110,R:[0,199,255],G:[0,127,255],B:[0,127,255],A:[0,48,128],I:[0,124,255]},vt={min:-600,max:100,R:[0,134,255],G:[0,109,250],B:[0,101,245],A:[0,60,148],I:[0,128,255]},xt={min:114,max:246,R:[0,255,255],G:[0,128,255],B:[0,128,255],A:[0,64,96],I:[0,87,255]},wt={min:50,max:1e3,R:[98,210,169,128,255],G:[94,26,77,128,255],B:[45,21,74,128,255],A:[0,25,0,4,168],I:[0,41,87,154,255]},bt={R:[0,13,21,26,27,25,22,21,22,28,39,54,75,98,124,148,171,189,202,210,213,211,206,200,195,193,195,201,211,225,240,255],G:[0,5,11,20,31,44,58,72,86,99,109,116,120,122,122,122,121,121,124,129,137,147,161,175,190,205,218,229,238,245,251,255],B:[0,14,30,46,61,71,77,78,75,68,60,52,48,47,53,65,83,105,131,157,183,205,222,235,241,243,242,240,239,240,245,255],A:[0,4,8,12,17,21,25,29,33,37,41,45,50,54,58,62,66,70,74,78,83,87,91,95,99,103,107,111,116,120,124,128],I:[0,8,16,25,33,41,49,58,66,74,82,90,99,107,115,123,132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255]},yt={R:[0,10,136,255],G:[0,39,220,255],B:[0,223,253,255],A:[0,48,64,70],I:[0,92,192,255]},Ct={R:[0,245,205,120,196,220,230,0,122,236,12,204,42,119,220,103,60,255,165,160,0,245,205,120,196,220,230,0,122,236,13,220,103,255,165,160,0,120,200,255,255,164,164,164,234,0,0,0,0,0],G:[0,245,62,18,58,248,148,118,186,13,48,182,204,159,216,255,60,165,42,32,200,245,62,18,58,248,148,118,186,13,48,216,255,165,42,32,200,190,70,148,148,108,108,108,169,0,0,0,0,0],B:[0,245,78,134,250,164,34,14,220,176,255,142,164,176,20,255,60,0,42,240,200,245,78,134,250,164,34,14,220,176,255,20,255,0,42,240,221,150,255,10,10,226,226,226,30,64,112,160,208,255],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,2,3,4,5,7,8,10,11,12,13,14,15,16,17,18,24,26,28,30,31,41,42,43,44,46,47,49,50,51,52,53,54,58,60,62,63,72,77,78,79,80,81,82,85,251,252,253,254,255]},Mt={R:[0,0,128,255,255],G:[0,128,0,128,255],B:[0,125,255,0,255],A:[0,32,64,96,128],I:[0,63,128,192,255]},Dt={R:[0,142,227,255],G:[0,85,170,255],B:[0,14,76,255],A:[0,42,84,128],I:[0,85,170,255]},It={R:[0,255],G:[0,255],B:[0,255],A:[0,128],I:[0,255]},Tt={R:[0,0,0],G:[0,128,255],B:[0,0,0],A:[0,64,128],I:[0,128,255]},St={R:[0,0,0],G:[72,72,255],B:[0,255,255],A:[0,64,128],I:[0,88,255]},Ft={R:[0,255,255],G:[72,88,255],B:[0,0,0],A:[0,64,128],I:[0,88,255]},Et={R:[0,255,255,255],G:[0,0,126,255],B:[0,0,0,255],A:[0,64,96,128],I:[0,128,191,255]},Bt={R:[3,255,255,255],G:[0,0,255,255],B:[0,0,0,255],A:[0,48,96,128],I:[0,95,191,255]},Vt={R:[255,255,0,0,0,255,255],G:[0,255,255,255,0,0,0],B:[0,0,0,255,255,255,0],A:[0,14,28,43,57,71,85],I:[0,43,85,128,170,213,255]},Ut={R:[0,120,237,240],G:[0,28,105,249],B:[4,109,37,33],A:[0,56,80,88],I:[0,64,192,255]},Rt={R:[0,0,127,255,127],G:[0,127,255,127,0],B:[127,255,127,0,0],A:[0,32,64,96,128],I:[0,63,128,192,255]},Nt={R:[0,255,255],G:[0,0,255],B:[0,0,0],A:[0,64,64],I:[0,86,255]},Pt={R:[94,50,90,152,215,238,249,254,252,241,209,158],G:[79,131,186,214,240,244,237,210,157,100,57,1],B:[162,189,167,164,155,169,168,123,86,68,79,66],A:[0,12,23,35,47,58,70,81,93,105,116,128],I:[0,23,46,70,93,116,139,162,185,209,232,255]},Lt={R:[3,7,13,25,45,67,84,98,110,124,138,154,173,191,210,225,233,233,231,229,230,235,243,253],G:[19,33,48,63,77,87,92,94,95,96,96,97,99,101,106,118,133,149,163,177,192,208,225,245],B:[38,58,79,99,114,122,122,120,117,113,110,105,101,97,94,96,103,112,122,134,149,169,192,218],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},kt={R:[0,148,183,223,247,252],G:[0,44,55,74,112,253],B:[4,128,121,104,92,191],A:[0,44,53,64,75,107],I:[0,107,128,154,179,255]},Ot={R:[11,59,55,222],G:[4,45,165,245],B:[5,91,172,229],A:[0,23,70,107],I:[0,56,167,255]},Yt={R:[3,5,6,8,12,19,28,36,42,48,54,61,68,76,86,96,110,129,154,181,205,224,239,252],G:[19,32,44,58,72,86,98,108,116,122,128,134,141,149,157,167,178,191,204,216,225,232,239,244],B:[39,60,82,104,123,137,144,145,142,138,134,130,126,121,116,110,105,104,112,131,155,178,198,217],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},Gt={R:[0,85,0,0,0,0,0,0,85,255,255,255,172],G:[0,0,0,0,85,170,255,255,255,255,85,0,0],B:[0,170,85,255,255,170,170,0,85,0,0,0,0],A:[0,5,10,21,26,32,37,42,48,53,64,72,85],I:[0,15,31,63,79,95,111,127,143,159,191,217,255]},Wt={R:[13,156,237,240],G:[8,23,121,249],B:[135,158,83,33],A:[0,56,80,88],I:[0,64,192,255]},Kt={R:[208,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248,161,189,41,114,65,121,97,50,238,149,44,214,124,167,40,167,127,178,231,30,173,244,193,203,204,238,139,135,71,234,234,217,66,14,129,19,97,165,112,244,35,73,192,12,149,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248,161,189,41,114,65,121,97,50,238,149,44,214,124,167,40,167,127,178,231,30,173,244,193,203,204,238,139,135,71,234,234,217,66,14,129,19,97,165,112,244,35,73,192,12,149,71,33,192,32,195,208,173,233,202,25,210,145,89,87,245,246,38,3,25,57,167,245,86,227,208,81,64,90,199,140,48,212,180,70,120,9,192,245,177,65,157,9,193,100,181,125,145,62,8,108,36,140,237,242,248],G:[182,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21,42,22,241,61,99,115,199,166,114,190,204,60,233,66,115,230,125,103,203,125,13,176,94,131,39,198,167,124,67,175,254,1,15,198,62,237,159,31,218,58,244,47,61,67,94,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21,42,22,241,61,99,115,199,166,114,190,204,60,233,66,115,230,125,103,203,125,13,176,94,131,39,198,167,124,67,175,254,1,15,198,62,237,159,31,218,58,244,47,61,67,94,46,78,199,79,89,41,208,135,20,154,35,21,43,230,113,191,147,208,37,28,27,86,203,25,209,148,187,139,111,48,102,76,110,106,130,37,160,34,222,90,165,245,222,102,47,19,130,4,232,137,211,240,11,140,21],B:[191,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77,89,112,59,125,226,50,205,227,125,128,104,27,59,66,53,133,159,203,97,125,139,159,158,7,215,47,140,226,223,231,44,110,184,61,233,47,67,148,22,120,173,156,117,181,94,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77,89,112,59,125,226,50,205,227,125,128,104,27,59,66,53,133,159,203,97,125,139,159,158,7,215,47,140,226,223,231,44,110,184,61,233,47,67,148,22,120,173,156,117,181,94,154,43,10,207,204,164,231,136,58,239,30,147,230,101,111,150,35,128,57,252,79,173,120,25,126,81,85,8,7,122,237,190,152,246,182,130,219,67,76,167,178,235,250,28,61,186,250,199,67,58,50,86,182,108,77],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},zt={R:[0,128,255],G:[0,0,0],B:[0,0,0],A:[0,64,128],I:[0,128,255]},Qt={R:[192,224,255],G:[1,128,255],B:[0,0,0],A:[0,64,128],I:[0,128,255]},Xt={R:[3,112,144,188,236,246,255],G:[5,31,29,22,76,158,250],B:[26,87,91,86,62,117,235],A:[0,30,38,49,67,85,107],I:[0,73,92,118,160,205,255]},Ht={R:[1,240,255],G:[1,128,255],B:[1,128,255],A:[0,76,128],I:[0,153,255]},qt={R:[0,5,18,34,53,72,90,107,126,144,161,178,194,209,222,233,242,248,251,251,249,244,241,252],G:[0,4,10,11,9,11,17,23,30,36,43,50,59,70,83,98,117,136,157,177,199,220,240,254],B:[3,24,50,76,96,106,109,110,108,104,97,89,79,67,55,42,26,12,6,22,47,79,121,164],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,11,22,33,44,55,66,77,88,99,110,121,133,144,155,166,177,188,199,210,221,232,243,255]},Zt={R:[48,48,64,70,65,25,132,195,244,254,218,122],G:[18,18,64,107,150,226,255,241,199,158,57,4],B:[59,59,162,227,255,187,81,52,58,47,7,3],A:[0,22,26,30,34,43,52,57,63,67,77,86],I:[0,1,16,32,49,83,118,140,164,181,219,255]},jt={R:[0,128,255],G:[0,0,0],B:[0,128,255],A:[0,64,128],I:[0,128,255]},Jt={R:[68,49,53,253],G:[1,104,183,231],B:[84,142,121,37],A:[0,56,80,88],I:[0,64,192,255]},_t={R:[255,255,255],G:[127,196,254],B:[0,0,0],A:[0,64,128],I:[0,128,255]},$t={R:[0,0,0],G:[0,128,255],B:[255,196,128],A:[0,64,128],I:[0,128,255]},te={R:[3,64,0,0,255,255,255],G:[0,0,0,255,255,192,3],B:[0,32,48,56,64,96,128],A:[0,8,16,24,32,52,80],I:[0,32,64,96,160,192,255]},ee={min:0,max:0,R:[0,37],G:[242,0],B:[255,255],A:[0,64],I:[0,255]},ie={R:[255,255],G:[255,11],B:[0,0],A:[0,64],I:[0,255]},se={min:0,max:0,R:[65,10,223,120,216,207,251,93,252,217,21,253,131,165,173,143,144,217,86,89,63,254,172,1,142,107,42,78,221,8,222,71,127,126,167,33,104,2,208,216,0,251,7,105,2,101,248,190,253,62,255,224,166,37,110,138,45,34,6,37,69,201,43,122,199,37,173,194,103,211,75,159,96,4,239,98,110,193,253,166,40,255,48,130,140,243,101,9,177,220,133,32,4,81,48,48,210,109,60,132,1,119,1,159,247,33,212,187,253,144,196,254,168,79,64,196,39,97,73,173,104,216,217,43,101,119,254,5,237,103,203,122,57,87,251,164,19,75,200,2,252,150,66,0,255,157,23,254,55,16,240,161,69,253,207,195,5,60,255,251,200,217,134,123,253,180,27,246,130,136,250,232,4,125,140,22,253,255,13,180,123,61,254,111,10,185,76,192,255,223,186,61,198,5,172,13,83,172,171,6,23,73,134,133,109,61,213,55,57,132,36,209,2,144,1,253,68,155,3,160,2,77,121,70,67,176,223,131,4,162,232,255,150,94,235,191,207,10,246,0,225,4,209,116,57,112,172,253,1,6,92,227,73,62,135,223],G:[162,50,112,245,4,124,176,243,56,125,183,139,182,68,189,4,225,10,20,223,7,46,31,193,225,250,219,41,2,100,83,181,34,150,72,223,168,248,80,253,7,117,214,2,248,10,3,59,179,160,90,244,146,4,207,4,125,255,96,100,1,208,130,51,116,181,236,53,244,5,165,28,181,86,96,42,254,1,134,194,214,92,41,204,137,86,207,3,143,3,100,239,164,94,65,251,131,244,173,57,143,107,217,53,210,0,148,250,45,198,81,40,61,218,252,88,171,0,248,24,248,4,41,100,187,46,208,145,43,168,121,46,175,250,125,107,233,112,207,231,174,215,53,9,43,153,52,124,128,65,210,147,255,147,63,200,148,254,0,179,241,42,239,2,230,8,82,135,87,16,3,87,86,151,254,8,255,86,53,19,7,192,171,201,253,247,197,103,251,126,0,149,54,183,61,126,79,113,10,103,184,75,11,195,222,136,149,131,8,99,240,177,252,255,198,16,7,68,178,66,191,150,73,26,211,109,78,209,240,254,1,166,247,131,2,0,167,127,133,10,43,99,235,3,214,142,176,82,132,38,10,249,255,215,44,81],B:[176,182,248,37,117,35,96,69,32,152,108,20,237,250,2,89,141,216,111,251,211,149,10,44,214,103,31,251,3,32,252,246,97,1,219,167,197,4,36,116,206,118,106,43,205,204,114,69,127,205,87,80,41,251,145,204,253,161,247,1,149,9,43,253,97,72,136,161,171,181,26,255,108,80,218,214,231,255,84,31,109,4,218,3,217,36,68,85,241,39,221,2,240,2,173,42,206,5,110,46,103,27,212,184,2,207,246,45,116,72,110,253,38,105,248,159,243,81,192,93,141,145,24,157,234,131,57,178,62,75,65,176,148,40,253,66,76,240,51,154,17,251,139,253,207,9,114,49,200,254,96,73,138,118,204,102,137,89,145,161,4,112,66,234,147,178,212,205,185,11,203,131,2,250,118,169,1,185,154,53,171,197,61,175,249,96,15,254,95,5,222,75,246,194,2,61,180,25,133,165,15,233,59,35,221,140,109,7,114,255,198,0,115,168,252,23,242,80,75,142,137,255,12,182,68,201,4,111,37,228,83,248,24,192,249,5,54,223,160,122,160,114,145,119,252,31,253,250,10,214,8,47,0,142,222,70],A:[0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64],I:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]},re=new class{constructor(){M(this,"gamma",1),M(this,"version",.1),M(this,"cluts",{});const t=Object.keys(R).filter((t=>!t.startsWith("$"))).sort(new Intl.Collator("en").compare);for(const e of t)this.cluts[e]=R[e]}addColormap(t,e){this.cluts[t]=e}colormaps(){return Object.keys(this.cluts)}colorMaps(){return this.colormaps()}colormapFromKey(t){let e=this.cluts[t];return void 0!==e?e:(e=this.cluts[t.toLowerCase()],void 0!==e?e:(t.length>0&&U.warn("No color map named "+t),{min:0,max:0,R:[0,255],G:[0,255],B:[0,255],A:[0,255],I:[0,255]}))}colormap(t,e){void 0===t&&(t=""),void 0===e&&(e=!1);const i=this.colormapFromKey(t);return this.makeLut(i.R,i.G,i.B,i.A,i.I,e)}makeLabelLut(t,e){if(void 0===e&&(e=255),void 0===t.R||void 0===t.G||void 0===t.B)throw new Error(`Invalid colormap table: ${t}`);const i=t.R.length,s=t.I??[...Array(i).keys()];if(i!==t.G.length||i!==t.B.length||i!==s.length)throw new Error(`colormap does not make sense: ${t} Rs ${t.R.length} Gs ${t.G.length} Bs ${t.B.length} Is ${s.length}`);let r=new Uint8ClampedArray(i).fill(e);r[0]=0,void 0!==t.A&&(r=Uint8ClampedArray.from(t.A));const n=Math.min(...s),o=Math.max(...s),a=o-n+1,l=new Uint8ClampedArray(4*a).fill(0);for(let c=0;c<i;c++){let e=4*(s[c]-n);l[e++]=t.R[c],l[e++]=t.G[c],l[e++]=t.B[c],l[e++]=r[c]}const h={lut:l,min:n,max:o};if(t.labels){const e=t.labels.length;if(e===a)h.labels=t.labels;else if(e===i){h.labels=Array(a).fill("?");for(let e=0;e<i;e++){const i=s[e];h.labels[i]=t.labels[e]}}}return h}async makeLabelLutFromUrl(t){const e=await fetch(t),i=await e.json();return this.makeLabelLut(i)}makeDrawLut(t){let e="object"==typeof t?t:R[t];void 0===e&&(U.warn("colormap undefined ",t),e=this.colormapFromKey(""));const i=this.makeLabelLut(e,255);if(void 0===i.labels&&(i.labels=[]),i.labels.length<256){for(let t=i.labels.length;t<256;t++)i.labels.push(t.toString())}const s=new Uint8ClampedArray(1024);let r=0;for(let o=0;o<256;o++)s[r++]=255,s[r++]=0,s[r++]=0,s[r++]=255;s[3]=0;const n=Math.min(i.lut.length,1024);if(n>0)for(let o=0;o<n;o++)s[o]=i.lut[o];return{lut:s,labels:i.labels}}makeLut(t,e,i,s,r,n){const o=t.length,a=[...t],l=[...e],h=[...i];if(!r){r=new Array(o);for(let t=0;t<o;t++)r[t]=t/(o-1)*255}s||((s=new Array(o).fill(64))[0]=0);let c=Uint8ClampedArray.from(s),d=Uint8ClampedArray.from(r);if(n)for(let u=0;u<o;u++)a[u]=t[o-1-u],l[u]=e[o-1-u],h[u]=i[o-1-u],c[u]=255-s[o-1-u],d[u]=255-r[o-1-u];const m=new Uint8ClampedArray(1024);if(void 0===d){d=new Uint8ClampedArray(o).fill(0);for(let t=0;t<o;t++)d[t]=Math.round(255*t/(o-1))}void 0===c&&(c=new Uint8ClampedArray(o).fill(64),c[0]=0);for(let u=0;u<o-1;u++){const t=d[u];let e=d[u+1];0===u&&0!==t&&U.warn("colormap issue: indices expected to start with 0 not ",t),u===d.length-2&&255!==e&&(U.warn("padding colormap: indices expected end with 255 not ",e),e=255);const i=e-t;let s=4*t;for(let r=t;r<=e;r++){const e=(r-t)/i;m[s++]=a[u]+e*(a[u+1]-a[u]),m[s++]=l[u]+e*(l[u+1]-l[u]),m[s++]=h[u]+e*(h[u+1]-h[u]),m[s++]=c[u]+e*(c[u+1]-c[u])}}if(1===this.gamma)return m;for(let u=0;u<1020;u++)u%4!=3&&(m[u]=255*Math.pow(m[u]/255,1/this.gamma));return m}},ne=class{static getClusterBoundaryU8(t,e){const i=new Array(t.length).fill(!1),s=new Array(t.length).fill(!1);for(let o=0;o<t.length;o++)t[o]>0&&(s[o]=!0);const r=e.length/3;let n=0;for(let o=0;o<r;o++){const t=e[n],r=e[n+1],o=e[n+2];n+=3,s[t]===s[r]&&s[t]===s[o]&&s[r]===s[o]||(i[t]=!0,i[r]=!0,i[o]=!0)}return i}static async gzip(t){const e=new CompressionStream("gzip"),i=e.writable.getWriter();i.write(t).catch(console.error);const s=i.close().catch(console.error),r=new Response(e.readable),n=new Uint8Array(await r.arrayBuffer());return await s,n}static createMZ3(t,e,i,s){void 0===i&&(i=!1),void 0===s&&(s=null);const r=s instanceof Uint8Array&&s.length===t.length/3*4,n=r?7:3,o=e.length/3,a=t.length/3,l=3*o*4,h=3*a*4,c=new ArrayBuffer(16+l+h),d=new DataView(c);d.setUint16(0,23117,!0),d.setUint16(2,n,!0),d.setUint32(4,o,!0),d.setUint32(8,a,!0),d.setUint32(12,0,!0);let m=16;if(new Uint32Array(c,m,e.length).set(e),m+=l,new Float32Array(c,m,t.length).set(t),r&&(m+=h,new Uint8Array(c,m,s.length).set(s)),i)throw new Error("Call async createMZ3Async() for compression");return c}static async createMZ3Async(t,e,i,s){void 0===i&&(i=!1),void 0===s&&(s=null);const r=this.createMZ3(t,e,i,s);return i?await this.gzip(new Uint8Array(r)):r}static createOBJ(t,e){let i="";for(let s=0;s<t.length;s+=3)i+=`v ${t[s]} ${t[s+1]} ${t[s+2]}\n`;for(let s=0;s<e.length;s+=3)i+=`f ${e[s]+1} ${e[s+1]+1} ${e[s+2]+1}\n`;return(new TextEncoder).encode(i).buffer}static createSTL(t,e){const i=e.length/3,s=new ArrayBuffer(84+50*i),r=new DataView(s);for(let o=0;o<80;o++)r.setUint8(o,0);r.setUint32(80,i,!0);let n=84;for(let o=0;o<e.length;o+=3){const i=3*e[o],s=3*e[o+1],a=3*e[o+2];r.setFloat32(n,0,!0),r.setFloat32(n+4,0,!0),r.setFloat32(n+8,0,!0),n+=12,r.setFloat32(n,t[i],!0),r.setFloat32(n+4,t[i+1],!0),r.setFloat32(n+8,t[i+2],!0),n+=12,r.setFloat32(n,t[s],!0),r.setFloat32(n+4,t[s+1],!0),r.setFloat32(n+8,t[s+2],!0),n+=12,r.setFloat32(n,t[a],!0),r.setFloat32(n+4,t[a+1],!0),r.setFloat32(n+8,t[a+2],!0),n+=12,r.setUint16(n,0,!0),n+=2}return s}static downloadArrayBuffer(t,e){const i=new Blob([t],{type:"application/octet-stream"}),s=URL.createObjectURL(i),r=document.createElement("a");r.href=s,r.download=e,document.body.appendChild(r),r.style.display="none",r.click(),setTimeout((()=>{document.body.removeChild(r),URL.revokeObjectURL(s)}),0)}static async saveMesh(t,e,i,s){void 0===i&&(i=".mz3"),void 0===s&&(s=!1);let r=new ArrayBuffer(0);return/\.obj$/i.test(i)?r=this.createOBJ(t,e):/\.stl$/i.test(i)?r=this.createSTL(t,e):(/\.mz3$/i.test(i)||(i+=".mz3"),r=await this.createMZ3Async(t,e,s)),i.length>4&&this.downloadArrayBuffer(r,i),r}static getClusterBoundary(t,e){const i=new Uint32Array(t.buffer),s=new Array(i.length).fill(!1),r=e.length/3;let n=0;for(let o=0;o<r;o++){const t=e[n],r=e[n+1],o=e[n+2];n+=3,i[t]===i[r]&&i[t]===i[o]&&i[r]===i[o]||(s[t]=!0,s[r]=!0,s[o]=!0)}return s}static getExtents(t){if(!ArrayBuffer.isView(t)&&!Array.isArray(t)||t.length<3)return{mxDx:0,extentsMin:0,extentsMax:0};let e=0;const i=r.fA(t[0],t[1],t[2]),s=r.fA(t[0],t[1],t[2]);for(let n=0;n<t.length;n+=3){const o=r.fA(t[n],t[n+1],t[n+2]);e=Math.max(e,r.Il(o)),r.jk(i,i,o),r.T9(s,s,o)}return{mxDx:e,extentsMin:[i[0],i[1],i[2]],extentsMax:[s[0],s[1],s[2]]}}static generateNormals(t,e){const i=[];let s;const r=t.length;let n,o,a,l,h,c,d,m,u;const f=new Float32Array(r),g=e.length;for(s=0;s<g;s+=3){d=3*e[s],m=3*e[s+1],u=3*e[s+2];const r=[t[d],t[d+1],t[d+2]],g=[t[m],t[m+1],t[m+2]],A=[t[u],t[u+1],t[u+2]];n=g[0]-r[0],o=g[1]-r[1],a=g[2]-r[2],l=A[0]-r[0],h=A[1]-r[1],c=A[2]-r[2],i[0]=h*a-c*o,i[1]=c*n-l*a,i[2]=l*o-h*n,f[d]+=i[0],f[d+1]+=i[1],f[d+2]+=i[2],f[m]+=i[0],f[m+1]+=i[1],f[m+2]+=i[2],f[u]+=i[0],f[u+1]+=i[1],f[u+2]+=i[2]}for(s=0;s<r;s+=3){i[0]=-1*f[s],i[1]=-1*f[s+1],i[2]=-1*f[s+2];let t=i[0]*i[0]+i[1]*i[1]+i[2]*i[2];t>0&&(t=1/Math.sqrt(t),i[0]*=t,i[1]*=t,i[2]*=t),f[s]=i[0],f[s+1]=i[1],f[s+2]=i[2]}return f}},oe=class{constructor(t){T(this,N),T(this,P,0),T(this,L,[]),T(this,k,[]),T(this,O),S(this,N,new DataView(t)),this.read()}async extract(t){const e=new Uint8Array(I(this,N).buffer.slice(t.startsAt,t.startsAt+t.compressedSize));if(0===t.compressionMethod)return e;if(8===t.compressionMethod){const t=new DecompressionStream("deflate-raw"),i=t.writable.getWriter();i.write(e).catch(console.error);const s=i.close().catch(console.error),r=new Response(t.readable),n=new Uint8Array(await r.arrayBuffer());return await s,n}throw new Error(`Unsupported compression method: ${t.compressionMethod}`)}read(){for(;!I(this,O)&&I(this,P)<I(this,N).byteLength;){const t=I(this,N).getUint32(I(this,P),!0);if(67324752===t){const t=this.readLocalFile(I(this,P));t.extract=this.extract.bind(this,t),I(this,L).push(t);const e=!!(8&t.generalPurpose);if(t.startsAt=I(this,P)+30+t.fileNameLength+t.extraLength,0===t.compressedSize&&e){let e=t.startsAt;for(;e+20<=I(this,N).byteLength;){if(134695760===I(this,N).getUint32(e,!0)){if(19280===I(this,N).getUint16(e+16,!0)){e+=4;break}}e++}t.crc=I(this,N).getUint32(e,!0),t.compressedSize=I(this,N).getUint32(e+4,!0),t.uncompressedSize=I(this,N).getUint32(e+8,!0),S(this,P,e+12)}else S(this,P,t.startsAt+t.compressedSize)}else{if(33639248!==t){if(101010256===t){S(this,O,this.readEndCentralDirectory(I(this,P)));break}if(101075792===t){S(this,O,this.readEndCentralDirectory64(I(this,P)));break}console.error(`Unexpected ZIP signature 0x${t.toString(16).padStart(8,"0")} at index ${I(this,P)}`);break}{const t=this.readCentralDirectory(I(this,P));I(this,k).push(t),S(this,P,I(this,P)+(46+t.fileNameLength+t.extraLength+t.fileCommentLength))}}}}readLocalFile(t){let e=I(this,N).getUint32(t+18,!0),i=I(this,N).getUint32(t+22,!0);const s=I(this,N).getUint16(t+26,!0),r=I(this,N).getUint16(t+28,!0),n=t+30+s;this.readString(n,r);if(4294967295===e&&4294967295===i){let t=n,s=!1;for(;t<n+r-4;){const r=I(this,N).getUint16(t,!0),n=I(this,N).getUint16(t+2,!0);if(t+=4,1===r){if(n>=16){i=Number(I(this,N).getBigUint64(t,!0)),t+=8,e=Number(I(this,N).getBigUint64(t,!0)),s=!0;break}throw new Error(`ZIP64 extra field found but is too small (expected at least 16 bytes, got ${n}).`)}t+=n}if(!s)throw new Error("ZIP64 format missing extra field with signature 0x0001.")}return{signature:this.readString(t,4),version:I(this,N).getUint16(t+4,!0),generalPurpose:I(this,N).getUint16(t+6,!0),compressionMethod:I(this,N).getUint16(t+8,!0),lastModifiedTime:I(this,N).getUint16(t+10,!0),lastModifiedDate:I(this,N).getUint16(t+12,!0),crc:I(this,N).getUint32(t+14,!0),compressedSize:e,uncompressedSize:i,fileNameLength:s,extraLength:r,fileName:this.readString(t+30,s),extra:this.readString(t+30+s,r)}}readCentralDirectory(t){return{versionCreated:I(this,N).getUint16(t+4,!0),versionNeeded:I(this,N).getUint16(t+6,!0),fileNameLength:I(this,N).getUint16(t+28,!0),extraLength:I(this,N).getUint16(t+30,!0),fileCommentLength:I(this,N).getUint16(t+32,!0),diskNumber:I(this,N).getUint16(t+34,!0),internalAttributes:I(this,N).getUint16(t+36,!0),externalAttributes:I(this,N).getUint32(t+38,!0),offset:I(this,N).getUint32(t+42,!0),comments:this.readString(t+46,I(this,N).getUint16(t+32,!0))}}readEndCentralDirectory(t){const e=I(this,N).getUint16(t+20,!0);return{numberOfDisks:I(this,N).getUint16(t+4,!0),centralDirectoryStartDisk:I(this,N).getUint16(t+6,!0),numberCentralDirectoryRecordsOnThisDisk:I(this,N).getUint16(t+8,!0),numberCentralDirectoryRecords:I(this,N).getUint16(t+10,!0),centralDirectorySize:I(this,N).getUint32(t+12,!0),centralDirectoryOffset:I(this,N).getUint32(t+16,!0),commentLength:e,comment:this.readString(t+22,e)}}readEndCentralDirectory64(t){const e=Number(I(this,N).getBigUint64(t+0,!0));return{numberOfDisks:I(this,N).getUint32(t+16,!0),centralDirectoryStartDisk:I(this,N).getUint32(t+20,!0),numberCentralDirectoryRecordsOnThisDisk:Number(I(this,N).getBigUint64(t+24,!0)),numberCentralDirectoryRecords:Number(I(this,N).getBigUint64(t+32,!0)),centralDirectorySize:Number(I(this,N).getBigUint64(t+40,!0)),centralDirectoryOffset:Number(I(this,N).getBigUint64(t+48,!0)),commentLength:e,comment:""}}readString(t,e){return Array.from({length:e},((e,i)=>String.fromCharCode(I(this,N).getUint8(t+i)))).join("")}get entries(){return I(this,L)}};N=new WeakMap,P=new WeakMap,L=new WeakMap,k=new WeakMap,O=new WeakMap;var ae=class t{static arrayBufferToBase64(e){const i=new Uint8Array(e);return t.uint8tob64(i)}static async decompress(t){const e=31===t[0]&&139===t[1]&&8===t[2]?"gzip":120!==t[0]||1!==t[1]&&94!==t[1]&&156!==t[1]&&218!==t[1]?"deflate-raw":"deflate",i=new DecompressionStream(e),s=i.writable.getWriter();s.write(t).catch(console.error);const r=s.close().catch(console.error),n=new Response(i.readable),o=new Uint8Array(await n.arrayBuffer());return await r,o}static async decompressToBuffer(e){const i=await t.decompress(e);return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}static async readMatV4(t,e){void 0===e&&(e=!1);let i=t.byteLength;if(i<40)throw new Error("File too small to be MAT v4: bytes = "+t.byteLength);let s=new DataView(t),r=s.getUint16(0,!0),n=t;if(35615===r||8075===r){const e=await this.decompress(new Uint8Array(t));s=new DataView(e.buffer),r=s.getUint16(0,!0),n=e.buffer,i=n.byteLength}const o=new TextDecoder("utf-8"),a=new Uint8Array(n);let l=0;const h={};function c(){const t=s.getUint32(l,!0),i=s.getUint32(l+4,!0),r=s.getUint32(l+8,!0),n=s.getUint32(l+12,!0),c=s.getUint32(l+16,!0);if(l+=20,0!==n)throw new Error("Matlab V4 reader does not support imaginary numbers");const d=i*r;if(d<1)throw new Error("mrows * ncols must be greater than one");const m=new Uint8Array(a.subarray(l,l+c));let u=o.decode(m).trim().replaceAll("\0","");e&&(u=u.replaceAll(".","_"));const f=(g=t,Math.floor(g/10)%10);var g;let A=8;if(f>=1&&f<=2)A=4;else if(f>=3&&f<=4)A=2;else if(5===f)A=1;else if(0!==f)throw new Error("impossible Matlab v4 datatype");if(l+=c,t>50)throw new Error("Does not appear to be little-endian V4 Matlab file");const p=l+d*A;h[u]=function(t,e,i){const s=new Uint8Array(a.subarray(e,i));return 1===t?new Float32Array(s.buffer):2===t?new Int32Array(s.buffer):3===t?new Int16Array(s.buffer):4===t?new Uint16Array(s.buffer):5===t?new Uint8Array(s.buffer):new Float64Array(s.buffer)}(f,l,p),l=p}for(;l+20<i;)c();return h}static b64toUint8(t){const e=atob(t),i=e.length,s=new Uint8Array(i);for(let r=0;r<i;r++)s[r]=e.charCodeAt(r);return s}static uint8tob64(t){let e="";const i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=t.byteLength,r=s%3,n=s-r;let o,a,l,h,c;for(let d=0;d<n;d+=3)c=t[d]<<16|t[d+1]<<8|t[d+2],o=(16515072&c)>>18,a=(258048&c)>>12,l=(4032&c)>>6,h=63&c,e+=i[o]+i[a]+i[l]+i[h];return 1===r?(c=t[n],o=(252&c)>>2,a=(3&c)<<4,e+=i[o]+i[a]+"=="):2===r&&(c=t[n]<<8|t[n+1],o=(64512&c)>>10,a=(1008&c)>>4,l=(15&c)<<2,e+=i[o]+i[a]+i[l]+"="),e}static download(t,e,i){const s=document.createElement("a"),r=Array.isArray(t)?t:[t],n=new Blob(r,{type:i});s.href=URL.createObjectURL(n),s.download=e,s.click()}static readFileAsync(t){return new Promise(((e,i)=>{const s=new FileReader;s.onload=()=>{e(s.result)},s.onerror=i,s.readAsArrayBuffer(t)}))}static blobToBase64(t){return new Promise((e=>{const i=new FileReader;i.onloadend=()=>e(i.result),i.readAsDataURL(t)}))}static async decompressBase64String(e){const i=atob(e),s=new ArrayBuffer(i.length),r=new Uint8Array(s);for(let t=0;t<i.length;t++)r[t]=i.charCodeAt(t);return t.decompressArrayBuffer(r)}static async compressToBase64String(e){const i=await t.compressStringToArrayBuffer(e);return t.uint8tob64(new Uint8Array(i))}static strToU8(t,e){if(e){const e=new Uint8Array(t.length);for(let i=0;i<t.length;++i)e[i]=t.charCodeAt(i);return e}const i=t.length;let s=new Uint8Array(t.length+(t.length>>1)),r=0;const n=t=>{s[r++]=t};for(let h=0;h<i;++h){if(r+5>s.length){const t=new Uint8Array(r+8+(i-h<<1));t.set(s),s=t}let o=t.charCodeAt(h);o<128||e?n(o):o<2048?(n(192|o>>6),n(128|63&o)):(o=65536+(1047552&o)|1023&t.charCodeAt(++h),n(240|o>>18),n(128|o>>12&63),n(128|o>>6&63),n(128|63&o))}return o=s,(null==(a=0)||a<0)&&(a=0),(null==(l=r)||l>o.length)&&(l=o.length),new Uint8Array(o.subarray(a,l));var o,a,l}static async compress(t,e){void 0===e&&(e="gzip");const i=new CompressionStream(e),s=i.writable.getWriter();s.write(t).catch(console.error);const r=s.close().catch(console.error),n=new Response(i.readable),o=await n.arrayBuffer();return await r,o}static async compressStringToArrayBuffer(t){const e=this.strToU8(t);return await this.compress(e)}static isArrayBufferCompressed(t){if(t&&t.byteLength){const e=new Uint8Array(t);return 8075===(e[0]<<8|e[1])}return!1}static strFromU8(t,e){if(e){let e="";for(let i=0;i<t.length;i+=16384)e+=String.fromCharCode.apply(null,t.subarray(i,i+16384));return e}{const e=(t,e,i)=>((null==e||e<0)&&(e=0),(null==i||i>t.length)&&(i=t.length),new Uint8Array(t.subarray(e,i))),i=t=>{for(let i="",s=0;;){let r=t[s++];const n=(r>127)+(r>223)+(r>239);if(s+n>t.length)return{s:i,r:e(t,s-1)};n?3===n?(r=((15&r)<<18|(63&t[s++])<<12|(63&t[s++])<<6|63&t[s++])-65536,i+=String.fromCharCode(55296|r>>10,56320|1023&r)):i+=1&n?String.fromCharCode((31&r)<<6|63&t[s++]):String.fromCharCode((15&r)<<12|(63&t[s++])<<6|63&t[s++]):i+=String.fromCharCode(r)}},{s:s,r:r}=i(t);if(r.length)throw new Error("Unexpected trailing bytes in UTF-8 decoding");return s}}static async decompressArrayBuffer(t){const e=await this.decompress(new Uint8Array(t));return this.strFromU8(e)}static arraysAreEqual(t,e){return l(t,e)}static range(t,e,i){return Array.from({length:(e-t)/i+1},((e,s)=>t+s*i))}static sph2cartDeg(t,e){const i=-e*(Math.PI/180),s=(t-90)%360*(Math.PI/180),r=[Math.cos(i)*Math.cos(s),Math.cos(i)*Math.sin(s),Math.sin(i)],n=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);return n<=0||(r[0]/=n,r[1]/=n,r[2]/=n),r}static vox2mm(t,e){const i=n.o8(e);n.mg(i,i);const o=s.fA(t[0],t[1],t[2],1);s.Z0(o,o,i);return r.fA(o[0],o[1],o[2])}},le=U,he=class t{static readTRACT(t){const e=t.byteLength;if(e<20)throw new Error("File too small to be niml.tract: bytes = "+e);const i=new DataView(t),s=new Uint8Array(t);let r=0;function n(){for(;r<e&&60!==s[r];)r++;const i=r;for(;r<e&&62!==s[r];)r++;return r++,r-i<1?"":(new TextDecoder).decode(t.slice(i,r-1)).trim()}let o=n();function a(t){const e=o.indexOf(t);if(e<0)return 0;const i=o.indexOf('"',e)+1,s=o.indexOf('"',i),r=o.slice(i,s);return parseInt(r)}const l=a("N_tracts=");(!o.startsWith("<network")||l<1)&&U.warn("This is not a valid niml.tract file "+o);let h=0;const c=[];c.push(h);const d=[],m=[];for(let f=0;f<l;f++){o=n();const t=a("ni_dimen="),e=a("Bundle_Tag="),s=o.includes("binary.lsbfirst");for(let n=0;n<t;n++){r+=4;const t=i.getUint32(r,s)/3;r+=4;for(let e=0;e<t;e++)d.push(i.getFloat32(r,s)),r+=4,d.push(-i.getFloat32(r,s)),r+=4,d.push(i.getFloat32(r,s)),r+=4;h+=t,c.push(h),m.push(e)}o=n()}const u=[];return u.push({id:"tract",vals:Float32Array.from(m)}),{pts:new Float32Array(d),offsetPt0:new Uint32Array(c),dps:u}}static async readTT(t){let e=new Uint32Array(0),i=new Float32Array(0);const r=await ae.readMatV4(t);if(!("trans_to_mni"in r))throw new Error("TT format file must have 'trans_to_mni'");if(!("voxel_size"in r))throw new Error("TT format file must have 'voxel_size'");if(!("track"in r))throw new Error("TT format file must have 'track'");let o=n.vt();const a=r.trans_to_mni;return o=n.fA(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]),n.mg(o,o),function(t){const r=new DataView(t.buffer),n=[];let a=0,l=0;for(;l<t.length;){n.push(l);const t=r.getUint32(l,!0);l=l+t+13,a+=t}e=new Uint32Array(n.length+1),i=new Float32Array(a);let h=0;for(let s=0;s<n.length;s++){e[s]=h/3;let t=n[s];const o=r.getUint32(t,!0)/3;let a=r.getInt32(t+4,!0),l=r.getInt32(t+8,!0),c=r.getInt32(t+12,!0);t+=16,i[h++]=a,i[h++]=l,i[h++]=c;for(let e=2;e<=o;e++)a+=r.getInt8(t++),l+=r.getInt8(t++),c+=r.getInt8(t++),i[h++]=a,i[h++]=l,i[h++]=c}for(let e=0;e<h;e++)i[e]=i[e]/32;let c=0;for(let e=0;e<h/3;e++){const t=s.fA(i[c],i[c+1],i[c+2],1);s.Z0(t,t,o),i[c++]=t[0],i[c++]=t[1],i[c++]=t[2]}e[n.length]=h/3}(r.track),{pts:i,offsetPt0:e}}static async readTRX(t){function e(t){const e=(31744&t)>>10,i=1023&t;return(t>>15?-1:1)*(e?31===e?i?NaN:1/0:Math.pow(2,e-15)*(1+i/1024):i/1024*6103515625e-14)}let i=0,s=0,r=new Float32Array([]);const n=[],o=[],a=[],l=[];let h=[],c=!1;const d=new oe(t);for(let m=0;m<d.entries.length;m++){const t=d.entries[m];if(0===t.uncompressedSize)continue;const u=t.fileName.split("/"),f=u.slice(-1)[0];if(f.startsWith("."))continue;const g=u.slice(-2)[0],A=f.split(".")[0],p=await t.extract();if(f.includes("header.json")){const t=(new TextDecoder).decode(p);h=JSON.parse(t);continue}let v=0,x=[];if(f.endsWith(".uint64")||f.endsWith(".int64")){v=p.length/8,x=new Uint32Array(v);const t=new Uint32Array(p.buffer);let e=0;for(let i=0;i<v;i++)x[i]=t[e],0!==t[e+1]&&(c=!0),e+=2}else if(f.endsWith(".uint32"))x=new Uint32Array(p.buffer);else if(f.endsWith(".uint16"))x=new Uint16Array(p.buffer);else if(f.endsWith(".uint8"))x=new Uint8Array(p.buffer);else if(f.endsWith(".int32"))x=new Int32Array(p.buffer);else if(f.endsWith(".int16"))x=new Int16Array(p.buffer);else if(f.endsWith(".int8"))x=new Int8Array(p.buffer);else if(f.endsWith(".float64"))x=new Float64Array(p.buffer);else if(f.endsWith(".float32"))x=new Float32Array(p.buffer);else{if(!f.endsWith(".float16"))continue;{v=p.length/2,x=new Float32Array(v);const t=new Uint16Array(p.buffer),i=new Float32Array(65536);for(let s=0;s<65536;s++)i[s]=e(s);for(let e=0;e<v;e++)x[e]=i[t[e]]}}if(v=x.length,g.includes("groups"))o.push({id:A,vals:Float32Array.from(x.slice())});else if(g.includes("dpv"))l.push({id:A,vals:Float32Array.from(x.slice())});else if(g.includes("dps"))a.push({id:A,vals:Float32Array.from(x.slice())});else{if(f.startsWith("offsets.")){i=v;for(let t=0;t<v;t++)n[t]=x[t]}f.startsWith("positions.3.")&&(s=v,r=new Float32Array(x))}}if(0===i||0===s)throw new Error("Failure reading TRX format (no offsets or points).");if(c)throw new Error("Too many vertices: JavaScript does not support 64 bit integers");return n[i]=s/3,{pts:r,offsetPt0:new Uint32Array(n),dpg:o,dps:a,dpv:l,header:h}}static readTSF(t,e){void 0===e&&(e=0);const i=new Float32Array(e),s=t.byteLength;if(s<20)throw new Error("File too small to be TSF: bytes = "+s);const r=new Uint8Array(t);let n=0;function o(){for(;n<s&&10===r[n];)n++;const e=n;for(;n<s&&10!==r[n];)n++;return n++,n-e<1?"":(new TextDecoder).decode(t.slice(e,n-1))}let a=o();if(!a.includes("mrtrix track scalars"))throw new Error("Not a valid TSF file");let l=-1;for(;n<s&&!a.includes("END");)if(a=o(),a.toLowerCase().startsWith("file:")&&(l=parseInt(a.split(" ").pop())),a.toLowerCase().startsWith("datatype:")&&!a.endsWith("Float32LE"))throw new Error("Only supports TSF files with Float32LE");if(l<20)throw new Error("Not a valid TSF file (missing file offset)");n=l;const h=new DataView(t);let c=0;for(;n+4<=s&&c<e;){const t=h.getFloat32(n,!0);if(n+=4,isFinite(t))i[c++]=t;else if(!isNaN(t))break}return i}static readTCK(t){const e=t.byteLength;if(e<20)throw new Error("File too small to be TCK: bytes = "+e);const i=new Uint8Array(t);let s=0;function r(){for(;s<e&&10===i[s];)s++;const r=s;for(;s<e&&10!==i[s];)s++;return s++,s-r<1?"":(new TextDecoder).decode(t.slice(r,s-1))}let n=r();if(!n.includes("mrtrix tracks"))throw new Error("Not a valid TCK file");let o=-1;for(;s<e&&!n.includes("END");)n=r(),n.toLowerCase().startsWith("file:")&&(o=parseInt(n.split(" ").pop()));if(o<20)throw new Error("Not a valid TCK file (missing file offset)");s=o;const a=new DataView(t);let l=0,h=new Uint32Array(e/16),c=0,d=0,m=new Float32Array(e/4);for(h[0]=0;s+12<e;){const t=a.getFloat32(s,!0);s+=4;const e=a.getFloat32(s,!0);s+=4;const i=a.getFloat32(s,!0);if(s+=4,isFinite(t))m[d++]=t,m[d++]=e,m[d++]=i,l++;else if(h[c++]=l,!isNaN(t))break}return m=m.slice(0,d),h=h.slice(0,c),{pts:m,offsetPt0:h}}static async readTRK(t){let e=new DataView(t),i=e.getUint32(0,!0);if(1128354388!==i){let s;if(4247762216===i)throw new Error("zstd TRK decompression is not supported");s=await ae.decompress(new Uint8Array(t)),t=s.buffer,e=new DataView(t),i=e.getUint32(0,!0)}const s=e.getUint32(992,!0),r=e.getUint32(996,!0);if(s>2||1e3!==r||1128354388!==i)throw new Error("Not a valid TRK file");const o=e.getInt16(36,!0),a=[];for(let n=0;n<o;n++){const e=new Uint8Array(t.slice(38+20*n,58+20*n)),i=(new TextDecoder).decode(e).split("\0").shift();a.push({id:i.trim(),vals:[]})}const l=e.getFloat32(12,!0),h=e.getFloat32(16,!0),c=e.getFloat32(20,!0),d=n.fA(1/l,0,0,-.5,0,1/h,0,-.5,0,0,1/c,-.5,0,0,0,1),m=e.getInt16(238,!0),u=[];for(let n=0;n<m;n++){const e=new Uint8Array(t.slice(240+20*n,260+20*n)),i=(new TextDecoder).decode(e).split("\0").shift();u.push({id:i.trim(),vals:[]})}const f=n.vt();for(let n=0;n<16;n++)f[n]=e.getFloat32(440+4*n,!0);0===f[15]&&(U.warn("TRK vox_to_ras not set"),n.D_(f));const g=n.vt();n.lK(g,d,f);let A=null,p=null;A=new Int32Array(t.slice(r)),p=new Float32Array(A.buffer);const v=A.length;if(v<1)throw new Error("Empty TRK file.");let x=0,w=0,b=new Uint32Array(A.length/4),y=0,C=new Float32Array(A.length),M=0;for(;x<v;){const t=A[x];x+=1,b[y++]=w;for(let e=0;e<t;e++){const t=p[x+0],e=p[x+1],i=p[x+2];if(x+=3,C[M++]=t*g[0]+e*g[1]+i*g[2]+g[3],C[M++]=t*g[4]+e*g[5]+i*g[6]+g[7],C[M++]=t*g[8]+e*g[9]+i*g[10]+g[11],o>0)for(let s=0;s<o;s++)a[s].vals.push(p[x]),x++;w++}if(m>0)for(let e=0;e<m;e++)u[e].vals.push(p[x]),x++}const D=[];for(let n=0;n<u.length;n++)D.push({id:u[n].id,vals:Float32Array.from(u[n].vals)});const I=[];for(let n=0;n<a.length;n++)I.push({id:a[n].id,vals:Float32Array.from(a[n].vals)});return b[y++]=w,C=C.slice(0,M),b=b.slice(0,y),{pts:C,offsetPt0:b,dps:D,dpv:I}}static readTxtVTK(t){const e=new TextDecoder("utf-8").decode(t).split("\n");if(e.length<7||!e[0].startsWith("# vtk DataFile"))throw new Error("Invalid VTK image");if(!e[2].startsWith("ASCII"))throw new Error("Not ASCII VTK mesh");let i=3;for(;e[i].length<1;)i++;if(!e[i].includes("POLYDATA"))throw new Error("Not ASCII VTK polydata");for(i++;e[i].length<1;)i++;if(!e[i].startsWith("POINTS"))throw new Error("Not VTK POINTS");let s=e[i].trim().split(/\s+/);const r=parseInt(s[1]),n=3*r,o=new Float32Array(3*r);let a=0;for(;a<3*r;){i++;const t=e[i].trim().trim().split(/\s+/);for(let e=0;e<t.length&&!(a>=n);e++)o[a]=parseFloat(t[e]),a++}const l=[];for(i++;e[i].length<1;)i++;if(e[i].startsWith("METADATA")){for(;e[i].length>1;)i++;i++}if(s=e[i].trim().split(/\s+/),i++,s[0].includes("LINES")){const t=parseInt(s[1]);if(t<1)throw new Error("Corrupted VTK ASCII");let r=e[i].trim();const n=[];let a=[];if(r.startsWith("OFFSETS")){i++;let s=0;for(;s<t;){r=e[i].trim(),i++;const o=r.trim().split(/\s+/);for(let e=0;e<o.length&&(n[s]=parseInt(o[e]),s++,!(s>=t));e++);}a=Array.from(o)}else{let s=function(){r=e[i].trim();const t=r.trim().split(/\s+/);h=[];for(let e=0;e<t.length;e++)h.push(parseInt(t[e]));c=0,i++},l=0;n[0]=0;let h=[],c=0;s();for(let e=0;e<t;e++){c>=h.length&&s();const t=h[c++];l+=t,n[e+1]=l;for(let e=0;e<t;e++){c>=h.length&&s();const t=3*h[c++];a.push(o[t+0]),a.push(o[t+1]),a.push(o[t+2])}}}return{pts:Float32Array.from(a),offsetPt0:Uint32Array.from(n)}}if(s[0].includes("TRIANGLE_STRIPS")){const t=parseInt(s[1]);for(let s=0;s<t;s++){const t=e[i].trim();i++;const s=t.trim().split(/\s+/),r=parseInt(s[0])-2;let n=1;for(let e=0;e<r;e++)e%2?(l.push(parseInt(s[n+2])),l.push(parseInt(s[n+1])),l.push(parseInt(s[n]))):(l.push(parseInt(s[n])),l.push(parseInt(s[n+1])),l.push(parseInt(s[n+2]))),n+=1}}else{if(!s[0].includes("POLYGONS"))throw new Error("Unsupported ASCII VTK datatype "+s[0]);{const t=parseInt(s[1]);for(let s=0;s<t;s++){const t=e[i].trim();i++;const s=t.trim().split(/\s+/),r=parseInt(s[0])-2,n=parseInt(s[1]);let o=parseInt(s[2]);for(let e=0;e<r;e++){const t=parseInt(s[3+e]);l.push(n),l.push(o),l.push(t),o=t}}}}return{positions:o,indices:new Uint32Array(l)}}static async readLayer(e,i,s,r,n,o,a,l,h,c){void 0===e&&(e=""),void 0===r&&(r=.5),void 0===n&&(n="warm"),void 0===o&&(o="winter"),void 0===a&&(a=!1),void 0===l&&(l=null),void 0===h&&(h=null),void 0===c&&(c=0);const d={...Ye,colormapInvert:!1,colormapType:0,isTransparentBelowCalMin:!0,isAdditiveBlend:!1,colorbarVisible:!0,colormapLabel:null},m=/(?:\.([^.]+))?$/;let u=m.exec(e)[1];u=u.toUpperCase(),"GZ"===u&&(u=m.exec(e.slice(0,-3))[1],u=u.toUpperCase());const f=s.vertexCount/3;if(s.offsetPt0){if("TSF"!==u)throw new Error("readLayer for streamlines only supports TSF files.");const r=s.pts.length/3,n=e.split("/");let o="Unknown";if(n.length>1){n.pop()&&(o=o.split(".").slice(0,-1).join("."))}const a=t.readTSF(i,r);s.dpv||(s.dpv=[]);const l=a.reduce(((t,e)=>Math.min(t,e))),h=a.reduce(((t,e)=>Math.max(t,e)));return s.dpv.push({id:o,vals:Float32Array.from(a.slice()),global_min:l,global_max:h,cal_min:l,cal_max:h}),d}if(f<3)return void U.error("n_vert < 3 in layer");if("MZ3"===u){const e=await t.readMZ3(i,f);d.values=e.scalars,"colormapLabel"in e&&(d.colormapLabel=e.colormapLabel)}else if("ANNOT"===u){const e=t.readANNOT(i,f,!0);e instanceof Uint32Array?d.values=e:(d.values=e.scalars,d.colormapLabel=e.colormapLabel)}else if("CRV"===u||"CURV"===u||"THICKNESS"===u||"AREA"===u)d.values=t.readCURV(i,f),d.isTransparentBelowCalMin=!1;else if("GII"===u){const e=await t.readGII(i,f);d.values=e.scalars,d.colormapLabel=e.colormapLabel}else if("MGH"===u||"MGZ"===u){const e=await t.readMGH(i,f,!0);"scalars"in e?(d.values=e.scalars,d.colormapLabel=e.colormapLabel):d.values=e}else if("NII"===u)d.values=await t.readNII(i,f,s.anatomicalStructurePrimary);else if("SMP"===u)d.values=await t.readSMP(i,f);else if("STC"===u)d.values=t.readSTC(i,f);else{if(!t.isCurv(i))return U.warn("Unknown layer overlay format "+e),d;d.values=t.readCURV(i,f),d.isTransparentBelowCalMin=!1}if(!d.values)return void U.error("no values in layer");d.nFrame4D=d.values.length/f,d.frame4D=0,d.outlineBorder=c;let g=d.values[0],A=d.values[0];for(let t=0;t<d.values.length;t++)g=Math.min(g,d.values[t]),A=Math.max(A,d.values[t]);return d.global_min=g,d.global_max=A,d.cal_min=l||0,l||(d.cal_min=g),d.cal_max=h||0,h||(d.cal_max=A),d.cal_minNeg=NaN,d.cal_maxNeg=NaN,d.opacity=r,d.colormap=n,d.colormapNegative=o,d.useNegativeCmap=a,d}static async readSMP(t,e){const i=t.byteLength;let s=new DataView(t),r=s.getUint16(0,!0);if(r>5){const e=await ae.decompress(new Uint8Array(t));s=new DataView(e.buffer),r=s.getUint16(0,!0),t=e.buffer}r>5&&U.error("Unsupported or invalid BrainVoyager SMP version "+r);const n=s.getUint32(2,!0);n!==e&&U.error("SMP file has "+n+" vertices, background mesh has "+e);const o=s.getUint16(6,!0),a=new Float32Array(n*o),l=[];let h=9;function c(){const e=h;for(;h<i&&0!==s.getUint8(h);)h++;return h++,(new TextDecoder).decode(t.slice(e,h-1))}c();for(let d=0;d<o;d++){const e={};e.mapType=s.getUint32(h,!0),h+=4,r>=3&&3===e.mapType&&(e.nLags=s.getUint32(h,!0),h+=4,e.mnLag=s.getUint32(h,!0),h+=4,e.mxLag=s.getUint32(h,!0),h+=4,e.ccOverlay=s.getUint32(h,!0),h+=4),e.clusterSize=s.getUint32(h,!0),h+=4,e.clusterCheck=s.getUint8(h),h+=1,e.critThresh=s.getFloat32(h,!0),h+=4,e.maxThresh=s.getFloat32(h,!0),h+=4,r>=4&&(e.includeValuesGreaterThreshMax=s.getUint32(h,!0),h+=4),e.df1=s.getUint32(h,!0),h+=4,e.df2=s.getUint32(h,!0),h+=4,r>=5?(e.posNegFlag=s.getUint32(h,!0),h+=4):e.posNegFlag=3,e.cortexBonferroni=s.getUint32(h,!0),h+=4,e.posMinRGB=[0,0,0],e.posMaxRGB=[0,0,0],e.negMinRGB=[0,0,0],e.negMaxRGB=[0,0,0],r>=2&&(e.posMinRGB[0]=s.getUint8(h),h++,e.posMinRGB[1]=s.getUint8(h),h++,e.posMinRGB[2]=s.getUint8(h),h++,e.posMaxRGB[0]=s.getUint8(h),h++,e.posMaxRGB[1]=s.getUint8(h),h++,e.posMaxRGB[2]=s.getUint8(h),h++,r>=4&&(e.negMinRGB[0]=s.getUint8(h),h++,e.negMinRGB[1]=s.getUint8(h),h++,e.negMinRGB[2]=s.getUint8(h),h++,e.negMaxRGB[0]=s.getUint8(h),h++,e.negMaxRGB[1]=s.getUint8(h),h++,e.negMaxRGB[2]=s.getUint8(h),h++),e.enableSMPColor=s.getUint8(h),h++,r>=4&&(e.lut=c()),e.colorAlpha=s.getFloat32(h,!0),h+=4),e.name=c();const i=new Float32Array(t,h,n);a.set(i,d*n),h+=4*n,l.push(e)}return a}static readSTC(t,e){const i=new DataView(t),s=i.getInt32(8,!1);if(s!==e)throw new Error("Overlay has "+s+" vertices, expected "+e);let r=12+4*s;const n=i.getUint32(r,!1);r+=4;const o=new Float32Array(n*s);for(let a=0;a<n*s;a++)o[a]=i.getFloat32(r,!1),r+=4;return o}static isCurv(t){const e=new DataView(t),i=e.getUint8(0),s=e.getUint8(1),r=e.getUint8(2);return 255===i&&255===s&&255===r||(le.debug("Unable to recognize file type: does not appear to be FreeSurfer format."),!1)}static readCURV(t,e){const i=new DataView(t),s=i.getUint8(0),r=i.getUint8(1),n=i.getUint8(2),o=i.getUint32(3,!1),a=i.getUint32(11,!1);if(255===s&&255===r&&255===n||le.debug("Unable to recognize file type: does not appear to be FreeSurfer format."),e!==o)throw new Error("CURV file has different number of vertices ( "+o+")than mesh ("+e+")");if(t.byteLength<15+4*o*a)throw new Error("CURV file smaller than specified");const l=new Float32Array(a*o);let h=15;for(let u=0;u<a*o;u++)l[u]=i.getFloat32(h,!1),h+=4;let c=l[0],d=l[0];for(let u=0;u<l.length;u++)c=Math.min(c,l[u]),d=Math.max(d,l[u]);const m=1/(d-c);for(let u=0;u<l.length;u++)l[u]=1-(l[u]-c)*m;return l}static readANNOT(t,e,i){void 0===i&&(i=!1);const s=new DataView(t),r=s.getUint32(0,!1);if(e!==this.decimateLayerVertices(r,e))throw new Error("ANNOT file has different number of vertices than mesh");if(t.byteLength<4+8*r)throw new Error("ANNOT file smaller than specified");let n=0;const o=new Uint32Array(r);for(let g=0;g<r;g++){o[s.getUint32(n+=4,!1)]=s.getUint32(n+=4,!1)}if(!i)return o;let a=0;try{a=s.getInt32(n+=4,!1)}catch(f){return o}if(1!==a)return o;if(s.getInt32(n+=4,!1)>0)return o;const l=s.getInt32(n+=4,!1),h=s.getInt32(n+=4,!1);n+=h;const c=s.getInt32(n+=4,!1);if(c<1)return o;const d={R:Array(l).fill(0),G:Array(l).fill(0),B:Array(l).fill(0),A:Array(l).fill(0),I:Array(l).fill(0),labels:Array(l).fill("")};for(let g=0;g<c;g++){const t=s.getInt32(n+=4,!1),e=s.getInt32(n+=4,!1);n+=4;let i="";for(let l=0;l<e;l++){const t=s.getUint8(n++);if(0===t)break;i+=String.fromCharCode(t)}n-=4;const r=s.getInt32(n+=4,!1),o=s.getInt32(n+=4,!1),a=s.getInt32(n+=4,!1),h=s.getInt32(n+=4,!1);t<0||t>=l?U.warn("annot entry out of range"):(d.R[t]=r,d.G[t]=o,d.B[t]=a,d.A[t]=h,d.I[t]=(h<<24)+(a<<16)+(o<<8)+r,d.labels[t]=i)}const m=new Float32Array(r);m.fill(-1);let u=0;for(let g=0;g<e;g++){const t=o[g];for(let e=0;e<l;e++)if(d.I[e]===t){m[g]=e;break}m[g]<0&&(u++,m[g]=0)}u>0&&U.error(`annot vertex colors do not match ${u} of ${r} vertices.`);for(let g=0;g<l;g++)d.I[g]=g;return{scalars:m,colormapLabel:re.makeLabelLut(d)}}static readNV(t){const e=t.byteLength,i=new Uint8Array(t);let s=0;function r(){for(;s<e&&10===i[s];)s++;const r=s;for(;s<e&&10!==i[s];)s++;return s++,s-r<1?"":(new TextDecoder).decode(t.slice(r,s-1))}let n,o,a=0,l=0,h=0,c=0;for(;s<e;){const t=r();if(t.startsWith("#"))continue;const e=t.trim().split(/\s+/);if(a<1)a=parseInt(e[0]),n=new Float32Array(3*a);else if(h<3*a)n[h]=parseFloat(e[0]),n[h+1]=parseFloat(e[1]),n[h+2]=parseFloat(e[2]),h+=3;else if(l<1)l=parseInt(e[0]),o=new Uint32Array(3*l);else{if(c>=3*l)break;o[c+2]=parseInt(e[0])-1,o[c+1]=parseInt(e[1])-1,o[c+0]=parseInt(e[2])-1,c+=3}}return{positions:n,indices:o}}static readASC(t){const e=t.byteLength,i=new Uint8Array(t);let s=0;function r(){for(;s<e&&10===i[s];)s++;const r=s;for(;s<e&&10!==i[s];)s++;return s++,s-r<1?"":(new TextDecoder).decode(t.slice(r,s-1))}let n=r();n.startsWith("#!ascii")||U.warn("Invalid ASC mesh"),n=r();let o=n.trim().split(/\s+/);const a=parseInt(o[0]),l=parseInt(o[1]),h=new Float32Array(3*a);let c=0;for(let m=0;m<a;m++)n=r(),o=n.trim().split(/\s+/),h[c]=parseFloat(o[0]),h[c+1]=parseFloat(o[1]),h[c+2]=parseFloat(o[2]),c+=3;const d=new Uint32Array(3*l);c=0;for(let m=0;m<l;m++)n=r(),o=n.trim().split(/\s+/),d[c]=parseInt(o[0]),d[c+1]=parseInt(o[1]),d[c+2]=parseInt(o[2]),c+=3;return{positions:h,indices:d}}static readVTK(e){const i=e.byteLength;if(i<20)throw new Error("File too small to be VTK: bytes = "+e.byteLength);const s=new Uint8Array(e);let r=0;function n(t){if(void 0===t&&(t=!0),t)for(;r<i&&10===s[r];)r++;const n=r;for(;r<i&&10!==s[r];)r++;return r++,r-n<1?"":(new TextDecoder).decode(e.slice(n,r-1))}let o=n();if(!o.startsWith("# vtk DataFile"))throw new Error("Invalid VTK mesh");if(o=n(!1),o=n(),o.startsWith("ASCII"))return t.readTxtVTK(e);if(!o.startsWith("BINARY"))throw new Error("Invalid VTK image, expected ASCII or BINARY "+o);if(o=n(),!o.includes("POLYDATA"))throw new Error("Only able to read VTK POLYDATA "+o);o=n(),o.includes("POINTS")&&(o.includes("double")||o.includes("float"))||U.warn("Only able to read VTK float or double POINTS"+o);const a=o.includes("double");let l=o.trim().split(/\s+/);const h=3*parseInt(l[1]),c=new Float32Array(h),d=new DataView(e);if(a)for(let t=0;t<h;t++)c[t]=d.getFloat64(r,!1),r+=8;else for(let t=0;t<h;t++)c[t]=d.getFloat32(r,!1),r+=4;o=n(),l=o.trim().split(/\s+/);const m=[];if(l[0].includes("LINES")){const t=parseInt(l[1]),e=r;if(o=n(),o.startsWith("OFFSETS")){let e=!1;o.includes("int64")&&(e=!0);const i=new Uint32Array(t);if(e){let e=!1;for(let s=0;s<t;s++){let t=d.getInt32(r,!1);0!==t&&(e=!0),r+=4,t=d.getInt32(r,!1),r+=4,i[s]=t}e&&U.warn("int32 overflow: JavaScript does not support int64")}else for(let s=0;s<t;s++){const t=d.getInt32(r,!1);r+=4,i[s]=t}return{pts:c,offsetPt0:i}}r=e;let i=0;const s=[],a=[];s.push(i);for(let n=0;n<t;n++){const t=d.getInt32(r,!1);r+=4,i+=t,s.push(i);for(let e=0;e<t;e++){const t=3*d.getInt32(r,!1);r+=4,a.push(c[t+0]),a.push(c[t+1]),a.push(c[t+2])}}return{pts:Float32Array.from(a),offsetPt0:Uint32Array.from(s)}}if(l[0].includes("TRIANGLE_STRIPS")){const t=parseInt(l[1]);for(let e=0;e<t;e++){const t=d.getInt32(r,!1)-2;r+=4;for(let e=0;e<t;e++)e%2?(m.push(d.getInt32(r+8,!1)),m.push(d.getInt32(r+4,!1)),m.push(d.getInt32(r,!1))):(m.push(d.getInt32(r,!1)),m.push(d.getInt32(r+4,!1)),m.push(d.getInt32(r+8,!1))),r+=4;r+=8}}else{if(!l[0].includes("POLYGONS"))throw new Error("Unsupported binary VTK datatype "+l[0]);{const t=parseInt(l[1]),e=r,i=n();if(i.startsWith("OFFSETS")){let e=i.includes("int64");const s=new Uint32Array(t);let o=!1;for(let i=0;i<t;i++)e&&(0!==d.getInt32(r,!1)&&(o=!0),r+=4),s[i]=d.getInt32(r,!1),r+=4;if(!Number.isSafeInteger(t)||t>=2147483648||o)throw new Error("values exceed 2GB limit");const a=n();if(!a.startsWith("CONNECTIVITY"))throw new Error("Expected CONNECTIVITY after OFFSETS");e=a.includes("int64");const l=s[t-1],h=new Uint32Array(l);for(let t=0;t<l;t++)e&&(r+=4),h[t]=d.getInt32(r,!1),r+=4;for(let i=0;i<t;i++){const t=0===i?0:s[i-1],e=s[i];for(let i=1;i<e-t-1;i++)m.push(h[t]),m.push(h[t+i]),m.push(h[t+i+1])}}else{r=e;for(let e=0;e<t;e++){const t=d.getInt32(r,!1)-2;if(0===e&&t>65535)throw new Error("Invalid VTK binary polygons using little-endian data (MRtrix)");r+=4;const i=d.getInt32(r,!1);r+=4;let s=d.getInt32(r,!1);r+=4;for(let e=0;e<t;e++){const t=d.getInt32(r,!1);r+=4,m.push(i,s,t),s=t}}}}}return{positions:c,indices:new Uint32Array(m)}}static readWRL(t){const e=new TextDecoder("utf-8").decode(t),i=/coord\s+Coordinate\s*\{\s*point\s*\[([\s\S]*?)\]/.exec(e),s=/coordIndex\s*\[([\s\S]*?)\]/.exec(e),r=/color\s+Color\s*\{\s*color\s*\[([\s\S]*?)\]/.exec(e);if(!i||!s)throw new Error("Invalid WRL file: Could not find vertices or indices.");const n=new Float32Array(i[1].trim().split(/[\s,]+/).map(Number));let o=null;if(r){o=new Float32Array(r[1].trim().split(/[\s,]+/).map(Number));const t=n.length/3;o.length!==3*t&&(console.warn(`Unexpected color count: expected ${3*t}, got ${o.length}`),o=null)}return{positions:n,indices:new Uint32Array(s[1].trim().split(/[\s,]+/).map(Number).filter((t=>-1!==t))),colors:o}}static readDFS(t){const e=new DataView(t),i=e.getUint32(0,!0),s=e.getUint16(4,!0);1599292996===i&&17740===s||U.warn("Not a little-endian brainsuite DFS mesh");const r=e.getUint32(12,!0),n=e.getUint32(24,!0),o=e.getUint32(28,!0),a=e.getUint32(48,!0);let l=r;const h=new Uint32Array(t,l,3*n);l+=3*n*4;const c=new Float32Array(t,l,3*o);for(let m=0;m<3*o;m+=3){const t=c[m];c[m]=c[m+1],c[m+1]=t}let d;return a>=0&&(d=new Float32Array(t,a,3*o)),{positions:c,indices:h,colors:d}}static async readMZ3(t,e){if(void 0===e&&(e=0),t.byteLength<20)throw new Error("File too small to be mz3: bytes = "+t.byteLength);let i=new DataView(t),s=t,r=i.getUint16(0,!0);if(35615===r||8075===r){const e=await ae.decompress(new Uint8Array(t));i=new DataView(e.buffer),r=i.getUint16(0,!0),s=e.buffer}const n=i.getUint16(2,!0),o=i.getUint32(4,!0);let a=i.getUint32(8,!0);const l=i.getUint32(12,!0);if(le.debug("MZ3 magic %d attr %d face %d vert %d skip %d",r,n,o,a,l),23117!==r)throw new Error("Invalid MZ3 file");const h=!!(1&n),c=!!(2&n),d=!!(4&n);let m=!!(8&n);const u=!!(16&n),f=!!(32&n),g=!!(64&n);if(le.debug(`isFace=${h} isVert=${c} isRGBA=${d} isSCALAR=${m} isDOUBLE=${u} isAOMAP=${f} isLOOKUP=${g}`),n>127)throw new Error("Unsupported future version of MZ3 file");let A=4;u&&(A=8);let p=0;if(e>0&&!h&&o<1&&!d&&(m=!0),m){const t=e||a,i=16+l+(h?12*o:0)+(c?12*t:0)+(d?4*t:0),r=Math.floor((s.byteLength-i)/A);a!==e&&r%e==0&&(a=e),p=Math.floor(r/a),p<1&&(U.warn("Corrupt MZ3: file reports NSCALAR but not enough bytes"),m=!1)}if(a<3&&e<3)throw new Error("Not a mesh MZ3 file (maybe scalar)");e>0&&e!==a&&U.warn("Layer has "+a+"vertices, but background mesh has "+e);let v=16+l;const x=new DataView(s);let w=null;if(h){w=new Uint32Array(3*o);for(let t=0;t<3*o;t++)w[t]=x.getUint32(v,!0),v+=4}let b=null;if(c){b=new Float32Array(3*a);for(let t=0;t<3*a;t++)b[t]=x.getFloat32(v,!0),v+=4}let y=null;if(d){y=new Float32Array(3*a);for(let t=0;t<a;t++){for(let e=0;e<3;e++)y[3*t+e]=x.getUint8(v++)/255;v++}}let C=new Float32Array;if(m&&p>0)if(u){const t=new Float64Array(p*a);for(let e=0;e<p*a;e++)t[e]=x.getFloat64(v,!0),v+=8;C=Float32Array.from(t)}else{C=new Float32Array(p*a);for(let t=0;t<p*a;t++)C[t]=x.getFloat32(v,!0),v+=4}if(e>0&&g&&m){const t=new TextDecoder("utf-8"),e=new Uint8Array(s,16,l),i=t.decode(e),r=JSON.parse(i);return{scalars:C,colormapLabel:re.makeLabelLut(r)}}if(e>0&&d&&m){let t=C[0];for(let i=0;i<a;i++)t=Math.max(t,C[i]);const e={R:[],G:[],B:[],A:[],I:[],labels:[]};for(let i=0;i<=t;i++)for(let t=0;t<a;t++)if(i===C[t]){const s=3*t;e.I.push(i),e.R.push(255*y[s]),e.G.push(255*y[s+1]),e.B.push(255*y[s+2]),e.A.push(255),e.labels.push(`${i}`);break}return{scalars:C,colormapLabel:re.makeLabelLut(e)}}return e>0?{scalars:C}:{positions:b,indices:w,scalars:C,colors:y}}static readPLY(t){const e=t.byteLength,i=new Uint8Array(t);let s=0;function r(){for(;s<e&&10===i[s];)s++;const r=s;for(;s<e&&10!==i[s];)s++;return s++,s-r<1?"":(new TextDecoder).decode(t.slice(r,s-1))}let n=r();if(!n.startsWith("ply"))throw new Error("Not a valid PLY file");n=r();const o=n.includes("ascii");function a(t){if("char"===t||"uchar"===t||"int8"===t||"uint8"===t)return 1;if("short"===t||"ushort"===t||"int16"===t||"uint16"===t)return 2;if("int"===t||"uint"===t||"int32"===t||"uint32"===t||"float"===t||"float32"===t)return 4;if("double"===t)return 8;throw new Error("Unknown data type: "+t)}const l=n.includes("binary_little_endian");let h=0,c=!1,d=0,m=0,u=0,f=0,g=0,A=0,p=0;for(;s<e&&!n.startsWith("end_header");){if(n=r(),n.startsWith("comment"))continue;let t=n.split(/\s/);if(n.startsWith("element vertex"))for(h=parseInt(t[t.length-1]),n=r(),t=n.split(/\s/);n.startsWith("property");){const e=t[1];"x"===t[2]&&e.startsWith("double")?c=!0:"x"!==t[2]||e.startsWith("float")||U.error("Error: expect ply xyz to be float or double: "+n),d+=a(e),n=r(),t=n.split(/\s/)}if(n.startsWith("element face"))for(p=parseInt(t[t.length-1]),n=r(),t=n.split(/\s/);n.startsWith("property");){if("list"===t[1])u=a(t[2]),f=a(t[3]),m+=u+3*f;else{const e=a(t[1]);m+=e,0===f&&(g+=e,A++)}n=r(),t=n.split(/\s/)}}if(o){p<1&&U.error(`Malformed ply format: faces ${p} `);const t=new Float32Array(3*h);let e=0;for(let o=0;o<h;o++){n=r();const i=n.split(/\s/);t[e]=parseFloat(i[0]),t[e+1]=parseFloat(i[1]),t[e+2]=parseFloat(i[2]),e+=3}let i=new Uint32Array(3*p),s=0;for(let o=0;o<p;o++){n=r();const t=n.split(/\s/),e=parseInt(t[A])-2;if(e<1)break;if(s+3*e>i.length){const t=new Uint32Array(i.length+i.length);t.set(i),i=t.slice()}const o=parseInt(t[A+1]);let a=parseInt(t[A+2]);for(let r=0;r<e;r++){const e=parseInt(t[A+3+r]);i[s+0]=o,i[s+1]=a,i[s+2]=e,a=e,s+=3}}return i.length!==s&&(i=i.slice(0,s)),{positions:t,indices:i}}(d<12||u<1||f<1||p<1)&&U.warn(`Malformed ply format: stride ${d} count ${u} iBytes ${f} iStrideBytes ${m} iPadBytes ${g} faces ${p}`);const v=new DataView(t);let x;if(s%4==0&&12===d&&l)x=new Float32Array(t,s,3*h),s+=h*d;else{x=new Float32Array(3*h);let t=0;for(let e=0;e<h;e++)c?(x[t]=v.getFloat64(s,l),x[t+1]=v.getFloat64(s+8,l),x[t+2]=v.getFloat64(s+16,l)):(x[t]=v.getFloat32(s,l),x[t+1]=v.getFloat32(s+4,l),x[t+2]=v.getFloat32(s+8,l)),t+=3,s+=d}const w=new Uint32Array(3*p);let b=!0,y=0;if(1===u&&4===f&&13===m)for(let C=0;C<p;C++){const t=v.getUint8(s);s+=u,3!==t&&(b=!1),w[y]=v.getUint32(s,l),s+=4,w[y+1]=v.getUint32(s,l),s+=4,w[y+2]=v.getUint32(s,l),s+=4,y+=3}else{let t=s;for(let e=0;e<p;e++){s=t+g;let e=0;1===u?e=v.getUint8(s):2===u?e=v.getUint16(s,l):4===u&&(e=v.getUint32(s,l)),s+=u,3!==e&&(b=!1);for(let t=0;t<3;t++)1===f?w[y]=v.getUint8(s):2===f?w[y]=v.getUint16(s,l):4===f&&(w[y]=v.getUint32(s,l)),y++,s+=f;t+=m}}return b||U.warn("Only able to read PLY meshes limited to triangles."),{positions:x,indices:w}}static readICO(t){const e=new TextDecoder("utf-8").decode(t).split("\n");let i=e[0].trim().split(/\s+/);i.length>1&&U.warn("This is not a valid FreeSurfer ICO/TRI mesh.");const s=parseInt(i[0]),r=new Float32Array(3*s);let n=1;for(let l=0;l<s;l++){const t=e[n].trim().split(/\s+/);n++;let i=parseInt(t[0])-1;const o=parseFloat(t[1]),a=parseFloat(t[2]),l=parseFloat(t[3]);if(i<0||i>=s){U.error("ICO vertices corrupted");break}i*=3,r[i]=o,r[i+1]=a,r[i+2]=l}i=e[n].trim().split(/\s+/),n++;const o=parseInt(i[0]),a=new Uint32Array(3*o);for(let l=0;l<o;l++){const t=e[n].trim().split(/\s+/);n++;let i=parseInt(t[0])-1;const s=parseInt(t[1])-1,r=parseInt(t[2])-1,l=parseInt(t[3])-1;if(i<0||i>=o){U.error("ICO indices corrupted");break}i*=3,a[i]=s,a[i+1]=r,a[i+2]=l}for(let l=0;l<a.length;l+=3){const t=a[l];a[l]=a[l+1],a[l+1]=t}return{positions:r,indices:a}}static readGEO(t,e){void 0===e&&(e=!1);const i=new TextDecoder("utf-8").decode(t).split("\n"),s=i[0].trim().split(/\s+/),r=parseInt(s[0]);let n=parseInt(s[1]),o=parseInt(s[2]);const a=parseInt(s[3]);(r>1||a!==3*o)&&U.warn("Multi-part BYU/GEO header or not a triangular mesh.");const l=[];n*=3;let h=0,c=2;for(;h<n;){const t=i[c].trim().split(/\s+/);c++;for(let e=0;e<t.length&&(l.push(parseFloat(t[e])),h++,!(h>=n));e++);}const d=[];o*=3;let m=0;for(;m<o;){const t=i[c].trim().split(/\s+/);c++;for(let e=0;e<t.length&&(d.push(Math.abs(parseInt(t[e]))-1),m++,!(m>=o));e++);}if(e)for(let u=0;u<d.length;u+=3){const t=d[u];d[u]=d[u+1],d[u+1]=t}return{positions:new Float32Array(l),indices:new Uint32Array(d)}}static readOFF(t){const e=new TextDecoder("utf-8").decode(t).split("\n"),i=[],s=[];let r=0;e[r].includes("OFF")?r++:U.warn("File does not start with OFF");let n=e[r].trim().split(/\s+/);const o=parseInt(n[0]),a=parseInt(n[1]);r++;for(let l=0;l<o;l++){n=e[r].trim().split(/\s+/),i.push(parseFloat(n[0])),i.push(parseFloat(n[1])),i.push(parseFloat(n[2])),r++}for(let l=0;l<a;l++){n=e[r].trim().split(/\s+/);3!==parseInt(n[0])&&U.warn("Only able to read OFF files with triangular meshes"),s.push(parseInt(n[1])),s.push(parseInt(n[2])),s.push(parseInt(n[3])),r++}return{positions:new Float32Array(i),indices:new Uint32Array(s)}}static readOBJMNI(t){const e=new TextDecoder("utf-8").decode(t).trim().split(/\s*,\s*|\s+/);(e.length<1||"P"!==e[0])&&U.warn("This is not a valid MNI OBJ mesh.");let i=6;const s=parseInt(e[i++]),r=3*s,n=new Float32Array(r);for(let d=0;d<r;d++)n[d]=parseFloat(e[i++]);i+=r;const o=parseInt(e[i++]),a=parseInt(e[i++]);(o<1||a<0||a>2)&&U.warn("This is not a valid MNI OBJ mesh.");let l=1;1===a?l=o:1===a&&(l=s),i+=4*l,i+=o;const h=3*o,c=new Uint32Array(h);for(let d=0;d<h;d++)c[d]=parseInt(e[i++]);return{positions:n,indices:c}}static async readOBJ(t){const e=new Uint8Array(t,0,2);31===e[0]&&139===e[1]&&(t=await ae.decompressToBuffer(new Uint8Array(t)));const i=new TextDecoder("utf-8").decode(t);if("P"===i[0])return this.readOBJMNI(t);const s=i.split("\n"),r=s.length,n=[],o=[];for(let d=0;d<r;d++){const t=s[d];if("v"===t[0]&&" "===t[1]){const e=t.trim().split(/\s+/);n.push(parseFloat(e[1])),n.push(parseFloat(e[2])),n.push(parseFloat(e[3]))}if("f"===t[0]){const e=t.trim().split(/\s+/),i=e.length-3;if(i<1)break;let s=e[1].split("/");const r=parseInt(s[0])-1;s=e[2].split("/");let n=parseInt(s[0])-1;for(let t=0;t<i;t++){s=e[3+t].split("/");const i=parseInt(s[0])-1;o.push(r),o.push(n),o.push(i),n=i}}}const a=new Float32Array(n),l=new Uint32Array(o);let h=l[0],c=l[0];for(let d=1;d<l.length;d++)l[d]<h&&(h=l[d]),l[d]>c&&(c=l[d]);if(c-h+1>a.length/3)throw new Error("Not a valid OBJ file");for(let d=0;d<l.length;d++)l[d]-=h;return{positions:a,indices:l}}static readFreeSurfer(e){const i=new Uint8Array(e);if(35===i[0]&&33===i[1]&&97===i[2])return t.readASC(e);const s=new DataView(e),r=s.getUint32(0,!1),n=s.getUint32(4,!1);4294966883===r&&1919246708===n||le.debug("Unable to recognize file type: does not appear to be FreeSurfer format.");let o=0;for(;10!==s.getUint8(o);)o++;o+=2;let a=s.getUint32(o,!1);o+=4;let l=s.getUint32(o,!1);o+=4,a*=3;const h=new Float32Array(a);for(let t=0;t<a;t++)h[t]=s.getFloat32(o,!1),o+=4;l*=3;const c=new Uint32Array(l);for(let t=0;t<l;t++)c[t]=s.getUint32(o,!1),o+=4;const d=s.getUint32(o,!1);o+=4;let m=20===d;if(!m){const t=s.getUint32(o,!1);o+=4;const e=s.getUint32(o,!1);o+=4,m=2===d&&0===t&&20===e}if(m){const t=(new TextDecoder).decode(e.slice(o)).trim().split("\n");for(let e=0;e<t.length;e++){if(!t[e].startsWith("cras"))continue;const i=t[e].split("=")[1].trim().split(" ").map(Number),s=Math.floor(h.length/3);let r=0;for(let t=0;t<s;t++)h[r]+=i[0],r++,h[r]+=i[1],r++,h[r]+=i[2],r++}}else U.warn("Unknown FreeSurfer Mesh extension code.");return{positions:h,indices:c}}static async readSRF(e){const i=new Uint8Array(e);if(35===i[0]&&33===i[1]&&97===i[2])return t.readASC(e);if(31===i[0]&&139===i[1]){e=(await ae.decompress(new Uint8Array(e))).buffer}const s=new DataView(e),r=s.getFloat32(0,!0),n=s.getUint32(8,!0),o=s.getUint32(12,!0),a=s.getFloat32(16,!0),l=s.getFloat32(20,!0),h=s.getFloat32(24,!0),c=new Float32Array(3*n);let d=28,m=1;for(let t=0;t<n;t++)c[m]=-s.getFloat32(d,!0)+a,m+=3,d+=4;m=2;for(let t=0;t<n;t++)c[m]=-s.getFloat32(d,!0)+l,m+=3,d+=4;m=0;for(let t=0;t<n;t++)c[m]=-s.getFloat32(d,!0)+h,m+=3,d+=4;d=28+24*n;const u=s.getFloat32(d,!0),f=s.getFloat32(d+4,!0),g=s.getFloat32(d+8,!0),A=s.getFloat32(d+16,!0),p=s.getFloat32(d+20,!0),v=s.getFloat32(d+24,!0);d+=32;const x=new Float32Array(3*n),w=new Uint32Array(e,d,n);m=0;for(let t=0;t<n;t++){const e=w[t];e>1056964608&&(x[m+0]=(e>>16&255)/255,x[m+1]=(e>>8&255)/255,x[m+2]=(255&e)/255),0===e&&(x[m+0]=u,x[m+1]=f,x[m+2]=g),1===e&&(x[m+0]=A,x[m+1]=p,x[m+2]=v),m+=3}d+=4*n;for(let t=0;t<n;t++){d+=4+4*s.getUint32(d,!0)}const b=new Uint32Array(3*o);for(let t=0;t<3*o;t++)b[t]=s.getInt32(d,!0),d+=4;return 4!==r&&U.warn("Not valid SRF"),{positions:c,indices:b,colors:x}}static readTxtSTL(t){const e=new TextDecoder("utf-8").decode(t).split("\n");if(!e[0].startsWith("solid"))throw new Error("Not a valid STL file");const i=[];for(let o=1;o<e.length;o++){if(!e[o].includes("vertex"))continue;const t=e[o].trim().split(/\s+/);for(let e=1;e<t.length;e++)i.push(parseFloat(t[e]))}const s=Math.floor(i.length/3);if(3*s!==i.length)throw new Error("Unable to parse ASCII STL file.");const r=new Float32Array(i),n=new Uint32Array(s);for(let o=0;o<s;o++)n[o]=o;return{positions:r,indices:n}}static readSTL(e){if(e.byteLength<134)throw new Error("File too small to be STL: bytes = "+e.byteLength);const i=new DataView(e);if(1768714099===i.getUint32(0,!0))return t.readTxtSTL(e);const s=i.getUint32(80,!0),r=3*s;if(e.byteLength<84+50*s)throw new Error("STL file too small to store triangles = "+s);const n=new Uint32Array(r),o=new Float32Array(3*r);let a=96,l=0;for(let t=0;t<s;t++){for(let t=0;t<9;t++)o[l]=i.getFloat32(a,!0),l+=1,a+=4;a+=14}for(let t=0;t<r;t++)n[t]=t;return{positions:o,indices:n}}static decimateLayerVertices(t,e){if(t%e==0)return t;const i=Math.round(Math.log((t-2)/10)/Math.log(4)),s=Math.round(Math.log((e-2)/10)/Math.log(4)),r=10*Math.pow(4,i)+2,n=10*Math.pow(4,s)+2;return r!==t||n!==e?t:e}static async readNII2(t,e,i){void 0===e&&(e=0),void 0===i&&(i="");let s=new Float32Array;const r=t.byteLength;let n=!0;const o=new DataView(t);let a=o.getUint16(0,n);if(469893120===a&&(n=!1,a=o.getUint16(0,n)),540!==a)throw new Error("Not a valid NIfTI-2 dataset");const l=Number(o.getBigInt64(168,n)),h=o.getFloat64(176,n),c=o.getFloat64(184,n);1===h&&0===c||U.warn("ignoring scale slope and intercept");const d=o.getUint32(504,n),m=o.getUint16(12,n);if(2!==m&&4!==m&&8!==m&&16!==m)throw new Error("Unsupported NIfTI datatype "+m);let u=1;const f=[1,1,1,1,1,1,1,1];for(let g=1;g<8;g++)f[g]=Math.max(Number(o.getBigInt64(16+8*g,n)),1),u*=f[g];if(d>=3e3&&d<=3099&&l>580){let s=function(){for(;x<r&&10===p[x];)x++;const e=x;for(;x<r&&10!==p[x];)x++;return x++,x-e<1?"":(new TextDecoder).decode(t.slice(e,x-1)).trim()},a=function(){let t=s();if(!t.startsWith("<")||t.endsWith(">"))return t;for(;x<r&&!t.endsWith(">");)t+=s();return t},h=function(t,e){void 0===e&&(e=!1);const i=v.indexOf(t);if(i<0)return 1;const s=v.indexOf('"',i)+1,r=v.indexOf('"',s),n=v.slice(s,r);return e?n:parseInt(n)},c=0,d=0,u=0,g="",A=new Uint32Array;const p=new Uint8Array(t);let v,x=552;const w=f[5],b=new Float32Array(e*w);for(;x<r&&(v=a(),!v.includes("</CIFTI>"));)if(v.includes("<BrainModel")){const t=h("SurfaceNumberOfVertices="),s=h("BrainStructure=",!0).toUpperCase();if(t%e!=0)continue;let r=!1;if(i.includes("CORTEX")&&s.includes("CORTEX")&&(r=!0),!r)continue;if(r=!1,i.includes("LEFT")&&s.includes("LEFT")&&(r=!0),i.includes("RIGHT")&&s.includes("RIGHT")&&(r=!0),!r)continue;if(u=t,c=h("IndexOffset="),d=h("IndexCount="),g=s,v.includes("<VertexIndices>")||(v=a()),!v.startsWith("<VertexIndices>")||!v.endsWith("</VertexIndices>"))return U.warn("Unable to find CIfTI <VertexIndices>"),b;v=v.slice(15,-16);const n=v.trim().split(/\s+/);n.length<d&&U.error("Error parsing VertexIndices"),A=new Uint32Array(d);for(let e=0;e<d;e++)A[e]=parseInt(n[e])}if(0===u||0===A.length)return U.warn("Unable to find CIfTI structure that matches the mesh."),b;if(16!==m)return U.warn("Only able to read float32 CIfTI (only known datatype)."),b;const y=new Float32Array(d*w),C=l+w*c*4;for(let t=0;t<d*w;t++)y[t]=o.getFloat32(C+4*t,n);let M=0;for(let t=0;t<d;t++)for(let i=0;i<w;i++)b[A[t]+i*e]=y[M],M++;return U.debug("CIfTI diagnostics",u,g,c,d,c,i),b}if(u=this.decimateLayerVertices(u,e),u%e!=0)throw new Error("Vertices in layer ("+u+") is not a multiple of number of vertices ("+e+")");if(n)16===m?s=new Float32Array(t,l,u):8===m?s=new Int32Array(t,l,u):4===m&&(s=new Int16Array(t,l,u));else if(16===m){s=new Float32Array(u);for(let t=0;t<u;t++)s[t]=o.getFloat32(l+4*t,n)}else if(8===m){s=new Int32Array(u);for(let t=0;t<u;t++)s[t]=o.getInt32(l+4*t,n)}else if(4===m){s=new Int16Array(u);for(let t=0;t<u;t++)s[t]=o.getInt16(l+2*t,n)}return 2===m&&(s=new Uint8Array(t,l,u)),s}static async readNII(e,i,s){void 0===i&&(i=0),void 0===s&&(s="");let r=new Float32Array,n=!0,o=new DataView(e),a=o.getUint16(0,n);if(540===a||469893120===a)return t.readNII2(e,i,s);if(23553===a&&(n=!1,a=o.getUint16(0,n)),348!==a){const r=await ae.decompress(new Uint8Array(e));if(o=new DataView(r.buffer),e=r.buffer,a=o.getUint16(0,n),540===a||469893120===a)return t.readNII2(e,i,s);23553===a&&(n=!1,a=o.getUint16(0,n))}348!==a&&U.error("Not a valid NIfTI image.");const l=o.getFloat32(108,n),h=o.getFloat32(112,n),c=o.getFloat32(116,n);1===h&&0===c||U.warn("ignoring scale slope and intercept");const d=o.getUint16(70,n);if(2!==d&&4!==d&&8!==d&&16!==d)throw new Error("Unsupported NIfTI datatype "+d);let m=1;for(let t=1;t<8;t++){const e=o.getUint16(40+2*t,n);m*=Math.max(e,1)}if(m=this.decimateLayerVertices(m,i),m%i!=0)throw new Error("Vertices in layer ("+m+") is not a multiple of number of vertices ("+i+")");if(n)16===d?r=new Float32Array(e,l,m):8===d?r=new Int32Array(e,l,m):4===d&&(r=new Int16Array(e,l,m));else if(16===d){r=new Float32Array(m);for(let t=0;t<m;t++)r[t]=o.getFloat32(l+4*t,n)}else if(8===d){r=new Int32Array(m);for(let t=0;t<m;t++)r[t]=o.getInt32(l+4*t,n)}else if(4===d){r=new Int16Array(m);for(let t=0;t<m;t++)r[t]=o.getInt16(l+2*t,n)}return 2===d&&(r=new Uint8Array(e,l,m)),r}static async readMGH(t,e,i){void 0===e&&(e=0),void 0===i&&(i=!1);let s=new DataView(t),r=t;if(31===s.getUint8(0)&&139===s.getUint8(1)){const e=await ae.decompress(new Uint8Array(t));r=new ArrayBuffer(e.byteLength),new Uint8Array(r).set(new Uint8Array(e)),s=new DataView(e.buffer)}const n=s.getInt32(0,!1),o=Math.max(1,s.getInt32(4,!1)),a=Math.max(1,s.getInt32(8,!1)),l=Math.max(1,s.getInt32(12,!1)),h=Math.max(1,s.getInt32(16,!1)),c=s.getInt32(20,!1);let d=284;const m=!1;(1!==n||c<0||c>4)&&U.warn("Not a valid MGH file");let u=o*a*l*h,f=[];if(u=this.decimateLayerVertices(u,e),u%e!=0)return U.warn("Vertices in layer ("+u+") is not a multiple of number of vertices ("+e+")"),f;if(3===c){f=new Float32Array(u);for(let t=0;t<u;t++)f[t]=s.getFloat32(d+4*t,m)}else if(1===c){f=new Int32Array(u);for(let t=0;t<u;t++)f[t]=s.getInt32(d+4*t,m)}else if(4===c){f=new Int16Array(u);for(let t=0;t<u;t++)f[t]=s.getInt16(d+2*t,m)}else 0===c&&(f=new Uint8Array(t,d,u));if(!i)return f;let g=4;4===c&&(g=2),0===c&&(g=1),d+=g*u,d+=16;const A=r.byteLength;let p;for(;d<A-8;){let t=0;switch(s.getInt32(d+=4,m)){case 30:t=s.getInt32(d+=4,m)-1;break;case 20:case 2:t=0;break;case 1:t=0;{let t=s.getInt32(d+=4,m);if(t>0)return U.warn("unsupported CTABreadFromBinaryV1"),f;if(t=-t,2!==t)return U.warn("CTABreadFromBinary: unknown version"),f;const e=s.getInt32(d+=4,m);if(e<0)return U.warn("CTABreadFromBinaryV2: nentries was ",e),f;const i=s.getInt32(d+=4,m);d+=i;const r=s.getInt32(d+=4,m);if(r<0)return f;const n={R:[],G:[],B:[],A:[],I:[],labels:[]};for(let o=0;o<r;o++){const t=s.getInt32(d+=4,m),e=s.getInt32(d+=4,m);let i=d+4,r="";for(let n=0;n<e;n++){const t=s.getUint8(i++);if(0===t)break;r+=String.fromCharCode(t)}d+=e;const o=s.getInt32(d+=4,m),a=s.getInt32(d+=4,m),l=s.getInt32(d+=4,m),h=255-s.getInt32(d+=4,m);n.I.push(t),n.R.push(o),n.G.push(a),n.B.push(l),n.A.push(h),n.labels.push(r)}p=re.makeLabelLut(n)}break;default:t=s.getInt32(d+=8,m)}d+=t}return{scalars:f,colormapLabel:p}}static readX3D(t){const e=t.byteLength;if(e<20)throw new Error("File too small to be X3D: bytes = "+e);const i=new Uint8Array(t);let o=0;function a(){for(;o<e&&60!==i[o];)o++;const s=o;for(;o<e&&62!==i[o];)o++;const r=o;return(new TextDecoder).decode(t.slice(s,r+1)).trim()}let l=a();function h(t){const e=l.indexOf(t+"=");if(e<0)return"";const i=l[e+t.length+1],s=l.indexOf(i,e)+1,r=l.indexOf(i,s);return l.slice(s,r)}function c(t){const e=l.indexOf(t+"=");if(e<0)return 1;const i=l[e+t.length+1],s=l.indexOf(i,e)+1,r=l.indexOf(i,s);let n=l.slice(s,r).trim();n=n.replace(/,\s*$/,"");const o=n.trim().split(/\s*,\s*|\s+/);if(o.length<2)return parseFloat(n);let a=new Array(o.length),h=0;for(let l=0;l<o.length;l++){const t=parseFloat(o[l]);isFinite(t)&&(a[h]=t,h++)}return a=a.slice(0,h),a}l.includes("xml version")||U.warn("Not a X3D image");let d=[],m=[],u=[],f=[],g=[0,0,0,0],A=[0,0,0,0],p=[255,255,255,255],v=[255,255,255,255];const x={};function w(){if(!l.endsWith("/>"))if(l.startsWith("<Appearance>"))for(;o<e&&!l.endsWith("</Appearance>");)l+=a();else for(;o<e&&!l.endsWith("/>");)l+=a();const t=h("USE");if(t.length>1)return void(t in x?p=x[t]:U.warn("Unable to find DEF for "+t));const i=c("diffuseColor");if(i.length<3)return;p[0]=Math.round(255*i[0]),p[1]=Math.round(255*i[1]),p[2]=Math.round(255*i[2]);const s=h("DEF");s.length<1||(x[s]=p)}for(;o<e;)if(l=a(),p=v.slice(),l.startsWith("<Transform")&&(g=c("translation"),A=c("rotation")),l.startsWith("<Appearance")&&(w(),v=p.slice()),l.startsWith("<Shape")){let t=1,i=1,h=[],v=[];for(;o<e&&(l=a(),l.startsWith("<Appearance")&&w(),!l.startsWith("</Shape"));){if(l.startsWith("<Sphere")&&(t=c("radius"),i=-1),l.startsWith("<Cylinder")&&(t=c("radius"),i=c("height")),l.startsWith("<IndexedFaceSet")&&(i=-2,h=c("coordIndex")),l.startsWith("<IndexedTriangleSet")&&(i=-7,h=c("index")),l.startsWith("<IndexedTriangleStripSet")&&(i=-3,h=c("index")),l.startsWith("<Coordinate")){v=c("point");const t=v.length%3;0!==t&&(v=v.slice(0,-t))}l.startsWith("<Color")&&(f=c("color")),l.startsWith("<Box")&&(i=-4,U.warn("Unsupported x3d shape: Box")),l.startsWith("<Cone")&&(i=-5,U.warn("Unsupported x3d shape: Cone")),l.startsWith("<ElevationGrid")&&(i=-6,U.warn("Unsupported x3d shape: ElevationGrid"))}if(i<-3&&-7!==i);else if(i<-1){if(h.length<1||v.length<3||void 0===v.length){U.warn("Indexed mesh must specify indices and points");break}const t=Math.floor(d.length/3);let e=2;if(-7===i)m=[...m,...h];else if(-2===i){let i=0;for(;e<h.length;)h[e]>=0?(m.push(h[i]+t),m.push(h[e-1]+t),m.push(h[e-0]+t),e+=1):(e+=3,i=e-2)}else for(;e<h.length;)h[e]>=0?(m.push(h[e-2]+t),m.push(h[e-1]+t),m.push(h[e-0]+t),e+=1):e+=3;d=[...d,...v];const s=Math.floor(v.length/3),r=Array(s).fill(p).flat();if(f.length===3*s){let t=0,e=0;for(let i=0;i<s;i++){for(let i=0;i<3;i++)r[e]=Math.round(255*f[t]),t++,e++;e++}}u=[...u,...r]}else if(i<0)B.makeColoredSphere(d,m,u,t,g,p);else{const e=n.vt();n.$0(e,A[3],[A[0],A[1],A[2]]);const o=s.fA(0,.5*-i,0,1),a=s.fA(0,.5*+i,0,1);s.Z0(o,o,e),s.Z0(a,a,e),s.WQ(o,o,g),s.WQ(a,a,g);const l=r.fA(o[0],o[1],o[2]),h=r.fA(a[0],a[1],a[2]);B.makeColoredCylinder(d,m,u,l,h,t,p)}}return{positions:Float32Array.from(d),indices:Uint32Array.from(m),rgba255:Uint8Array.from(u)}}static async readGII(t,e){void 0===e&&(e=0);let i=t.byteLength;if(i<20)throw new Error("File too small to be GII: bytes = "+i);let s=new TextDecoder("ascii").decode(t);if(31===s[0].charCodeAt(0)){const e=await ae.decompress(new Uint8Array(t));t=e.buffer,s=new TextDecoder("ascii").decode(e.buffer)}let r=0;function n(){let e=!0,n=r;for(;e;){for(;r<i&&"<"!==s[r];)r++;for(n=r;r<i&&">"!==s[r];)r++;if(e="/"===s[r-1],n+1<i&&"/"===s[n+1]&&(r+=1,e=!0),r>=i)break}const o=(new TextDecoder).decode(t.slice(n+1,r)).trim(),a=o.split(" ")[0].trim(),l=r;let h=r,c=r;if("?"!==s[n+1]&&"!"!==s[n+1]){const t="</"+a+">";h=s.indexOf(t,l),c=h+t.length-1}return{name:o,startPos:n,contentStartPos:l,contentEndPos:h,endPos:c}}let o=n();if(!o.name.startsWith("?xml"))throw new Error("readGII: Invalid XML file");for(;!o.name.startsWith("GIFTI")&&o.endPos<i;)o=n();if(!o.name.startsWith("GIFTI")||o.contentStartPos===o.contentEndPos)throw new Error("readGII: XML file does not include GIFTI tag");i=o.contentEndPos;let a=new Float32Array,l=new Uint32Array,h=new Float32Array,c="",d=!1,m=!1,u=!1,f=!1,g=[1,1,1];const A=[0,0,0];let p=0,v=!1,x=!1,w=0,b=!1;o.endPos=o.contentStartPos;let y="";function C(t,e){void 0===e&&(e=!1);const i=y.indexOf(t);if(i<0)return 1;const s=y.indexOf('"',i)+1,r=y.indexOf('"',s),n=y.slice(s,r);return e?parseFloat(n):parseInt(n)}function M(t){const e=y.indexOf(t);if(e<0)return"";const i=e+t.length,s=y.indexOf("]",i);return y.slice(i,s)}const D={R:[],G:[],B:[],A:[],I:[],labels:[]};for(;o.endPos<i&&o.name.length>1;)if(o=n(),o.name.startsWith("Label Key")&&(y=o.name,D.I.push(C("Key=")),D.R.push(Math.round(255*C("Red=",!0))),D.G.push(Math.round(255*C("Green=",!0))),D.B.push(Math.round(255*C("Blue=",!0))),D.A.push(Math.round(255*C("Alpha",!0))),y=(new TextDecoder).decode(t.slice(o.contentStartPos+1,o.contentEndPos)).trim(),D.labels.push(M("<![CDATA["))),"Data"!==o.name.trim()){if("DataSpace"===o.name.trim()&&(y=(new TextDecoder).decode(t.slice(o.contentStartPos+1,o.contentEndPos)).trim(),y.includes("NIFTI_XFORM_SCANNER_ANAT")&&(b=!0)),"MD"===o.name.trim()&&(y=(new TextDecoder).decode(t.slice(o.contentStartPos+1,o.contentEndPos)).trim(),y.includes("AnatomicalStructurePrimary")&&y.includes("CDATA[")&&(c=M("<Value><![CDATA[").toUpperCase()),y.includes("VolGeom")&&y.includes("CDATA["))){let t=-1;if(y.includes("VolGeomC_R")&&(t=0),y.includes("VolGeomC_A")&&(t=1),y.includes("VolGeomC_S")&&(t=2),t<0)continue;A[t]=parseFloat(M("<Value><![CDATA["))}o.name.startsWith("DataArray")&&(y=o.name,g=[1,1,1],v=y.includes('Encoding="GZipBase64Binary"'),x=y.includes('Encoding="ASCII"'),d=y.includes('Intent="NIFTI_INTENT_TRIANGLE"'),m=y.includes('Intent="NIFTI_INTENT_POINTSET"'),u=y.includes('Intent="NIFTI_INTENT_VECTOR"'),f=y.includes('ArrayIndexingOrder="ColumnMajorOrder"'),y.includes('DataType="NIFTI_TYPE_UINT8"')&&(p=2),y.includes('DataType="NIFTI_TYPE_INT32"')&&(p=8),y.includes('DataType="NIFTI_TYPE_FLOAT32"')&&(p=16),y.includes('DataType="NIFTI_TYPE_FLOAT64"')&&(p=32),g[0]=C("Dim0="),g[1]=C("Dim1="),g[2]=C("Dim2="))}else{if(u)continue;let i;if(y=(new TextDecoder).decode(t.slice(o.contentStartPos+1,o.contentEndPos)).trim(),x){const t=g[0]*g[1]*g[2],e=y.split(/\s+/);if(t!==e.length)throw new Error("Unable to parse ASCII GIfTI");if(2===p&&(p=8),32===p&&(p=16),8===p){i=new Int32Array(t);for(let s=0;s<t;s++)i[s]=parseInt(e[s])}if(16===p){i=new Float32Array(t);for(let s=0;s<t;s++)i[s]=parseFloat(e[s])}}else if("undefined"==typeof Buffer){let t=function(t){const e=atob(t),i=e.length,s=new Uint8Array(i);for(let r=0;r<i;r++)s[r]=e.charCodeAt(r);return s};if(v){const e=t(y.slice());i=await ae.decompress(new Uint8Array(e))}else i=t(y.slice())}else if(v){const t=Buffer.from(y.slice(),"base64");i=await ae.decompress(new Uint8Array(t))}else i=Buffer.from(y.slice(),"base64");if(m){if(16!==p&&U.warn("expect positions as FLOAT32"),a=new Float32Array(i.buffer),f){const t=a.slice(),e=t.length/3;let i=0;for(let s=0;s<e;s++)for(let r=0;r<3;r++)a[i]=t[r*e+s],i++}}else if(d){if(8!==p&&U.warn("expect indices as INT32"),l=new Uint32Array(i.buffer),f){const t=l.slice(),e=t.length/3;let i=0;for(let s=0;s<e;s++)for(let r=0;r<3;r++)l[i]=t[r*e+s],i++}}else{let t,s=function(t,e){const i=t.length,s=new Float32Array(i+e.length);return s.set(t),s.set(e,i),s};if(w=g[0]*g[1]*g[2],0!==e&&w%e!=0&&U.warn("Number of vertices in scalar overlay ("+w+") does not match mesh ("+e+")"),2===p){const e=new Uint8Array(i.buffer);t=Float32Array.from(e)}else if(8===p){const e=new Int32Array(i.buffer);t=Float32Array.from(e)}else if(16===p)t=new Float32Array(i.buffer);else{if(32!==p)throw new Error(`Invalid dataType: ${p}`);{const e=new Float64Array(i.buffer);t=Float32Array.from(e)}}h=s(h,t)}}let I;if(D.I.length>1&&(I=re.makeLabelLut(D)),e>0)return{scalars:h,colormapLabel:I,anatomicalStructurePrimary:c};if(a.length>2&&!b&&(0!==A[0]||0!==A[1]||0!==A[2])){w=Math.floor(a.length/3);let t=0;for(let e=0;e<w;e++)a[t]+=A[0],t++,a[t]+=A[1],t++,a[t]+=A[2],t++}return{positions:a,indices:l,scalars:h,colormapLabel:I,anatomicalStructurePrimary:c}}},ce=class{constructor(t,e,i,s,r){M(this,"text"),M(this,"style"),M(this,"points"),M(this,"anchor"),M(this,"onClick"),this.text=t,this.style=e,this.points=i,this.anchor=s||0,this.onClick=r}},de=()=>{const t=new ArrayBuffer(2);return new DataView(t).setInt16(0,256,!0),256===new Int16Array(t)[0]},me=(t=>(t[t.UNKNOWN=0]="UNKNOWN",t[t.NII=1]="NII",t[t.DCM=2]="DCM",t[t.DCM_MANIFEST=3]="DCM_MANIFEST",t[t.MIH=4]="MIH",t[t.MIF=5]="MIF",t[t.NHDR=6]="NHDR",t[t.NRRD=7]="NRRD",t[t.MHD=8]="MHD",t[t.MHA=9]="MHA",t[t.MGH=10]="MGH",t[t.MGZ=11]="MGZ",t[t.V=12]="V",t[t.V16=13]="V16",t[t.VMR=14]="VMR",t[t.HEAD=15]="HEAD",t[t.DCM_FOLDER=16]="DCM_FOLDER",t[t.SRC=17]="SRC",t[t.FIB=18]="FIB",t[t.BMP=19]="BMP",t[t.ZARR=20]="ZARR",t[t.NPY=21]="NPY",t[t.NPZ=22]="NPZ",t))(me||{}),ue=Object.freeze({...me,parse:t=>{let e=0;switch(t.toUpperCase()){case"":case"DCM":e=2;break;case"TXT":e=3;break;case"FZ":case"GQI":case"QSDR":case"FIB":e=18;break;case"NII":e=1;break;case"MIH":e=4;break;case"MIF":e=5;break;case"NHDR":e=6;break;case"NRRD":e=7;break;case"MHD":e=8;break;case"MHA":e=9;break;case"MGH":e=10;break;case"MGZ":e=11;break;case"NPY":e=21;break;case"NPZ":e=22;break;case"SRC":e=17;break;case"V":e=12;break;case"V16":e=13;break;case"VMR":e=14;break;case"HEAD":e=15;break;case"PNG":case"BMP":case"GIF":case"JPG":case"JPEG":e=19;break;case"ZARR":e=20}return e}}),fe=function(t,e,i,s,r,n,o,a,l,h,c,d,m,u,f,g,A,p,v){return void 0===e&&(e=""),void 0===i&&(i=""),void 0===s&&(s="gray"),void 0===r&&(r=1),void 0===n&&(n=NaN),void 0===o&&(o=NaN),void 0===a&&(a=!0),void 0===l&&(l=.02),void 0===h&&(h=!1),void 0===c&&(c=!1),void 0===d&&(d=""),void 0===m&&(m=0),void 0===u&&(u=ue.UNKNOWN),void 0===f&&(f=NaN),void 0===g&&(g=NaN),void 0===A&&(A=!0),void 0===p&&(p=!1),void 0===v&&(v=null),{url:t,urlImageData:e,name:i,colormap:s,colorMap:s,opacity:r,cal_min:n,cal_max:o,trustCalMinMax:a,percentileFrac:l,ignoreZeroVoxels:h,useQFormNotSForm:c,colormapNegative:d,imageType:u,cal_minNeg:f,cal_maxNeg:g,colorbarVisible:A,frame4D:m,alphaThreshold:p,colormapLabel:v}};function ge(t,e){void 0===e&&(e=80),t=t.replace(/[`$]/g,"");const i=[],s=Math.min(e,t.length);for(let r=0;r<s;r++){const e=t.charCodeAt(r);i.push(255&e)}return i}function Ae(t,e,i){void 0===e&&(e=!1),void 0===i&&(i=!1);let s=!0;i&&(s=t.littleEndian);const r=new Uint8Array(348),n=new DataView(r.buffer);n.setInt32(0,348,s),n.setUint8(38,114),n.setUint8(39,t.dim_info);for(let a=0;a<8;a++)n.setUint16(40+2*a,t.dims[a],s);n.setFloat32(56,t.intent_p1,s),n.setFloat32(60,t.intent_p2,s),n.setFloat32(64,t.intent_p3,s),n.setInt16(68,t.intent_code,s),e?(n.setInt16(70,2,s),n.setInt16(72,8,s)):(n.setInt16(70,t.datatypeCode,s),n.setInt16(72,t.numBitsPerVoxel,s)),n.setInt16(74,t.slice_start,s);for(let a=0;a<8;a++)n.setFloat32(76+4*a,t.pixDims[a],s);e?(n.setFloat32(108,352,s),n.setFloat32(112,1,s),n.setFloat32(116,0,s)):(n.setFloat32(108,t.vox_offset,s),n.setFloat32(112,t.scl_slope,s),n.setFloat32(116,t.scl_inter,s)),n.setInt16(120,t.slice_end,s),n.setUint8(122,t.slice_code),0===t.xyzt_units?n.setUint8(123,10):n.setUint8(123,t.xyzt_units),e?(n.setFloat32(124,0,s),n.setFloat32(128,0,s)):(n.setFloat32(124,t.cal_max,s),n.setFloat32(128,t.cal_min,s)),n.setFloat32(132,t.slice_duration,s),n.setFloat32(136,t.toffset,s),r.set(ge(t.description),148),r.set(ge(t.aux_file),228),n.setInt16(252,t.qform_code,s),t.sform_code<1||t.sform_code<1?n.setInt16(254,1,s):n.setInt16(254,t.sform_code,s),n.setFloat32(256,t.quatern_b,s),n.setFloat32(260,t.quatern_c,s),n.setFloat32(264,t.quatern_d,s),n.setFloat32(268,t.qoffset_x,s),n.setFloat32(272,t.qoffset_y,s),n.setFloat32(276,t.qoffset_z,s);const o=t.affine.flat();for(let a=0;a<12;a++)n.setFloat32(280+4*a,o[a],s);return n.setInt32(344,3222382,!0),r}function pe(t){const e=[!1,!1,!1,!1],i=[!1,!1,!1,!1];for(let s=0;s<4;s++)for(let e=0;e<4;e++)if(isNaN(t[s][e]))return!1;for(let s=0;s<3;s++)for(let r=0;r<3;r++)0!==t[s][r]&&(e[s]=!0,i[r]=!0);for(let s=0;s<3;s++){if(!e[s])return!1;if(!i[s])return!1}return!0}async function ve(t){const e=t.getReader(),{done:i,value:s}=await e.read();if(i)return e.releaseLock(),new ReadableStream({start(t){t.close()}});if(!s||s.length<2)return e.releaseLock(),new ReadableStream({start(t){s&&t.enqueue(s),t.close()}});const r=31===s[0]&&139===s[1],n=new ReadableStream({async start(t){try{for(t.enqueue(s);;){const{done:i,value:s}=await e.read();if(i){t.close(),e.releaseLock();break}t.enqueue(s)}}catch(i){t.error(i),e.releaseLock()}}});return r?n.pipeThrough(new DecompressionStream("gzip")):n}function xe(t,e,i,s){void 0===t&&(t=[256,256,256]),void 0===e&&(e=[1,1,1]),void 0===i&&(i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1]),void 0===s&&(s=2);const r=new d.a;r.littleEndian=!0,r.dims=[3,1,1,1,0,0,0,0],r.dims[0]=Math.max(3,t.length);for(let o=0;o<t.length;o++)r.dims[o+1]=t[o];r.pixDims=[1,1,1,1,1,0,0,0];for(let o=0;o<t.length;o++)r.pixDims[o+1]=e[o];if(16===i.length){let t=0;for(let e=0;e<4;e++)for(let s=0;s<4;s++)r.affine[e][s]=i[t],t++}let n=8;return 256===s||2===s?n=8:512===s||4===s?n=16:16===s||768===s||8===s||2304===s?n=32:64===s?n=64:U.warn("Unsupported NIfTI datatypeCode for header creation: "+s),r.datatypeCode=s,r.numBitsPerVoxel=n,r.scl_inter=0,r.scl_slope=1,r.sform_code=2,r.magic="n+1",r.vox_offset=352,r}function we(t,e){if(void 0===e&&(e=null),!t.hdr)throw new Error("NVImage header is not defined for toUint8Array");if(!t.img&&null===e)throw new Error("NVImage image data is not defined for toUint8Array");const i=null!==e,s=JSON.parse(JSON.stringify(t.hdr)),r=t.extensions&&t.extensions.length>0,n=new Uint8Array(4);n[0]=r?1:0;let o=new Uint8Array(0);if(r){const e=[];let i=0;for(const r of t.extensions){const t=new Uint8Array(r.edata),s=new Uint8Array(8+t.length),n=new DataView(s.buffer);n.setInt32(0,r.esize,!0),n.setInt32(4,r.ecode,!0),s.set(t,8),e.push(s),i+=s.length}o=new Uint8Array(i);let s=0;for(const t of e)o.set(t,s),s+=t.length}s.vox_offset=Math.max(352,348+n.length+o.length),i&&(s.datatypeCode=2,s.numBitsPerVoxel=8,s.scl_slope=1,s.scl_inter=0);const a=Ae(s,i);let l;if(i){const i=e,s=t.permRAS;if(!s||1===s[0]&&2===s[1]&&3===s[2])l=i;else{U.debug("Reorienting drawing bytes back to native space for saving...");const e=t.hdr.dims,s=e[1]*e[2]*e[3],r=t.dimsRAS?t.dimsRAS[1]*t.dimsRAS[2]*t.dimsRAS[3]:s;if(i.length!==r)console.warn(`Drawing length (${i.length}) does not match expected RAS voxel count (${r}). Cannot reorient drawing reliably.`),l=i;else if(t.img2RASstep&&t.img2RASstart&&t.dimsRAS){const e=t.img2RASstep,r=t.img2RASstart,n=t.dimsRAS,o=new Uint8Array(s);o.fill(0);const a=i;let h=0;for(let t=0;t<n[3];t++){const i=r[2]+t*e[2];for(let t=0;t<n[2];t++){const l=r[1]+t*e[1];for(let t=0;t<n[1];t++){const n=r[0]+t*e[0]+l+i;n>=0&&n<s?o[n]=a[h]:h<a.length&&console.warn(`Calculated native index ${n} is out of bounds [0..${s-1}] during drawing reorientation.`),h++}}}l=o}else console.warn("Missing RAS transformation info (img2RASstep, img2RASstart, dimsRAS). Cannot reorient drawing reliably."),l=i}}else{if(!t.img)throw new Error("NVImage image data is null when trying to save non-drawing.");l=new Uint8Array(t.img.buffer,t.img.byteOffset,t.img.byteLength)}const h=a.length+n.length+o.length,c=Math.max(0,s.vox_offset-h),d=new Uint8Array(c),m=s.vox_offset+l.length,u=new Uint8Array(m);let f=0;return u.set(a,f),f+=a.length,u.set(n,f),f+=n.length,u.set(o,f),f+=o.length,u.set(d,f),f+=d.length,u.set(l,s.vox_offset),u}async function be(t,e,i){void 0===i&&(i=null);const s=we(t,i);if(!e.toLowerCase().endsWith(".gz"))return s;try{const t=await ae.compress(s,"gzip");return new Uint8Array(t)}catch(r){return U.error("Compression failed:",r),U.warn("Returning uncompressed data due to compression error."),s}}function ye(t,e,i,r,n,o){if(void 0===n&&(n=0),void 0===o&&(o=!1),!t.hdr)throw new Error("getValue: NVImage header is not defined.");if(!o&&!t.img)throw new Error("getValue: NVImage image data is not defined.");if(o&&!t.imaginary)return U.warn("getValue: Attempted to read imaginary data, but none exists."),[0];const a=t.hdr.dims[1],l=t.hdr.dims[2],h=t.hdr.dims[3],c=t.permRAS.slice();if(1!==c[0]||2!==c[1]||3!==c[2]){const n=s.fA(e,i,r,1);s.Z0(n,n,t.toRASvox),e=n[0],i=n[1],r=n[2]}e=Math.max(0,Math.min(Math.round(e),a-1)),i=Math.max(0,Math.min(Math.round(i),l-1)),r=Math.max(0,Math.min(Math.round(r),h-1)),n=Math.max(0,n);let d=e+i*a+r*a*l;if(2304===t.hdr.datatypeCode)return t.img?(d*=4,d+3>=t.img.length?(U.warn(`getValue: Calculated index ${d} out of bounds for RGBA data.`),[0]):[t.img[d],t.img[d+1],t.img[d+2],t.img[d+3]]):[0];if(128===t.hdr.datatypeCode)return t.img?(d*=3,d+2>=t.img.length?(U.warn(`getValue: Calculated index ${d} out of bounds for RGB data.`),[0]):[t.img[d],t.img[d+1],t.img[d+2]]):[0];const m=d+n*(a*l*h),u=o?t.imaginary:t.img;if(m<0||m>=u.length)return[0];const f=u[m];return[(isNaN(t.hdr.scl_slope)||0===t.hdr.scl_slope?1:t.hdr.scl_slope)*f+(isNaN(t.hdr.scl_inter)?0:t.hdr.scl_inter)]}var Ce={};function Me(t,e,i,s){void 0===s&&(s=1);const r=e+i;let n=e;const o=[];for(;n+12<=r;){const e=t.getInt32(n,!1),i=t.getInt32(n+8,!1);if(n+=12,i<=0||n+i>r)break;if(e!==s){n+=i;continue}let a=i,l=n;if(1===s){if(n+4>r)break;a=t.getInt32(n,!1),l+=4}if(a>1&&l+a<=r){const e=new Uint8Array(t.buffer,l,a),i=new TextDecoder("utf-8").decode(e.slice(0,-1));o.push(i)}n+=i}return o.join("\n\n")}function De(t,e){if(t.intent_code=1002,16!==t.datatypeCode&&8!==t.datatypeCode)return e;let i=new Float32Array(e);if(8===t.datatypeCode&&(i=new Int32Array(e)),de()){const t=new Uint32Array(e);for(let e=0;e<t.length;e++){const i=t[e];t[e]=(255&i)<<24|(65280&i)<<8|(16711680&i)>>>8|(4278190080&i)>>>24}}t.littleEndian=de();let s=!0,r=1/0,n=-1/0;for(let o=0;o<i.length;o++){const t=i[o];Number.isFinite(t)&&(Number.isInteger(t)||(s=!1),t<r&&(r=t),t>n&&(n=t))}if(!s||r<0||n>2147483647)return U.warn(`FreeSurfer Labels must be integers in INT32 range. range ${r}..${n}`),e;if(n>32767){t.datatypeCode=8;const e=new Int32Array(i.length);for(let t=0;t<i.length;t++)e[t]=Math.trunc(i[t]);return e.buffer}if(n>255){t.datatypeCode=4,t.numBitsPerVoxel=16;const e=new Int16Array(i.length);for(let t=0;t<i.length;t++)e[t]=Math.trunc(i[t]);return e.buffer}{t.datatypeCode=2,t.numBitsPerVoxel=8;const e=new Uint8Array(i.length);for(let t=0;t<i.length;t++)e[t]=Math.trunc(i[t]);return e.buffer}}function Ie(t,e,i){const s=t.byteLength-e.vox_offset;if(s<i)return U.error(`MGH image data size mismatch: expected ${i}, found ${s}`),!1;if(s===i)return!1;const r=e.vox_offset+i+20,n=t.byteLength-r;if(n<=12)return!1;if(Me(new DataView(t),r,n).toLowerCase().endsWith("lut.txt"))return!0;return Me(new DataView(t),r,n,3).includes("mri_label2vol")}async function Te(t,e){t.hdr||(U.debug("readMgh called before nvImage.hdr was initialized. Creating default."),t.hdr=new d.a);const i=t.hdr;i.littleEndian=!1;let o=e,a=new DataView(o);if(o.byteLength>=2&&31===a.getUint8(0)&&139===a.getUint8(1))try{o=await ae.decompressToBuffer(new Uint8Array(e)),a=new DataView(o)}catch(k){return U.error("Failed to decompress MGZ file.",k),null}if(o.byteLength<284)return U.error("File too small to be a valid MGH/MGZ header."),null;const l=a.getInt32(0,!1),h=a.getInt32(4,!1),c=a.getInt32(8,!1),m=a.getInt32(12,!1),u=a.getInt32(16,!1),f=a.getInt32(20,!1),g=a.getFloat32(30,!1),A=a.getFloat32(34,!1),p=a.getFloat32(38,!1),v=a.getFloat32(42,!1),x=a.getFloat32(46,!1),w=a.getFloat32(50,!1),b=a.getFloat32(54,!1),y=a.getFloat32(58,!1),C=a.getFloat32(62,!1),M=a.getFloat32(66,!1),D=a.getFloat32(70,!1),I=a.getFloat32(74,!1),T=a.getFloat32(78,!1),S=a.getFloat32(82,!1),F=a.getFloat32(86,!1);if(1!==l&&U.warn(`Unexpected MGH version: ${l}.`),h<=0||c<=0||m<=0)return U.error(`Invalid MGH dimensions: ${h}x${c}x${m}`),null;switch(f){case 0:i.numBitsPerVoxel=8,i.datatypeCode=2;break;case 4:i.numBitsPerVoxel=16,i.datatypeCode=4;break;case 1:i.numBitsPerVoxel=32,i.datatypeCode=8;break;case 3:i.numBitsPerVoxel=32,i.datatypeCode=16;break;default:return U.error(`Unsupported MGH data type: ${f}`),null}i.dims[1]=h,i.dims[2]=c,i.dims[3]=m,i.dims[4]=Math.max(1,u),i.dims[0]=i.dims[4]>1?4:3,i.pixDims[1]=Math.abs(g),i.pixDims[2]=Math.abs(A),i.pixDims[3]=Math.abs(p),i.pixDims[4]=0,i.sform_code=1,i.qform_code=0;const E=n.fA(v*i.pixDims[1],b*i.pixDims[2],M*i.pixDims[3],0,x*i.pixDims[1],y*i.pixDims[2],D*i.pixDims[3],0,w*i.pixDims[1],C*i.pixDims[2],I*i.pixDims[3],0,0,0,0,1),B=s.fA(i.dims[1]/2,i.dims[2]/2,i.dims[3]/2,1),V=s.vt();s.Z0(V,B,E);const R=r.fA(T-V[0],S-V[1],F-V[2]);i.affine=[[E[0],E[1],E[2],R[0]],[E[4],E[5],E[6],R[1]],[E[8],E[9],E[10],R[2]],[0,0,0,1]],i.vox_offset=284,i.magic="n+1";const N=i.numBitsPerVoxel/8,P=h*c*m*i.dims[4]*N,L=o.slice(i.vox_offset,i.vox_offset+P);return Ie(o,i,P)?De(i,L):L}C(Ce,{isFreeSurferLabelImage:()=>Ie,optimizeFreeSurferLabels:()=>De,readMgh:()=>Te});var Se={};async function Fe(t,e){let i=e,s=null;try{if((0,u.cx)(i)&&(U.debug(`Decompressing NIfTI file: ${t.name}`),i=await(0,u.Sz)(i),U.debug(`Decompression complete for: ${t.name}`)),!i||0===i.byteLength)throw new Error("Buffer became invalid after decompression attempt.");if(t.hdr=await(0,u.Ad)(i),(0,u.Ql)(t.hdr)&&(t.extensions=t.hdr.extensions),null===t.hdr)throw new Error(`Failed to read NIfTI header: ${t.name}`);if(0===t.hdr.cal_min&&255===t.hdr.cal_max&&2!==t.hdr.datatypeCode&&(U.debug(`Resetting suspicious cal_min/max (0/255) for non-uint8 NIfTI: ${t.name}`),t.hdr.cal_min=0,t.hdr.cal_max=0),s=(0,u.AM)(t.hdr,i),null===s)throw new Error(`nifti-reader-js readImage returned null for ${t.name}`);return s}catch(r){return U.error(`Error processing NIfTI file ${t.name}:`,r),t.hdr=null,null}}C(Se,{readNifti:()=>Fe});var Ee={};async function Be(t,e,i){void 0===i&&(i=null),t.hdr||(U.warn("readNrrd called before nvImage.hdr was initialized. Creating default."),t.hdr=new d.a);const s=t.hdr;s.pixDims=[1,1,1,1,1,0,0,0];const o=e.byteLength;let a=null;const l=new Uint8Array(e);for(let r=1;r<o;r++)if(10===l[r-1]&&10===l[r]){const t=e.slice(0,r-1);a=(new TextDecoder).decode(t),s.vox_offset=r+1;break}if(null===a)return U.error("readNrrd: could not extract txt"),null;const h=a.split("\n");if(!h[0].startsWith("NRRD"))return U.error("Invalid NRRD image (magic signature missing)"),null;const c=h.length;let m=!1,u=!1,f=!1;const g=x.fA(NaN,0,0,0,1,0,0,0,1),A=r.fA(0,0,0);let p=x.vt();for(let r=1;r<c;r++){let t=h[r];if(0===t.length||"#"===t[0]){if(t.startsWith("#"))continue;if(0===t.trim().length)continue}t=t.toLowerCase();const e=t.split(":");if(e.length<2)continue;const i=e[0].trim();let n=e[1].trim();switch(n=n.replaceAll(")"," "),n=n.replaceAll("("," "),n=n.trim(),i){case"data file":f=!0;break;case"encoding":if(n.includes("raw"))m=!1;else{if(!n.includes("gz"))return U.error("Unsupported NRRD encoding"),null;m=!0}break;case"type":switch(n){case"uchar":case"unsigned char":case"uint8":case"uint8_t":s.numBitsPerVoxel=8,s.datatypeCode=2;break;case"signed char":case"int8":case"int8_t":s.numBitsPerVoxel=8,s.datatypeCode=256;break;case"short":case"short int":case"signed short":case"signed short int":case"int16":case"int16_t":s.numBitsPerVoxel=16,s.datatypeCode=4;break;case"ushort":case"unsigned short":case"unsigned short int":case"uint16":case"uint16_t":s.numBitsPerVoxel=16,s.datatypeCode=512;break;case"int":case"signed int":case"int32":case"int32_t":s.numBitsPerVoxel=32,s.datatypeCode=8;break;case"uint":case"unsigned int":case"uint32":case"uint32_t":s.numBitsPerVoxel=32,s.datatypeCode=768;break;case"float":s.numBitsPerVoxel=32,s.datatypeCode=16;break;case"double":s.numBitsPerVoxel=64,s.datatypeCode=64;break;default:return U.error("Unsupported NRRD data type: "+n),null}break;case"spacings":{const t=n.split(/[ ,]+/);for(let e=0;e<t.length;e++)s.pixDims[e+1]=parseFloat(t[e])}break;case"sizes":{const t=n.split(/[ ,]+/);s.dims[0]=t.length;for(let e=0;e<t.length;e++)s.dims[e+1]=parseInt(t[e])}break;case"endian":n.includes("little")?s.littleEndian=!0:n.includes("big")&&(s.littleEndian=!1);break;case"space directions":{const t=n.split(/[ ,]+/);if(9===t.length)for(let e=0;e<9;e++)g[e]=parseFloat(t[e])}break;case"space origin":{const t=n.split(/[ ,]+/);3===t.length&&(A[0]=parseFloat(t[0]),A[1]=parseFloat(t[1]),A[2]=parseFloat(t[2]))}break;case"space units":n.includes("microns")&&(u=!0);break;case"space":n.includes("right-anterior-superior")||n.includes("ras")?p=x.fA(1,0,0,0,1,0,0,0,1):n.includes("left-anterior-superior")||n.includes("las")?p=x.fA(-1,0,0,0,1,0,0,0,1):n.includes("left-posterior-superior")||n.includes("lps")?p=x.fA(-1,0,0,0,-1,0,0,0,1):U.warn("Unsupported NRRD space value:",n);break;default:U.warn("Unknown:",i)}}if(!isNaN(g[0])){s.sform_code=2,u&&(n.Ny(g,g,.001),A[0]*=.001,A[1]*=.001,A[2]*=.001),p[0]<0&&(A[0]=-A[0]),p[4]<0&&(A[1]=-A[1]),p[8]<0&&(A[2]=-A[2]),x.lw(g,p,g);const e=n.fA(g[0],g[3],g[6],A[0],g[1],g[4],g[7],A[1],g[2],g[5],g[8],A[2],0,0,0,1);if(!t.vox2mm)return null;const i=t.vox2mm([0,0,0],e),o=t.vox2mm([1,0,0],e);r.Re(o,o,i);const a=t.vox2mm([0,1,0],e);r.Re(a,a,i);const l=t.vox2mm([0,0,1],e);r.Re(l,l,i),s.pixDims[1]=r.Bw(o),s.pixDims[2]=r.Bw(a),s.pixDims[3]=r.Bw(l),s.affine=[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[0,0,0,1]]}let v=null;const w=f?i:e,b=f?0:s.vox_offset;if(f&&!w)return U.warn("Missing data: NRRD header describes detached data file but only one URL provided"),null;if(!w||b>=w.byteLength)return U.error(`NRRD data offset (${b}) invalid for buffer length (${w?.byteLength??0})`),null;let y=w.slice(b);if(m)try{U.debug("Decompressing NRRD data..."),y=await ae.decompressToBuffer(new Uint8Array(y)),U.debug("Decompression complete.")}catch(D){return U.error("Failed to decompress NRRD data.",D),null}const C=s.numBitsPerVoxel/8,M=s.dims.slice(1,s.dims[0]+1).reduce(((t,e)=>t*Math.max(1,e)),1)*C;return y.byteLength<M?(U.error(`NRRD image data size mismatch: expected ${M}, found ${y.byteLength}`),null):(y.byteLength>M&&(U.warn(`NRRD has extra ${y.byteLength-M} bytes after expected image data. Truncating.`),y=y.slice(0,M)),v=y,s.datatypeCode?s.numBitsPerVoxel?v:(U.error("NRRD parsing failed to set numBitsPerVoxel."),null):(U.error("NRRD parsing failed to set datatypeCode."),null))}C(Ee,{readNrrd:()=>Be});var Ve=class t{constructor(t,e,i,s,r,n,o,a,l,h,c,d,m,u,f,g,A,p,v){void 0===t&&(t=null),void 0===e&&(e=""),void 0===i&&(i="gray"),void 0===s&&(s=1),void 0===r&&(r=null),void 0===n&&(n=NaN),void 0===o&&(o=NaN),void 0===a&&(a=!0),void 0===l&&(l=.02),void 0===h&&(h=!1),void 0===c&&(c=!1),void 0===d&&(d=""),void 0===m&&(m=0),void 0===u&&(u=ue.UNKNOWN),void 0===f&&(f=NaN),void 0===g&&(g=NaN),void 0===A&&(A=!0),void 0===p&&(p=null),void 0===v&&(v=0),M(this,"name"),M(this,"id"),M(this,"url"),M(this,"headers"),M(this,"_colormap"),M(this,"_opacity"),M(this,"percentileFrac"),M(this,"ignoreZeroVoxels"),M(this,"trustCalMinMax"),M(this,"colormapNegative"),M(this,"colormapLabel"),M(this,"colormapInvert"),M(this,"nFrame4D"),M(this,"frame4D"),M(this,"nTotalFrame4D"),M(this,"cal_minNeg"),M(this,"cal_maxNeg"),M(this,"colorbarVisible",!0),M(this,"modulationImage",null),M(this,"modulateAlpha",0),M(this,"series",[]),M(this,"nVox3D"),M(this,"oblique_angle"),M(this,"maxShearDeg"),M(this,"useQFormNotSForm"),M(this,"colormapType"),M(this,"pixDims"),M(this,"matRAS"),M(this,"pixDimsRAS"),M(this,"obliqueRAS"),M(this,"dimsRAS"),M(this,"permRAS"),M(this,"img2RASstep"),M(this,"img2RASstart"),M(this,"toRAS"),M(this,"toRASvox"),M(this,"frac2mm"),M(this,"frac2mmOrtho"),M(this,"extentsMinOrtho"),M(this,"extentsMaxOrtho"),M(this,"mm2ortho"),M(this,"hdr",null),M(this,"extensions"),M(this,"imageType"),M(this,"img"),M(this,"imaginary"),M(this,"v1"),M(this,"fileObject"),M(this,"dims"),M(this,"onColormapChange",(()=>{})),M(this,"onOpacityChange",(()=>{})),M(this,"mm000"),M(this,"mm100"),M(this,"mm010"),M(this,"mm001"),M(this,"cal_min"),M(this,"cal_max"),M(this,"robust_min"),M(this,"robust_max"),M(this,"global_min"),M(this,"global_max"),M(this,"urlImgData"),M(this,"isManifest"),M(this,"limitFrames4D"),this.init(t,e,i,s,r,n,o,a,l,h,c,d,m,u,f,g,A,p,v)}init(t,e,i,s,r,n,o,l,h,c,d,m,u,f,g,A,p,v,x,w){void 0===t&&(t=null),void 0===e&&(e=""),void 0===i&&(i=""),void 0===s&&(s=1),void 0===r&&(r=null),void 0===n&&(n=NaN),void 0===o&&(o=NaN),void 0===l&&(l=!0),void 0===h&&(h=.02),void 0===c&&(c=!1),void 0===d&&(d=!1),void 0===m&&(m=""),void 0===u&&(u=0),void 0===f&&(f=ue.UNKNOWN),void 0===g&&(g=NaN),void 0===A&&(A=NaN),void 0===p&&(p=!0),void 0===v&&(v=null),void 0===x&&(x=0),void 0===w&&(w=null);const b=""===i;if(b&&(i="gray"),this.name=e,this.imageType=f,this.id=(0,a.v4)(),this._colormap=i,this._opacity=s>1?1:s,this.percentileFrac=h,this.ignoreZeroVoxels=c,this.trustCalMinMax=l,this.colormapNegative=m,this.colormapLabel=v,this.frame4D=u,this.cal_minNeg=g,this.cal_maxNeg=A,this.colorbarVisible=p,this.colormapType=x,this.useQFormNotSForm=d,!t)return;if(b&&this.hdr&&1002===this.hdr.intent_code&&(i="random",this._colormap=i),this.hdr&&"number"==typeof this.hdr.magic&&(this.hdr.magic="n+1"),this.nFrame4D=1,this.hdr)for(let a=4;a<7;a++)this.hdr.dims[a]>1&&(this.nFrame4D*=this.hdr.dims[a]);if(this.frame4D=Math.min(this.frame4D,this.nFrame4D-1),this.nTotalFrame4D=this.nFrame4D,!this.hdr||!w)return;this.nVox3D=this.hdr.dims[1]*this.hdr.dims[2]*this.hdr.dims[3];const y=this.nVox3D*(this.hdr.numBitsPerVoxel/8),C=w.byteLength/y;C!==this.nFrame4D&&(C>0&&C*y===w.byteLength?U.debug("Loading the first "+C+" of "+this.nFrame4D+" volumes"):U.warn("This header does not match voxel data",this.hdr,w.byteLength),this.nFrame4D=C),1007!==this.hdr.intent_code&&2003!==this.hdr.intent_code||3!==this.nFrame4D||16!==this.hdr.datatypeCode||(w=this.float32V1asRGBA(new Float32Array(w)).buffer),0!==this.hdr.pixDims[1]&&0!==this.hdr.pixDims[2]&&0!==this.hdr.pixDims[3]||U.error("pixDims not plausible",this.hdr),(isNaN(this.hdr.scl_slope)||0===this.hdr.scl_slope)&&(this.hdr.scl_slope=1),isNaN(this.hdr.scl_inter)&&(this.hdr.scl_inter=0);let M=pe(this.hdr.affine);if(d||!M||this.hdr.qform_code>this.hdr.sform_code){U.debug("spatial transform based on QForm");const t=this.hdr.quatern_b,e=this.hdr.quatern_c,i=this.hdr.quatern_d,s=Math.sqrt(1-(Math.pow(t,2)+Math.pow(e,2)+Math.pow(i,2))),r=0===this.hdr.pixDims[0]?1:this.hdr.pixDims[0],n=[[s*s+t*t-e*e-i*i,2*t*e-2*s*i,2*t*i+2*s*e],[2*t*e+2*s*i,s*s+e*e-t*t-i*i,2*e*i-2*s*t],[2*t*i-2*s*e,2*e*i+2*s*t,s*s+i*i-e*e-t*t]],o=this.hdr.affine;for(let a=0;a<3;a+=1)for(let t=0;t<3;t+=1)o[a][t]=n[a][t]*this.hdr.pixDims[t+1],2===t&&(o[a][t]*=r);o[0][3]=this.hdr.qoffset_x,o[1][3]=this.hdr.qoffset_y,o[2][3]=this.hdr.qoffset_z,this.hdr.affine=o}if(M=pe(this.hdr.affine),!M){U.debug("Defective NIfTI: spatial transform does not make sense");let t=this.hdr.pixDims[1],e=this.hdr.pixDims[2],i=this.hdr.pixDims[3];(isNaN(t)||0===t)&&(t=1),(isNaN(e)||0===e)&&(e=1),(isNaN(i)||0===i)&&(i=1),this.hdr.pixDims[1]=t,this.hdr.pixDims[2]=e,this.hdr.pixDims[3]=i;const s=[[t,0,0,0],[0,e,0,0],[0,0,i,0],[0,0,0,1]];this.hdr.affine=s}if(128!==this.hdr.datatypeCode&&2304!==this.hdr.datatypeCode&&this.hdr.littleEndian!==de()&&this.hdr.numBitsPerVoxel>8)if(16===this.hdr.numBitsPerVoxel){const t=new Uint16Array(w);for(let e=0;e<t.length;e++){const i=t[e];t[e]=((255&i)<<8|i>>8&255)<<16>>16}}else if(32===this.hdr.numBitsPerVoxel){const t=new Uint32Array(w);for(let e=0;e<t.length;e++){const i=t[e];t[e]=(255&i)<<24|(65280&i)<<8|i>>8&65280|i>>24&255}}else if(64===this.hdr.numBitsPerVoxel){const t=this.hdr.numBitsPerVoxel/8,e=new Uint8Array(w);for(let i=0;i<e.length;i+=t){let s=t-1;for(let t=0;t<s;t++){const r=e[i+t];e[i+t]=e[i+s],e[i+s]=r,s--}}}switch(this.hdr.datatypeCode){case 2:case 128:case 2304:this.img=new Uint8Array(w);break;case 4:this.img=new Int16Array(w);break;case 16:this.img=new Float32Array(w);break;case 64:this.img=new Float64Array(w);break;case 512:this.img=new Uint16Array(w);break;case 256:{const t=new Int8Array(w),e=t.length;this.img=new Int16Array(e);for(let i=0;i<e;i++)this.img[i]=t[i];this.hdr.datatypeCode=4,this.hdr.numBitsPerVoxel=16;break}case 1:{const t=this.hdr.dims[1]*this.hdr.dims[2]*Math.max(1,this.hdr.dims[3])*Math.max(1,this.hdr.dims[4]),e=new Uint8Array(w);this.img=new Uint8Array(t);const i=new Uint8Array(8);for(let r=0;r<8;r++)i[r]=Math.pow(2,r);let s=-1;for(let r=0;r<t;r++){const t=r%8;0===t&&s++,e[s]&i[t]&&(this.img[r]=1)}this.hdr.datatypeCode=2,this.hdr.numBitsPerVoxel=8;break}case 768:{const t=new Uint32Array(w),e=t.length;this.img=new Float64Array(e);for(let i=0;i<e-1;i++)this.img[i]=t[i];this.hdr.datatypeCode=64;break}case 8:{const t=new Int32Array(w),e=t.length;this.img=new Float64Array(e);for(let i=0;i<e-1;i++)this.img[i]=t[i];this.hdr.datatypeCode=64;break}case 1024:{const t=new BigInt64Array(w),e=t.length;this.img=new Float64Array(e);for(let i=0;i<e-1;i++)this.img[i]=Number(t[i]);this.hdr.datatypeCode=64;break}case 32:{const t=new Float32Array(w),e=Math.floor(t.length/2);this.imaginary=new Float32Array(e),this.img=new Float32Array(e);let i=0;for(let s=0;s<e-1;s++)this.img[s]=t[i],this.imaginary[s]=t[i+1],i+=2;this.hdr.datatypeCode=16;break}default:throw new Error("datatype "+this.hdr.datatypeCode+" not supported")}this.calculateRAS(),isNaN(n)||(this.hdr.cal_min=n),isNaN(o)||(this.hdr.cal_max=o),this.calMinMax()}static async new(e,i,s,r,n,o,a,l,h,c,d,m,u,f,g,A,p,v,x,w){void 0===e&&(e=null),void 0===i&&(i=""),void 0===s&&(s=""),void 0===r&&(r=1),void 0===n&&(n=null),void 0===o&&(o=NaN),void 0===a&&(a=NaN),void 0===l&&(l=!0),void 0===h&&(h=.02),void 0===c&&(c=!1),void 0===d&&(d=!1),void 0===m&&(m=""),void 0===u&&(u=0),void 0===f&&(f=ue.UNKNOWN),void 0===g&&(g=NaN),void 0===A&&(A=NaN),void 0===p&&(p=!0),void 0===v&&(v=null),void 0===x&&(x=0);const b=new t,y=/(?:\.([^.]+))?$/;let C=y.exec(i)[1]||"";C=C.toUpperCase(),"GZ"===C&&(C=y.exec(i.slice(0,-3))[1],C=C.toUpperCase());let M=null;if(f===ue.UNKNOWN&&(f=ue.parse(C)),e instanceof ArrayBuffer&&e.byteLength>=2&&f===ue.DCM){const t=new Uint8Array(e);(92===t[0]&&1===t[1]||92===t[1]&&1===t[0])&&(f=ue.NII)}switch(b.imageType=f,f){case ue.DCM_FOLDER:case ue.DCM_MANIFEST:case ue.DCM:return;case ue.FIB:[M,b.v1]=await b.readFIB(e);break;case ue.MIH:case ue.MIF:M=await b.readMIF(e,n);break;case ue.NHDR:case ue.NRRD:if(M=await Ee.readNrrd(b,e),null===M)throw new Error(`Failed to parse NHDR/NRRD file ${i}`);break;case ue.MHD:case ue.MHA:M=await b.readMHA(e,n);break;case ue.MGH:case ue.MGZ:if(M=await Ce.readMgh(b,e),null===M)throw new Error(`Failed to parse MGH/MGZ file ${i}`);break;case ue.SRC:M=await b.readSRC(e);break;case ue.V:M=b.readECAT(e);break;case ue.V16:M=b.readV16(e);break;case ue.VMR:M=b.readVMR(e);break;case ue.HEAD:M=await b.readHEAD(e,n);break;case ue.BMP:M=await b.readBMP(e);break;case ue.NPY:M=await b.readNPY(e);break;case ue.NPZ:M=await b.readNPZ(e);break;case ue.ZARR:M=await b.readZARR(e,w);break;case ue.NII:if(M=await Se.readNifti(b,e),null===M)throw new Error(`Failed to parse NIfTI file ${i}.`);break;default:throw new Error("Image type not supported")}return b.init(e,i,s,r,n,o,a,l,h,c,d,m,u,f,g,A,p,v,x,M),b}computeObliqueAngle(t){const e=n.o8(t);n.mg(e,t);const i=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),s=Math.max(Math.max(Math.abs(e[0]),Math.abs(e[1])),Math.abs(e[2]))/i,r=Math.sqrt(e[4]*e[4]+e[5]*e[5]+e[6]*e[6]),o=Math.max(Math.max(Math.abs(e[4]),Math.abs(e[5])),Math.abs(e[6]))/r,a=Math.sqrt(e[8]*e[8]+e[9]*e[9]+e[10]*e[10]),l=Math.max(Math.max(Math.abs(e[8]),Math.abs(e[9])),Math.abs(e[10]))/a,h=Math.min(Math.min(s,o),l);let c=Math.abs(180*Math.acos(h)/3.141592653);return c>.01?U.warn("Warning voxels not aligned with world space: "+c+" degrees from plumb.\n"):c=0,c}float32V1asRGBA(t){t.length!==3*this.nVox3D&&U.warn("float32V1asRGBA() expects "+3*this.nVox3D+"voxels, got ",+t.length);const e=t.slice();this.hdr.datatypeCode=2304,this.nFrame4D=1;for(let a=4;a<7;a++)this.hdr.dims[a]=1;this.hdr.dims[0]=3;const i=new Uint8Array(4*this.nVox3D);let s=1;for(let a=0;a<3*this.nVox3D;a++)isNaN(e[a])||(s=Math.max(s,Math.abs(e[a])));const r=255/s,n=2*this.nVox3D;let o=0;for(let a=0;a<this.nVox3D;a++){const t=e[a],s=e[a+this.nVox3D],l=e[a+n];i[o]=Math.abs(t*r),i[o+1]=Math.abs(s*r),i[o+2]=Math.abs(l*r);let h=248+1*Number(t>0)+2*Number(s>0)+4*Number(l>0);Math.abs(t)+Math.abs(s)+Math.abs(l)<.1&&(h=0),i[o+3]=h,o+=4}return i}loadImgV1(t,e,i){void 0===t&&(t=!1),void 0===e&&(e=!1),void 0===i&&(i=!1);let s=this.v1;if(s||3!==this.nFrame4D||this.img.constructor!==Float32Array||(s=this.img.slice()),!s)return U.warn("Image does not have V1 data"),!1;if(t)for(let r=0;r<this.nVox3D;r++)s[r]=-s[r];if(e)for(let r=this.nVox3D;r<2*this.nVox3D;r++)s[r]=-s[r];if(i)for(let r=2*this.nVox3D;r<3*this.nVox3D;r++)s[r]=-s[r];return this.img=this.float32V1asRGBA(s),!0}calculateOblique(){if(!this.matRAS)throw new Error("matRAS not defined");if(void 0===this.pixDimsRAS)throw new Error("pixDimsRAS not defined");if(!this.dimsRAS)throw new Error("dimsRAS not defined");this.oblique_angle=this.computeObliqueAngle(this.matRAS);const t=this.vox2mm([0,0,0],this.matRAS),e=this.vox2mm([1/this.pixDimsRAS[1],0,0],this.matRAS),i=this.vox2mm([0,1/this.pixDimsRAS[2],0],this.matRAS),o=this.vox2mm([0,0,1/this.pixDimsRAS[3]],this.matRAS);r.Re(e,e,t),r.Re(i,i,t),r.Re(o,o,t);const a=n.fA(e[0],e[1],e[2],0,i[0],i[1],i[2],0,o[0],o[1],o[2],0,0,0,0,1);this.obliqueRAS=n.o8(a);const l=Math.abs(90-r.g7(e,i)*(180/Math.PI)),h=Math.abs(90-r.g7(e,o)*(180/Math.PI)),c=Math.abs(90-r.g7(i,o)*(180/Math.PI));this.maxShearDeg=Math.max(Math.max(l,h),c),this.maxShearDeg>.1&&U.warn("Warning: voxels are rhomboidal, maximum shear is %f degrees.",this.maxShearDeg);const d=s.fA(this.dimsRAS[1],this.dimsRAS[2],this.dimsRAS[3],1),m=n.o8(this.matRAS);n.mg(m,m);const u=s.fA(-.5,-.5,-.5,0);n.Tl(m,m,r.fA(u[0],u[1],u[2])),m[0]*=d[0],m[1]*=d[0],m[2]*=d[0],m[4]*=d[1],m[5]*=d[1],m[6]*=d[1],m[8]*=d[2],m[9]*=d[2],m[10]*=d[2],this.frac2mm=n.o8(m);const f=this.pixDimsRAS[1],g=this.pixDimsRAS[2],A=this.pixDimsRAS[3],p=n.o8(m);p[0]=f*d[0],p[1]=0,p[2]=0,p[4]=0,p[5]=g*d[1],p[6]=0,p[8]=0,p[9]=0,p[10]=A*d[2];const v=this.mm2vox([0,0,0],!0);p[12]=(-v[0]-.5)*f,p[13]=(-v[1]-.5)*g,p[14]=(-v[2]-.5)*A,this.frac2mmOrtho=n.o8(p),this.extentsMinOrtho=[p[12],p[13],p[14]],this.extentsMaxOrtho=[p[0]+p[12],p[5]+p[13],p[10]+p[14]],this.mm2ortho=n.vt(),n.B8(this.mm2ortho,a)}THD_daxes_to_NIFTI(t,e,i){const s=this.hdr;if(null===s)throw new Error("HDR is not set");s.sform_code=2;const r="xxyyzzg";let n=-1,o=-1,a=-1;const l=["x","y","z"];l[0]=r[i[0]],l[1]=r[i[1]],l[2]=r[i[2]];const h=t.slice(0,3),c=e.slice(0,3);for(let d=0;d<3;d++)"x"===l[d]?n=d:"y"===l[d]?o=d:a=d;n<0||o<0||a<0||n!==o&&n!==a&&o!==a&&(s.pixDims[1]=Math.abs(h[0]),s.pixDims[2]=Math.abs(h[1]),s.pixDims[3]=Math.abs(h[2]),s.affine=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],s.affine[0][n]=-h[n],s.affine[1][o]=-h[o],s.affine[2][a]=h[a],s.affine[0][3]=-c[n],s.affine[1][3]=-c[o],s.affine[2][3]=c[a])}SetPixDimFromSForm(){if(!this.hdr)throw new Error("hdr not defined");const t=this.hdr.affine,e=n.fA(t[0][0],t[0][1],t[0][2],t[0][3],t[1][0],t[1][1],t[1][2],t[1][3],t[2][0],t[2][1],t[2][2],t[2][3],t[3][0],t[3][1],t[3][2],t[3][3]),i=this.vox2mm([0,0,0],e),s=this.vox2mm([1,0,0],e);r.Re(s,s,i);const o=this.vox2mm([0,1,0],e);r.Re(o,o,i);const a=this.vox2mm([0,0,1],e);r.Re(a,a,i),this.hdr.pixDims[1]=r.Bw(s),this.hdr.pixDims[2]=r.Bw(o),this.hdr.pixDims[3]=r.Bw(a)}readECAT(t){this.hdr=new d.a;const e=this.hdr;e.dims=[3,1,1,1,0,0,0,0],e.pixDims=[1,1,1,1,1,0,0,0];const i=new DataView(t),s=i.getInt32(0,!1),r=i.getInt16(50,!1);if(1296127058!==s||r<1||r>14)throw new Error("Not a valid ECAT file");let n=512,o=0;const a=[];let l=new Float32Array;for(;;){if(i.getInt32(n,!1)+i.getInt32(n+12,!1)!==31)break;let t=n+20,s=0,r=0;for(;s<31&&(r=i.getInt32(t,!1),t+=16,0!==r);){s++;let t=512*r;const n=t-512,h=i.getUint16(n,!1);e.dims[1]=i.getUint16(n+4,!1),e.dims[2]=i.getUint16(n+6,!1),e.dims[3]=i.getUint16(n+8,!1);const c=i.getFloat32(n+26,!1);e.pixDims[1]=10*i.getFloat32(n+34,!1),e.pixDims[2]=10*i.getFloat32(n+38,!1),e.pixDims[3]=10*i.getFloat32(n+42,!1),e.pixDims[4]=i.getUint32(n+46,!1)/1e3,a.push(e.pixDims[4]);const d=e.dims[1]*e.dims[2]*e.dims[3],m=new Float32Array(d);if(1===h)for(let e=0;e<d;e++)m[e]=i.getUint8(t)*c,t++;else if(6===h)for(let e=0;e<d;e++)m[e]=i.getUint16(t,!1)*c,t+=2;else if(7===h)for(let e=0;e<d;e++)m[e]=i.getUint32(t,!1)*c,t+=4;else U.warn("Unknown ECAT data type "+h);const u=l.slice(0);l=new Float32Array(u.length+m.length),l.set(u),l.set(m,u.length),o++}if(0===r)break;n+=512}if(e.dims[4]=o,e.pixDims[4]=a[0],o>1){e.dims[0]=4;let t=!1;for(let e=0;e<o;e++)a[e]!==a[0]&&(t=!0);t&&U.warn("Frame durations vary")}return e.sform_code=1,e.affine=[[-e.pixDims[1],0,0,.5*(e.dims[1]-2)*e.pixDims[1]],[0,-e.pixDims[2],0,.5*(e.dims[2]-2)*e.pixDims[2]],[0,0,-e.pixDims[3],.5*(e.dims[3]-2)*e.pixDims[3]],[0,0,0,1]],e.numBitsPerVoxel=32,e.datatypeCode=16,l.buffer}readV16(t){this.hdr=new d.a;const e=this.hdr;e.dims=[3,1,1,1,0,0,0,0],e.pixDims=[1,1,1,1,1,0,0,0];const i=new DataView(t);e.dims[1]=i.getUint16(0,!0),e.dims[2]=i.getUint16(2,!0),e.dims[3]=i.getUint16(4,!0);return 2*e.dims[1]*e.dims[2]*e.dims[3]+6!==t.byteLength&&U.warn("This does not look like a valid BrainVoyager V16 file"),e.numBitsPerVoxel=16,e.datatypeCode=512,U.warn("Warning: V16 files have no spatial transforms"),e.affine=[[0,0,-e.pixDims[1],.5*(e.dims[1]-2)*e.pixDims[1]],[-e.pixDims[2],0,0,.5*(e.dims[2]-2)*e.pixDims[2]],[0,-e.pixDims[3],0,.5*(e.dims[3]-2)*e.pixDims[3]],[0,0,0,1]],e.littleEndian=!0,t.slice(6)}async readNPY(t){function e(t){return{"|b1":1,"<i1":1,"<u1":1,"<i2":2,"<u2":2,"<i4":4,"<u4":4,"<f4":4,"<f8":8}[t]??1}const i=new DataView(t),s=[i.getUint8(0),i.getUint8(1),i.getUint8(2),i.getUint8(3),i.getUint8(4),i.getUint8(5)],r=[147,78,85,77,80,89];if(!s.every(((t,e)=>t===r[e])))throw new Error("Not a valid NPY file: Magic number mismatch");const n=i.getUint16(8,!0),o=new TextDecoder("utf-8").decode(t.slice(10,10+n)),a=o.match(/'shape': \((.*?)\)/);if(!a)throw new Error("Invalid NPY header: Shape not found");const l=a[1].split(",").map((t=>t.trim())).filter((t=>""!==t)).map(Number),h=o.match(/'descr': '([^']+)'/);if(!h)throw new Error("Invalid NPY header: Data type not found");const c=h[1],m=l.reduce(((t,e)=>t*e),1),u=10+n,f=t.slice(u,u+m*e(c)),g=l.length>0?l[l.length-1]:1,A=l.length>1?l[l.length-2]:1,p=l.length>2?l[l.length-3]:1;this.hdr=new d.a;const v=this.hdr;return v.dims=[3,g,A,p,0,0,0,0],v.pixDims=[1,1,1,1,1,0,0,0],v.affine=[[v.pixDims[1],0,0,.5*-(v.dims[1]-2)*v.pixDims[1]],[0,-v.pixDims[2],0,.5*(v.dims[2]-2)*v.pixDims[2]],[0,0,-v.pixDims[3],.5*(v.dims[3]-2)*v.pixDims[3]],[0,0,0,1]],v.numBitsPerVoxel=8*e(c),v.datatypeCode={"|b1":2,"<i1":256,"<u1":2,"<i2":4,"<u2":512,"<i4":8,"<u4":768,"<f4":16,"<f8":64}[c]??16,f}async readNPZ(t){const e=new oe(t);for(let i=0;i<e.entries.length;i++){const t=e.entries[i];if(t.fileName.toLowerCase().endsWith(".npy")){const e=await t.extract();return await this.readNPY(e.buffer)}}}async imageDataFromArrayBuffer(t){return new Promise(((e,i)=>{const s=new Blob([t]),r=URL.createObjectURL(s),n=new Image;n.crossOrigin="Anonymous",n.src=r,n.onload=()=>{URL.revokeObjectURL(r);const t=document.createElement("canvas");t.width=n.width,t.height=n.height;const s=t.getContext("2d");s?(s.drawImage(n,0,0),e(s.getImageData(0,0,n.width,n.height))):i(new Error("Failed to get 2D context"))},n.onerror=t=>{URL.revokeObjectURL(r),i(t)}}))}async readBMP(t){const e=await this.imageDataFromArrayBuffer(t),{width:i,height:s,data:r}=e;this.hdr=new d.a;const n=this.hdr;n.dims=[3,i,s,1,0,0,0,0],n.pixDims=[1,1,1,1,1,0,0,0],n.affine=[[n.pixDims[1],0,0,.5*-(n.dims[1]-2)*n.pixDims[1]],[0,-n.pixDims[2],0,.5*(n.dims[2]-2)*n.pixDims[2]],[0,0,-n.pixDims[3],.5*(n.dims[3]-2)*n.pixDims[3]],[0,0,0,1]],n.numBitsPerVoxel=8,n.datatypeCode=2304;let o=!0;for(let a=0;a<r.length;a+=4)if(r[a]!==r[a+1]||r[a]!==r[a+2]){o=!1;break}if(o){n.datatypeCode=2;const t=new Uint8Array(i*s);for(let e=0,i=0;e<r.length;e+=4,i++)t[i]=r[e];return t.buffer}return r.buffer}async readZARR(t,e){let{width:i,height:s,depth:r=1,data:n}=e??{},o=i*s*r*3,a=o===n.length;if(a||(o=i*s*r,3===r&&(a=!0,r=1)),o!==n.length)throw new Error(`Expected RGB ${i}\xd7${s}\xd7${r}\xd73 =  ${o}, but ZARR length ${n.length}`);this.hdr=new d.a;const l=this.hdr;if(l.dims=[3,i,s,r,1,1,1,1],l.pixDims=[1,1,1,1,0,0,0,0],l.affine=[[l.pixDims[1],0,0,.5*-(l.dims[1]-2)*l.pixDims[1]],[0,-l.pixDims[2],0,.5*(l.dims[2]-2)*l.pixDims[2]],[0,0,-l.pixDims[3],.5*(l.dims[3]-2)*l.pixDims[3]],[0,0,0,1]],!a){if(l.numBitsPerVoxel=8,l.datatypeCode=2,n instanceof Uint8Array){const t=new ArrayBuffer(n.length);return new Uint8Array(t).set(n),t}return n}l.numBitsPerVoxel=24,l.datatypeCode=128;const h=function(t,e,i,s){const r=e*i,n=new Uint8Array(r*s*3),o=new Array(s);for(let h=0;h<s;h++)o[h]=3*r*h;let a=0,l=0;for(let h=0;h<r;h++){for(let e=0;e<s;e++)n[o[e]+l]=t[a++],n[o[e]+l+1]=t[a++],n[o[e]+l+2]=t[a++];l+=3}return n}(n,l.dims[1],l.dims[2],l.dims[3]),c=new ArrayBuffer(h.length);return new Uint8Array(c).set(h),c}readVMR(t){this.hdr=new d.a;const e=this.hdr;e.dims=[3,1,1,1,0,0,0,0],e.pixDims=[1,1,1,1,1,0,0,0];const i=new DataView(t),s=i.getUint16(0,!0);4!==s&&U.warn("Not a valid version 4 VMR image"),e.dims[1]=i.getUint16(2,!0),e.dims[2]=i.getUint16(4,!0),e.dims[3]=i.getUint16(6,!0);const r=e.dims[1]*e.dims[2]*e.dims[3];if(s>=4){let s=8+r;const n=i.getUint32(s+88,!0);if(s+=92,n>0){const e=t.byteLength;for(let t=0;t<n;t++){for(;s<e&&0!==i.getUint8(s);)s++;for(s++,s+=4;s<e&&0!==i.getUint8(s);)s++;s++;const t=i.getUint32(s,!0);s+=4;for(let e=0;e<t;e++)s+=4}}e.pixDims[1]=i.getFloat32(s+2,!0),e.pixDims[2]=i.getFloat32(s+6,!0),e.pixDims[3]=i.getFloat32(s+10,!0)}return U.warn("Warning: VMR spatial transform not implemented"),e.affine=[[0,0,-e.pixDims[1],.5*(e.dims[1]-2)*e.pixDims[1]],[-e.pixDims[2],0,0,.5*(e.dims[2]-2)*e.pixDims[2]],[0,-e.pixDims[3],0,.5*(e.dims[3]-2)*e.pixDims[3]],[0,0,0,1]],U.debug(e),e.numBitsPerVoxel=8,e.datatypeCode=2,t.slice(8,8+r)}async readFIB(t){this.hdr=new d.a;const e=this.hdr;e.littleEndian=!1,e.dims=[3,1,1,1,0,0,0,0],e.pixDims=[1,1,1,1,1,0,0,0];const i=await ae.readMatV4(t,!0);if(!("dimension"in i)||!("dti_fa"in i))throw new Error("Not a valid DSIstudio FIB file");const s="index0"in i&&"index1"in i&&"index2"in i&&"odf_vertices"in i;e.numBitsPerVoxel=32,e.datatypeCode=16,e.dims[1]=i.dimension[0],e.dims[2]=i.dimension[1],e.dims[3]=i.dimension[2],e.dims[4]=1,e.pixDims[1]=i.voxel_size[0],e.pixDims[2]=i.voxel_size[1],e.pixDims[3]=i.voxel_size[2],e.sform_code=1;const r=.5*(e.dims[1]-1)*e.pixDims[1],n=.5*(e.dims[2]-1)*e.pixDims[2],o=.5*(e.dims[3]-1)*e.pixDims[3];e.affine=[[e.pixDims[1],0,0,-r],[0,-e.pixDims[2],0,n],[0,0,e.pixDims[2],-o],[0,0,0,1]],e.littleEndian=!0;const a=e.dims[1]*e.dims[2]*e.dims[3],l=a*Math.ceil(e.numBitsPerVoxel/8),h=l*e.dims[4],c=new Uint8Array(new ArrayBuffer(4*a*3));if(s){const t=e.dims[1]*e.dims[2]*e.dims[3],s=new Float32Array(t),r=new Float32Array(t),n=new Float32Array(t),o=i.index0,a=i.odf_vertices;for(let e=0;e<t;e++){const t=3*o[e];s[e]=a[t+0],r[e]=a[t+1],n[e]=-a[t+2]}c.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength),0*l),c.set(new Uint8Array(r.buffer,r.byteOffset,r.byteLength),1*l),c.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength),2*l)}"report"in i&&(e.description=(new TextDecoder).decode(i.report.subarray(0,Math.min(79,i.report.byteLength))));const m=new Uint8Array(new ArrayBuffer(h)),u=Float32Array.from(i.dti_fa);if("mask"in i){let t=1;"dti_fa_slope"in i&&(t=i.dti_fa_slope[0]);let s=1;"dti_fa_inter"in i&&(s=i.dti_fa_inter[0]);const r=e.dims[1]*e.dims[2]*e.dims[3],n=i.mask,o=new Float32Array(r);let a=0;for(let e=0;e<r;e++)0!==n[e]&&(o[e]=u[a]*t+s,a++);return[o.buffer,new Float32Array(c.buffer)]}const f=new Uint8Array(u.buffer,u.byteOffset,u.byteLength);return m.set(f,0),[m.buffer,new Float32Array(c.buffer)]}async readSRC(t){this.hdr=new d.a;const e=this.hdr;e.littleEndian=!1,e.dims=[3,1,1,1,0,0,0,0],e.pixDims=[1,1,1,1,1,0,0,0];const i=await ae.readMatV4(t);if(!("dimension"in i)||!("image0"in i))throw new Error("Not a valid DSIstudio SRC file");let s=0,r=0;for(const[d,u]of Object.entries(i))if(d.startsWith("image")){if(0===s?r=u.length:r!==u.length&&(r=-1),u.constructor!==Uint16Array)throw new Error("DSIstudio SRC files always use Uint16 datatype");s++}if(r<1||s<1)throw new Error("SRC file not valid DSI Studio data. The image(s) should have the same length");e.numBitsPerVoxel=16,e.datatypeCode=512,e.dims[1]=i.dimension[0],e.dims[2]=i.dimension[1],e.dims[3]=i.dimension[2],e.dims[4]=s,e.dims[4]>1&&(e.dims[0]=4),e.pixDims[1]=i.voxel_size[0],e.pixDims[2]=i.voxel_size[1],e.pixDims[3]=i.voxel_size[2],e.sform_code=1;const n=.5*(e.dims[1]-1)*e.pixDims[1],o=.5*(e.dims[2]-1)*e.pixDims[2],a=.5*(e.dims[3]-1)*e.pixDims[3];e.affine=[[e.pixDims[1],0,0,-n],[0,-e.pixDims[2],0,o],[0,0,e.pixDims[2],-a],[0,0,0,1]],e.littleEndian=!0;const l=e.dims[1]*e.dims[2]*e.dims[3]*(e.numBitsPerVoxel/8),h=l*e.dims[4],c=new Uint8Array(new ArrayBuffer(h));let m=0;for(let d=0;d<s;d++){const t=i[`image${d}`],e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);c.set(e,m),m+=l}return"report"in i&&(e.description=(new TextDecoder).decode(i.report.subarray(0,Math.min(79,i.report.byteLength)))),c.buffer}async readHEAD(t,e){this.hdr=new d.a;const i=this.hdr;i.dims[0]=3,i.pixDims=[1,1,1,1,1,0,0,0];let s=[0,0,0],r=[0,0,0],n=[1,1,1];const o=(new TextDecoder).decode(t).split(/\r?\n/),a=(t.byteLength+8)%16,l=t.byteLength+(16-a);U.debug(t.byteLength,"len",l);const h=new ArrayBuffer(l);new Uint8Array(h).set(new Uint8Array(t));const c=new m.s(l+8,42,h,!0);i.addExtension(c),i.extensionCode=42,i.extensionFlag[0]=1,i.extensionSize=l+8;const u=o.length;let f=0,g=!1;for(;f<u;){let t=o[f];if(f++,!t.startsWith("type"))continue;const e=t.includes("integer-attribute"),a=t.includes("float-attribute");if(t=o[f],f++,!t.startsWith("name"))continue;let l=t.split("= ");const h=l[1];t=o[f],f++,l=t.split("= ");let c=parseInt(l[1]);if(!(c<1)){if(t=o[f],f++,l=t.trim().split(/\s+/),a||e){for(;l.length<c;){t=o[f],f++;const e=t.trim().split(/\s+/);l.push(...e)}for(let t=0;t<c;t++)l[t]=parseFloat(l[t])}switch(h){case"BYTEORDER_STRING":l[0].includes("LSB_FIRST")?i.littleEndian=!0:l[0].includes("MSB_FIRST")&&(i.littleEndian=!1);break;case"BRICK_TYPES":{i.dims[4]=c;const t=parseInt(l[0]);0===t?(i.numBitsPerVoxel=8,i.datatypeCode=2):1===t?(i.numBitsPerVoxel=16,i.datatypeCode=4):3===t?(i.numBitsPerVoxel=32,i.datatypeCode=16):U.warn("Unknown BRICK_TYPES ",t)}break;case"IJK_TO_DICOM_REAL":if(c<12)break;g=!0,i.sform_code=2,i.affine=[[-l[0],-l[1],-l[2],-l[3]],[-l[4],-l[5],-l[6],-l[7]],[l[8],l[9],l[10],l[11]],[0,0,0,1]];break;case"DATASET_DIMENSIONS":c=Math.max(c,3);for(let t=0;t<c;t++)i.dims[t+1]=l[t];break;case"ORIENT_SPECIFIC":s=l;break;case"ORIGIN":r=l;break;case"DELTA":n=l;break;case"TAXIS_FLOATS":i.pixDims[4]=l[0];break;default:U.warn("Unknown:",h)}}}g?this.SetPixDimFromSForm():this.THD_daxes_to_NIFTI(n,r,s);const A=i.numBitsPerVoxel/8*i.dims[1]*i.dims[2]*i.dims[3]*i.dims[4];if(!e)throw new Error("pairedImgData not set");return e.byteLength<A?await ae.decompressToBuffer(new Uint8Array(e)):e.slice(0)}async readMHA(t,e){const i=t.byteLength;if(i<20)throw new Error("File too small to be VTK: bytes = "+t.byteLength);const s=new Uint8Array(t);let n=0;function o(t){return 10===t||13===t}function a(){for(;n<i&&o(s[n]);)n++;const e=n;for(;n<i&&!o(s[n]);)n++;return n-e<2?"":(new TextDecoder).decode(t.slice(e,n))}let l=a();this.hdr=new d.a;const h=this.hdr;h.pixDims=[1,1,1,1,1,0,0,0],h.dims=[1,1,1,1,1,1,1,1],h.littleEndian=!0;let c=!1,m=!1;const u=x.fA(NaN,0,0,0,1,0,0,0,1),f=r.fA(0,0,0);for(;""!==l;){let t=l.split(" ");if(t.length>2&&(t=t.slice(2)),l.startsWith("BinaryDataByteOrderMSB")&&t[0].includes("False")&&(h.littleEndian=!0),l.startsWith("BinaryDataByteOrderMSB")&&t[0].includes("True")&&(h.littleEndian=!1),l.startsWith("CompressedData")&&t[0].includes("True")&&(c=!0),l.startsWith("TransformMatrix"))for(let e=0;e<9;e++)u[e]=parseFloat(t[e]);if(l.startsWith("Offset"))for(let e=0;e<Math.min(t.length,3);e++)f[e]=parseFloat(t[e]);if(l.startsWith("ElementSpacing"))for(let e=0;e<t.length;e++)h.pixDims[e+1]=parseFloat(t[e]);if(l.startsWith("DimSize")){h.dims[0]=t.length;for(let e=0;e<t.length;e++)h.dims[e+1]=parseInt(t[e])}if(l.startsWith("ElementType"))switch(t[0]){case"MET_UCHAR":h.numBitsPerVoxel=8,h.datatypeCode=2;break;case"MET_CHAR":h.numBitsPerVoxel=8,h.datatypeCode=256;break;case"MET_SHORT":h.numBitsPerVoxel=16,h.datatypeCode=4;break;case"MET_USHORT":h.numBitsPerVoxel=16,h.datatypeCode=512;break;case"MET_INT":h.numBitsPerVoxel=32,h.datatypeCode=8;break;case"MET_UINT":h.numBitsPerVoxel=32,h.datatypeCode=768;break;case"MET_FLOAT":h.numBitsPerVoxel=32,h.datatypeCode=16;break;case"MET_DOUBLE":h.numBitsPerVoxel=64,h.datatypeCode=64;break;default:throw new Error("Unsupported MHA data type: "+t[0])}if(l.startsWith("ObjectType")&&!t[0].includes("Image")&&U.warn("Only able to read ObjectType = Image, not "+l),l.startsWith("ElementDataFile")){"LOCAL"!==t[0]&&(m=!0);break}l=a()}const g=x.fA(h.pixDims[1],0,0,0,h.pixDims[2],0,0,0,h.pixDims[3]);for(x.lw(u,u,g),h.affine=[[-u[0],-u[3],-u[6],-f[0]],[-u[1],-u[4],-u[7],-f[1]],[u[2],u[5],u[8],f[2]],[0,0,0,1]];10===s[n];)n++;return h.vox_offset=n,m&&e?c?await ae.decompressToBuffer(new Uint8Array(e.slice(0))):e.slice(0):c?await ae.decompressToBuffer(new Uint8Array(t.slice(h.vox_offset))):t.slice(h.vox_offset)}async readMIF(t,e){this.hdr=new d.a;const i=this.hdr;i.pixDims=[1,1,1,1,1,0,0,0],i.dims=[1,1,1,1,1,1,1,1];let s=t.byteLength;if(s<20)throw new Error("File too small to be MIF: bytes = "+s);let r=new Uint8Array(t);31===r[0]&&139===r[1]&&(U.debug("MIF with GZ decompression"),t=await ae.decompressToBuffer(new Uint8Array(t)),s=t.byteLength,r=new Uint8Array(t));let n=0;function o(){for(;n<s&&10===r[n];)n++;const e=n;for(;n<s&&10!==r[n];)n++;return n++,n-e<1?"":(new TextDecoder).decode(t.slice(e,n-1))}let a=o();if(!a.startsWith("mrtrix image"))throw new Error("Not a valid MIF file");const l=[];let h=!1,c=0,m=0,u=!1;for(a=o();n<s&&!a.startsWith("END");){let t=a.split(":");if(a=o(),t.length<2)break;const e=t[0];t=t[1].split(",");for(let i=0;i<t.length;i++)t[i]=t[i].trim();switch(e){case"dim":i.dims[0]=t.length;for(let e=0;e<t.length;e++)i.dims[e+1]=parseInt(t[e]);break;case"vox":for(let e=0;e<t.length;e++)i.pixDims[e+1]=parseFloat(t[e]),isNaN(i.pixDims[e+1])&&(i.pixDims[e+1]=0);break;case"layout":for(let e=0;e<t.length;e++)l.push(parseInt(t[e]));break;case"datatype":{const e=t[0];e.startsWith("Bit")?(h=!0,i.datatypeCode=2):e.startsWith("Int8")?i.datatypeCode=256:e.startsWith("UInt8")?i.datatypeCode=2:e.startsWith("Int16")?i.datatypeCode=4:e.startsWith("UInt16")?i.datatypeCode=512:e.startsWith("Int32")?i.datatypeCode=8:e.startsWith("UInt32")?i.datatypeCode=768:e.startsWith("Float32")?i.datatypeCode=16:e.startsWith("Float64")?i.datatypeCode=64:U.warn("Unsupported datatype "+e),e.includes("8")?i.numBitsPerVoxel=8:e.includes("16")?i.numBitsPerVoxel=16:e.includes("32")?i.numBitsPerVoxel=32:e.includes("64")&&(i.numBitsPerVoxel=64),i.littleEndian=!0,e.endsWith("LE")&&(i.littleEndian=!0),e.endsWith("BE")&&(i.littleEndian=!1)}break;case"transform":if(c>2||4!==t.length)break;i.affine[c][0]=parseFloat(t[0]),i.affine[c][1]=parseFloat(t[1]),i.affine[c][2]=parseFloat(t[2]),i.affine[c][3]=parseFloat(t[3]),c++;break;case"comments":i.description=t[0].substring(0,Math.min(79,t[0].length));break;case"RepetitionTime":m=parseFloat(t[0]);break;case"file":u=!t[0].startsWith(". "),u||(t=t[0].split(" "),i.vox_offset=parseInt(t[1]))}}const f=i.dims[0];f>5&&U.warn("reader only designed for a maximum of 5 dimensions (XYZTD)");let g,A=1;for(let d=0;d<f;d++)A*=Math.max(i.dims[d+1],1);for(let d=0;d<3;d++)for(let t=0;t<3;t++)i.affine[d][t]*=i.pixDims[t+1];if(U.debug("mif affine:"+i.affine[0]),m>0&&(i.pixDims[4]=m),u&&!e&&U.warn("MIH header provided without paired image data"),e&&u)g=e.slice(0);else if(h){i.numBitsPerVoxel=8;const e=new Uint8Array(A),s=t.slice(i.vox_offset,i.vox_offset+Math.ceil(A/8)),r=new Uint8Array(s);let n=0;for(let t=0;t<A;t++){const i=t%8;e[t]=r[n]>>7-i&1,7===i&&n++}g=e.buffer}else g=t.slice(i.vox_offset,i.vox_offset+A*(i.numBitsPerVoxel/8));l.length!==i.dims[0]&&U.warn("dims does not match layout");let p=1;const v=[1,1,1,1,1],x=[!1,!1,!1,!1,!1];for(let d=0;d<l.length;d++)for(let t=0;t<l.length;t++){Math.abs(l[t])===d&&(v[t]=p,(l[t]<0||Object.is(l[t],-0))&&(x[t]=!0),p*=i.dims[t+1])}let w=ae.range(0,i.dims[1]-1,1);x[0]&&(w=ae.range(i.dims[1]-1,0,-1));for(let d=0;d<i.dims[1];d++)w[d]*=v[0];let b=ae.range(0,i.dims[2]-1,1);x[1]&&(b=ae.range(i.dims[2]-1,0,-1));for(let d=0;d<i.dims[2];d++)b[d]*=v[1];let y=ae.range(0,i.dims[3]-1,1);x[2]&&(y=ae.range(i.dims[3]-1,0,-1));for(let d=0;d<i.dims[3];d++)y[d]*=v[2];let C=ae.range(0,i.dims[4]-1,1);x[3]&&(C=ae.range(i.dims[4]-1,0,-1));for(let d=0;d<i.dims[4];d++)C[d]*=v[3];let M=ae.range(0,i.dims[5]-1,1);x[4]&&(M=ae.range(i.dims[5]-1,0,-1));for(let d=0;d<i.dims[5];d++)M[d]*=v[4];let D,I,T=0;switch(i.datatypeCode){case 256:D=new Int8Array(g),I=new Int8Array(A);break;case 2:D=new Uint8Array(g),I=new Uint8Array(A);break;case 4:D=new Int16Array(g),I=new Int16Array(A);break;case 512:D=new Uint16Array(g),I=new Uint16Array(A);break;case 8:D=new Int32Array(g),I=new Int32Array(A);break;case 768:D=new Uint32Array(g),I=new Uint32Array(A);break;case 16:D=new Float32Array(g),I=new Float32Array(A);break;case 64:D=new Float64Array(g),I=new Float64Array(A);break;default:throw new Error("unknown datatypeCode")}for(let d=0;d<i.dims[5];d++)for(let t=0;t<i.dims[4];t++)for(let e=0;e<i.dims[3];e++)for(let s=0;s<i.dims[2];s++)for(let r=0;r<i.dims[1];r++)I[T]=D[w[r]+b[s]+y[e]+C[t]+M[d]],T++;return I.buffer}calculateRAS(){if(!this.hdr)throw new Error("hdr not set");const t=this.hdr.affine,e=this.hdr,i=x.fA(Math.abs(t[0][0]),Math.abs(t[0][1]),Math.abs(t[0][2]),Math.abs(t[1][0]),Math.abs(t[1][1]),Math.abs(t[1][2]),Math.abs(t[2][0]),Math.abs(t[2][1]),Math.abs(t[2][2])),s=[1,1,1];i[3]>i[0]&&(s[0]=2),i[6]>i[0]&&i[6]>i[3]&&(s[0]=3),s[1]=1,1===s[0]?i[4]>i[7]?s[1]=2:s[1]=3:2===s[0]?i[1]>i[7]?s[1]=1:s[1]=3:i[1]>i[4]?s[1]=1:s[1]=2,s[2]=6-s[1]-s[0];let r=[1,2,3];r[s[0]-1]=1,r[s[1]-1]=2,r[s[2]-1]=3;let o=n.fA(t[0][0],t[0][1],t[0][2],t[0][3],t[1][0],t[1][1],t[1][2],t[1][3],t[2][0],t[2][1],t[2][2],t[2][3],0,0,0,1);this.mm000=this.vox2mm([-.5,-.5,-.5],o),this.mm100=this.vox2mm([e.dims[1]-.5,-.5,-.5],o),this.mm010=this.vox2mm([-.5,e.dims[2]-.5,-.5],o),this.mm001=this.vox2mm([-.5,-.5,e.dims[3]-.5],o);const a=n.vt();n.C(a,o);for(let n=0;n<3;n++)for(let t=0;t<3;t++)a[4*n+t]=o[4*n+r[t]-1];const l=[0,0,0];a[0]<0&&(l[0]=1),a[5]<0&&(l[1]=1),a[10]<0&&(l[2]=1),this.dimsRAS=[e.dims[0],e.dims[r[0]],e.dims[r[1]],e.dims[r[2]]],this.pixDimsRAS=[e.pixDims[0],e.pixDims[r[0]],e.pixDims[r[1]],e.pixDims[r[2]]],this.permRAS=r.slice();for(let n=0;n<3;n++)1===l[n]&&(this.permRAS[n]=-this.permRAS[n]);if(this.arrayEquals(r,[1,2,3])&&this.arrayEquals(l,[0,0,0]))return this.toRAS=n.vt(),this.matRAS=n.o8(o),this.calculateOblique(),this.img2RASstep=[1,this.dimsRAS[1],this.dimsRAS[1]*this.dimsRAS[2]],void(this.img2RASstart=[0,0,0]);n.D_(o),o[0]=1-2*l[0],o[5]=1-2*l[1],o[10]=1-2*l[2],o[3]=(e.dims[r[0]]-1)*l[0],o[7]=(e.dims[r[1]]-1)*l[1],o[11]=(e.dims[r[2]]-1)*l[2];const h=n.vt();n.B8(h,o),n.lw(h,h,a),this.matRAS=n.o8(h),o=n.fA(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),o[r[0]-1+0]=2*-l[0]+1,o[r[1]-1+4]=2*-l[1]+1,o[r[2]-1+8]=2*-l[2]+1,o[3]=l[0],o[7]=l[1],o[11]=l[2],this.toRAS=n.o8(o),o[3]=0,o[7]=0,o[11]=0,o[12]=0,-1!==this.permRAS[0]&&-1!==this.permRAS[1]&&-1!==this.permRAS[2]||(o[12]=e.dims[1]-1),o[13]=0,-2!==this.permRAS[0]&&-2!==this.permRAS[1]&&-2!==this.permRAS[2]||(o[13]=e.dims[2]-1),o[14]=0,-3!==this.permRAS[0]&&-3!==this.permRAS[1]&&-3!==this.permRAS[2]||(o[14]=e.dims[3]-1),this.toRASvox=n.o8(o),U.debug(this.hdr.dims),U.debug(this.dimsRAS);const c=this.hdr;r=this.permRAS;const d=[Math.abs(r[0]),Math.abs(r[1]),Math.abs(r[2])],m=[c.dims[d[0]],c.dims[d[1]],c.dims[d[2]]],u=[1,c.dims[1],c.dims[1]*c.dims[2]],f=[u[d[0]-1],u[d[1]-1],u[d[2]-1]],g=[0,0,0];for(let n=0;n<3;n++)r[n]<0&&(g[n]=f[n]*(m[n]-1),f[n]=-f[n]);this.img2RASstep=f,this.img2RASstart=g,this.calculateOblique()}async hdr2RAS(t){if(void 0===t&&(t=1),!this.permRAS)throw new Error("permRAS undefined");if(!this.hdr)throw new Error("hdr undefined");const e=Ae({...this.hdr,vox_offset:352},!1),i=await(0,u.Ad)(e.buffer,!0);1===t?(i.dims[0]=3,i.dims[4]=1):t>1&&(i.dims[0]=4,i.dims[4]=t);const s=this.permRAS.slice();if(1===s[0]&&2===s[1]&&3===s[2])return i;i.qform_code=0;for(let n=1;n<4;n++)i.dims[n]=this.dimsRAS[n];for(let n=0;n<this.pixDimsRAS.length;n++)i.pixDims[n]=this.pixDimsRAS[n];let r=0;for(let n=0;n<4;n++)for(let t=0;t<4;t++)i.affine[n][t]=this.matRAS[r],r++;return i}img2RAS(t){if(void 0===t&&(t=0),!this.permRAS)throw new Error("permRAS undefined");if(!this.img)throw new Error("img undefined");if(!this.hdr)throw new Error("hdr undefined");const e=this.permRAS.slice();if(1===e[0]&&2===e[1]&&3===e[2])return this.img;const i=this.hdr,s=i.dims[1]*i.dims[2]*i.dims[3];let r=t*s;(r+s>this.img.length||r<0)&&(r=0,U.warn(`img2RAS nVolume (${t}) out of bounds (${t}+1)\xd7${s} > ${this.img.length}`));const n=this.img.slice(0,s),o=[Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2])],a=[i.dims[o[0]],i.dims[o[1]],i.dims[o[2]]],l=[1,i.dims[1],i.dims[1]*i.dims[2]],h=[l[o[0]-1],l[o[1]-1],l[o[2]-1]],c=[0,0,0];for(let m=0;m<3;m++)e[m]<0&&(c[m]=h[m]*(a[m]-1),h[m]=-h[m]);let d=0;for(let m=0;m<a[2];m++){const t=c[2]+m*h[2];for(let e=0;e<a[1];e++){const i=c[1]+e*h[1];for(let e=0;e<a[0];e++){const s=c[0]+e*h[0];n[d]=this.img[s+i+t+r],d++}}}return n}vox2mm(t,e){const i=n.o8(e);n.mg(i,i);const o=s.fA(t[0],t[1],t[2],1);s.Z0(o,o,i);return r.fA(o[0],o[1],o[2])}mm2vox(t,e){if(void 0===e&&(e=!1),!this.matRAS)throw new Error("matRAS undefined");const i=n.o8(this.matRAS),o=n.o8(i);n.mg(o,i),n.B8(o,o);const a=s.fA(t[0],t[1],t[2],1);s.Z0(a,a,o);const l=r.fA(a[0],a[1],a[2]);return e?l:[Math.round(l[0]),Math.round(l[1]),Math.round(l[2])]}arrayEquals(t,e){return Array.isArray(t)&&Array.isArray(e)&&t.length===e.length&&t.every(((t,i)=>t===e[i]))}setColormap(t){this._colormap=t,this.calMinMax(),this.onColormapChange&&this.onColormapChange(this)}setColormapLabel(t){this.colormapLabel=re.makeLabelLut(t)}async setColormapLabelFromUrl(t){this.colormapLabel=await re.makeLabelLutFromUrl(t)}get colormap(){return this._colormap}get colorMap(){return this._colormap}set colormap(t){this.setColormap(t)}set colorMap(t){this.setColormap(t)}get opacity(){return this._opacity}set opacity(t){this._opacity=t,this.onOpacityChange&&this.onOpacityChange(this)}calMinMax(t,e){if(void 0===t&&(t=Number.POSITIVE_INFINITY),void 0===e&&(e=!0),!this.hdr)throw new Error("hdr undefined");if(!this.img)throw new Error("img undefined");let i=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,r=0,n=0,o=this.hdr.dims[1]*this.hdr.dims[2]*this.hdr.dims[3];const a=Math.floor(this.img.length/o);t>=a&&(t=this.frame4D);const l=(t=Math.min(t,a-1))*o;let h=[];if(e){const t=.25,e=[Math.floor(t*this.hdr.dims[1]),Math.floor(t*this.hdr.dims[2]),Math.floor(t*this.hdr.dims[3])],i=[this.hdr.dims[1]-2*e[0],this.hdr.dims[2]-2*e[1],this.hdr.dims[3]-2*e[2]],s=[i[0]+e[0],i[1]+e[1],i[2]+e[2]];o=i[0]*i[1]*i[2],h=new this.img.constructor(o);let r=-1,n=0;for(let o=0;o<this.hdr.dims[3];o++)for(let t=0;t<this.hdr.dims[2];t++)for(let i=0;i<this.hdr.dims[1];i++)r++,i<e[0]||t<e[1]||o<e[2]||i>=s[0]||t>=s[1]||o>=s[2]||(h[n]=this.img[r+l],n++)}else{h=new this.img.constructor(o);for(let t=0;t<o;t++)h[t]=this.img[t+l]}const c=h.constructor!==Float64Array&&h.constructor!==Float32Array&&this.ignoreZeroVoxels;if(c)for(let T=0;T<o;T++)i=Math.min(h[T],i),s=Math.max(h[T],s),0===h[T]&&r++;else for(let T=0;T<o;T++)isNaN(h[T])?n++:0===h[T]&&(r++,this.ignoreZeroVoxels)||(i=Math.min(h[T],i),s=Math.max(h[T],s));this.ignoreZeroVoxels&&i===s&&r>0&&(i=0);const d=this.intensityRaw2Scaled(i),m=this.intensityRaw2Scaled(s),u=re.colormapFromKey(this._colormap);let f=0,g=0;if(void 0!==u.min&&(f=u.min),void 0!==u.max&&(g=u.max),f===g&&this.trustCalMinMax&&isFinite(this.hdr.cal_min)&&isFinite(this.hdr.cal_max)&&this.hdr.cal_max>this.hdr.cal_min)return this.cal_min=this.hdr.cal_min,this.cal_max=this.hdr.cal_max,this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=d,this.global_max=m,[this.hdr.cal_min,this.hdr.cal_max,this.hdr.cal_min,this.hdr.cal_max];if(f!==g)return this.cal_min=f,this.cal_max=g,this.robust_min=this.cal_min,this.robust_max=this.cal_max,[f,g,f,g];const A=100*r/(o-0);let p=!1;A>60&&!this.ignoreZeroVoxels&&(U.warn(`${Math.round(A)}% of voxels are zero: ignoring zeros for cal_max`),p=!0,this.ignoreZeroVoxels=!0),this.ignoreZeroVoxels||(r=0),r+=n;const v=Math.round((o-0-r)*this.percentileFrac);if(v<1||i===s)return e?this.calMinMax(t,!1):(U.debug("no variability in image intensity?"),this.cal_min=d,this.cal_max=m,this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=d,this.global_max=m,[d,m,d,m]);const x=1001,w=1e3/(s-i),b=new Array(x);for(let T=0;T<x;T++)b[T]=0;if(c)for(let T=0;T<o;T++)b[Math.round((h[T]-i)*w)]++;else if(this.ignoreZeroVoxels)for(let T=0;T<o;T++)0!==h[T]&&(isNaN(h[T])||b[Math.round((h[T]-i)*w)]++);else for(let T=0;T<o;T++)isNaN(h[T])||b[Math.round((h[T]-i)*w)]++;let y=0,C=0;for(;y<v;)y+=b[C],C++;C--,y=0;let M=x;for(;y<v;)M--,y+=b[M];if(C===M){let t=-1;for(;0!==t;)C>0&&(C--,b[C]>0&&(t=0)),0!==t&&M<1e3&&(M++,b[M]>0&&(t=0)),0===C&&1e3===M&&(t=0)}let D=this.intensityRaw2Scaled(C/w+i),I=this.intensityRaw2Scaled(M/w+i);return this.hdr.cal_min<this.hdr.cal_max&&this.hdr.cal_min>=d&&this.hdr.cal_max<=m&&(D=this.hdr.cal_min,I=this.hdr.cal_max),p&&(D=Math.min(D,0)),this.cal_min=D,this.cal_max=I,1002===this.hdr.intent_code&&(this.cal_min=d,this.cal_max=m),this.robust_min=this.cal_min,this.robust_max=this.cal_max,this.global_min=d,this.global_max=m,[D,I,d,m]}intensityRaw2Scaled(t){if(!this.hdr)throw new Error("hdr undefined");return 0===this.hdr.scl_slope&&(this.hdr.scl_slope=1),t*this.hdr.scl_slope+this.hdr.scl_inter}intensityScaled2Raw(t){if(!this.hdr)throw new Error("hdr undefined");return 0===this.hdr.scl_slope&&(this.hdr.scl_slope=1),(t-this.hdr.scl_inter)/this.hdr.scl_slope}async saveToUint8Array(t,e){return void 0===e&&(e=null),be(this,t,e)}async saveToDisk(t,e){return void 0===t&&(t=""),void 0===e&&(e=null),async function(t,e,i){void 0===e&&(e=""),void 0===i&&(i=null);const s=await be(t,e,i);if(!e)return U.debug("saveToDisk: empty file name, returning data as Uint8Array rather than triggering download"),s;try{const t=new Blob([s.buffer],{type:"application/octet-stream"}),i=URL.createObjectURL(t),r=document.createElement("a");r.setAttribute("href",i),r.setAttribute("download",e),r.style.visibility="hidden",document.body.appendChild(r),r.click(),document.body.removeChild(r),setTimeout((()=>URL.revokeObjectURL(i)),100)}catch(r){U.error("Failed to trigger download:",r)}return s}(this,t,e)}static async fetchDicomData(t,e){if(void 0===e&&(e={}),""===t)throw Error("url must not be empty");let i=/^(?:[a-z+]+:)?\/\//i.test(t)?t:new URL(t,window.location.href);/(?:.([^.]+))?$/.exec(i.pathname)||(i=new URL("niivue-manifest.txt",t));let s=await fetch(i,{headers:e});if(!s.ok)throw Error(s.statusText);const r=(await s.text()).split("\n"),n=/(.*\/).*/.exec(i)[0],o=[];for(const a of r){const t=new URL(a,n);if(s=await fetch(t,{headers:e}),!s.ok)throw Error(s.statusText);const i=await s.arrayBuffer();o.push({name:a,data:i})}return o}static async readFirstDecompressedBytes(t,e){const i=t.getReader(),s=new w.as,r=[];let n,o,a=0,l=!1;const h=new Promise(((t,e)=>{n=t,o=e}));return s.ondata=t=>{r.push(t),a+=t.length,a>=e&&(l=!0,i.cancel().catch((()=>{})),function(){const t=new Uint8Array(a);let e=0;for(const i of r)t.set(i,e),e+=i.length;n(t)}())},(async()=>{try{for(;!l;){const{done:t,value:e}=await i.read();if(t)return l=!0,void s.push(new Uint8Array,!0);s.push(e,!1)}}catch(t){o(t)}})().catch((()=>{})),h}static extractFilenameFromUrl(t){const e=new URL(t).searchParams.get("response-content-disposition");if(e){const t=e.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/);if(t)return decodeURIComponent(t[1])}return t.split("/").pop().split("?")[0]}static async loadInitialVolumesGz(t,e,i){if(void 0===t&&(t=""),void 0===e&&(e={}),void 0===i&&(i=NaN),isNaN(i))return null;const s=await fetch(t,{headers:e,cache:"force-cache"});let r=352,n=await this.readFirstDecompressedBytes(s.body,r);const o=new DataView(n.buffer,n.byteOffset,n.byteLength),a=o.getUint16(0,!0),l=348===a;if(!l&&!(23553===a))return null;n.length>111&&(r=o.getFloat32(108,l)),r>n.length&&(n=await this.readFirstDecompressedBytes(s.body,r));if(!(92===n[0]&&1===n[1]||92===n[1]&&1===n[0]))return null;const h=await(0,u.Ad)(n.buffer);if(!h)throw new Error("Could not read NIfTI header");const c=h.numBitsPerVoxel/8,d=[1,2,3].reduce(((t,e)=>t*(h.dims[e]>1?h.dims[e]:1)),1),m=[4,5,6].reduce(((t,e)=>t*(h.dims[e]>1?h.dims[e]:1)),1),f=Math.max(Math.min(i,m),1),g=h.vox_offset+f*d*c;if(f===m)return null;const A=await fetch(t,{headers:e,cache:"force-cache"});return(await this.readFirstDecompressedBytes(A.body,g)).buffer.slice(0,g)}static async loadInitialVolumes(t,e,i){if(void 0===t&&(t=""),void 0===e&&(e={}),void 0===i&&(i=NaN),isNaN(i))return null;const s=(await fetch(t,{headers:e,cache:"force-cache"})).body.getReader(),{value:r,done:n}=await s.read();let o=r;if(n||!o||o.length<2)throw new Error("Not enough data to determine compression");const a=new DataView(o.buffer,o.byteOffset,o.byteLength),l=a.getUint16(0,!0);if(35615===l)return await s.cancel(),this.loadInitialVolumesGz(t,e,i);const h=348===l;if(!h&&!(23553===l))return await s.cancel(),null;let c=352;for(o.length>111&&(c=a.getFloat32(108,h));o.length<c;){let t=function(t,e){const i=new Uint8Array(t.length+e.length);return i.set(t,0),i.set(e,t.length),i};const{value:e,done:i}=await s.read();if(i||!e)break;o=t(o,e)}const d=await(0,u.Ad)(o.buffer);if(!d)throw new Error("Could not read NIfTI header");const m=d.numBitsPerVoxel/8,f=[1,2,3].reduce(((t,e)=>t*(d.dims[e]>1?d.dims[e]:1)),1),g=[4,5,6].reduce(((t,e)=>t*(d.dims[e]>1?d.dims[e]:1)),1),A=Math.max(Math.min(i,g),1),p=d.vox_offset+A*f*m,v=new Uint8Array(p),x=Math.min(o.length,p);v.set(o.subarray(0,x),0);let w=x;for(;w<p;){const{value:t,done:e}=await s.read();if(e||!t)return await s.cancel(),null;const i=Math.min(t.length,p-w);v.set(t.subarray(0,i),w),w+=i}return await s.cancel(),v.buffer}static async loadFromUrl(e){let{url:i="",urlImgData:s="",headers:r={},name:n="",colormap:o="",opacity:a=1,cal_min:l=NaN,cal_max:h=NaN,trustCalMinMax:c=!0,percentileFrac:d=.02,ignoreZeroVoxels:m=!1,useQFormNotSForm:u=!1,colormapNegative:x="",frame4D:w=0,isManifest:b=!1,limitFrames4D:y=NaN,imageType:C=ue.UNKNOWN,colorbarVisible:M=!0,buffer:D=new ArrayBuffer(0)}=void 0===e?{}:e;if(""===i)throw Error("url must not be empty");let I=null,T=null,S=null;if(i instanceof Uint8Array&&(i=i.slice().buffer),D.byteLength>0&&(i=D),i instanceof ArrayBuffer)if(T=i,""!==n)i=n;else{const t=new Uint8Array(T);i=31===t[0]&&139===t[1]?"array.nii.gz":"array.nii"}function F(t){const e=t.match(/\.([^.]+)(?:\.gz|\.bz2|\.xz)?$/);return e?e[1]:""}let E="";if(E=F(""===n?i:n),C===ue.UNKNOWN&&(C=ue.parse(E)),C===ue.UNKNOWN&&"string"==typeof i){const t=await fetch(i,{});if(t.redirected){const e=this.extractFilenameFromUrl(t.url);e&&e.length>0&&""===n&&(n=e,E=F(n),C=ue.parse(E))}}if(C===ue.ZARR){const t=new URL(i).searchParams,e=t.get("z"),s=t.get("y"),r=t.get("x"),n=e?f.di(parseInt(e),parseInt(e)+1):null,o=s?f.di(parseInt(s),parseInt(s)+1):null,a=r?f.di(parseInt(r),parseInt(r)+1):null,l=i.split("?")[0],h=new g.A(l),c=A.zr(h);let d,m;try{d=await p.h(c.resolve(i),{kind:"array"})}catch(U){d=await p.h(c,{kind:"array"})}if(4===d.shape.length){const t=null,e=d.shape[2],i=d.shape[1],s=d.shape[0];n&&n[0]>=e&&(n[0]=e-1),o&&o[0]>=i&&(o[0]=i-1),a&&a[0]>=s&&(a[0]=s-1),m=await v.Jt(d,[a,o,n,t])}else m=await v.Jt(d,[a,o,n]);T=m.data;const[u,x,w,b]=m.shape;S={data:T,width:x,height:u,depth:w,channels:b}}const B=C===ue.DCM||ue.NII;if(!T&&B&&(T=await this.loadInitialVolumes(i,r,y)),!T)if(b)T=await t.fetchDicomData(i,r),C=ue.DCM_MANIFEST;else{const t=await fetch(i,{headers:r});if(!t.ok)throw Error(t.statusText);if(!t.body)throw new Error("No readable stream available");const e=[],s=(await ve(t.body)).getReader();for(;;){const{done:t,value:i}=await s.read();if(t)break;e.push(i)}const n=e.reduce(((t,e)=>t+e.length),0);T=new ArrayBuffer(n);const o=new Uint8Array(T);let a=0;for(const i of e)o.set(i,a),a+=i.length}"HEAD"===E.toUpperCase()&&""===s&&(s=i.substring(0,i.lastIndexOf("HEAD"))+"BRIK");let V=null;if(s)try{let t=await fetch(s,{headers:r});if(404===t.status&&s.includes("BRIK")&&(t=await fetch(`${s}.gz`,{headers:r})),t.ok&&t.body){const e=await ve(t.body),i=[],s=e.getReader();for(;;){const{done:t,value:e}=await s.read();if(t)break;i.push(e)}const r=i.reduce(((t,e)=>t+e.length),0);V=new ArrayBuffer(r);const n=new Uint8Array(V);let o=0;for(const t of i)n.set(t,o),o+=t.length}}catch(R){console.error("Error loading paired image data:",R)}if(!T)throw new Error("Unable to load buffer properly from volume");if(!n){let t;try{t=new URL(i).pathname.split("/")}catch(U){t=i.split("/")}n=t.slice(-1)[0],n.indexOf("?")>-1&&(n=n.slice(0,n.indexOf("?")))}return I=await this.new(T,n,o,a,V,l,h,c,d,m,u,x,w,C,NaN,NaN,!0,null,0,S),I.url=i,I.colorbarVisible=M,I}static async readFileAsync(t,e){void 0===e&&(e=NaN);let i=t.stream();if(!isNaN(e)){let t=0;const s=new TransformStream({transform(i,s){if(t>=e)return void s.terminate();const r=e-t;i.length>r?(s.enqueue(i.slice(0,r)),s.terminate()):s.enqueue(i),t+=i.length}});i=i.pipeThrough(s)}const s=[],r=(await ve(i)).getReader();for(;;){const{done:t,value:e}=await r.read();if(t)break;s.push(e)}const n=s.reduce(((t,e)=>t+e.length),0),o=new ArrayBuffer(n),a=new Uint8Array(o);let l=0;for(const h of s)a.set(h,l),l+=h.length;return o}static async loadFromFile(t){let{file:e,name:i="",colormap:s="",opacity:r=1,urlImgData:n=null,cal_min:o=NaN,cal_max:a=NaN,trustCalMinMax:l=!0,percentileFrac:h=.02,ignoreZeroVoxels:c=!1,useQFormNotSForm:d=!1,colormapNegative:m="",frame4D:f=0,limitFrames4D:g=NaN,imageType:A=ue.UNKNOWN}=t,p=null,v=[];try{if(Array.isArray(e))v=await Promise.all(e.map((t=>this.readFileAsync(t))));else{if(isNaN(g))v=await this.readFileAsync(e);else{const t=await this.readFileAsync(e,512),i=new Uint8Array(t);if(92===i[0]&&1===i[1]||92===i[1]&&1===i[0]){const i=await(0,u.Ad)(t);if(!i)throw new Error("could not read nifti header");const s=i.numBitsPerVoxel/8,r=[1,2,3].reduce(((t,e)=>t*(i.dims[e]>1?i.dims[e]:1)),1),n=[4,5,6].reduce(((t,e)=>t*(i.dims[e]>1?i.dims[e]:1)),1),o=Math.max(Math.min(g,n),1),a=i.vox_offset+o*r*s;v=await this.readFileAsync(e,a)}else v=await this.readFileAsync(e)}i=e.name}let t=null;n&&(t=await this.readFileAsync(n)),p=await this.new(v,i,s,r,t,o,a,l,h,c,d,m,f,A,NaN,NaN,!0,null,0,null),p.fileObject=e}catch(x){throw U.error(x),new Error("could not build NVImage")}if(null===p)throw new Error("could not build NVImage");return p}static createNiftiArray(t,e,i,s,r){return void 0===t&&(t=[256,256,256]),void 0===e&&(e=[1,1,1]),void 0===i&&(i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1]),void 0===s&&(s=2),void 0===r&&(r=new Uint8Array),function(t,e,i,s,r){void 0===t&&(t=[256,256,256]),void 0===e&&(e=[1,1,1]),void 0===i&&(i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1]),void 0===s&&(s=2),void 0===r&&(r=new Uint8Array);const n=xe(t,e,i,s),o=Ae(n,!1);n.vox_offset=Math.max(352,o.length);const a=Ae(n,!1);if(r.length<1)return a;const l=Math.max(0,n.vox_offset-a.length),h=new Uint8Array(l),c=new Uint8Array(r.buffer,r.byteOffset,r.byteLength),d=n.vox_offset+c.length,m=new Uint8Array(d);return m.set(a,0),m.set(h,a.length),m.set(c,n.vox_offset),m}(t,e,i,s,r)}static createNiftiHeader(t,e,i,s){return void 0===t&&(t=[256,256,256]),void 0===e&&(e=[1,1,1]),void 0===i&&(i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1]),void 0===s&&(s=2),xe(t,e,i,s)}getVolumeData(t,e,i){return void 0===t&&(t=[-1,0,0]),void 0===e&&(e=[0,0,0]),void 0===i&&(i="same"),function(t,e,i,s){void 0===e&&(e=[-1,0,0]),void 0===i&&(i=[0,0,0]),void 0===s&&(s="same");const r=[new Uint8Array,[0,0,0]];if(!(t.hdr&&t.img&&t.dimsRAS&&t.img2RASstep&&t.img2RASstart))return U.error("getVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start)."),r;if(e=e.slice(0,3),i=i.slice(0,3),Math.min(...e)<0||Math.min(...i)<0)return U.warn("getVolumeData: Invalid start or end coordinates provided."),r;const n=t.dimsRAS.slice(1,4);for(let p=0;p<3;p++)if(e[p]=Math.max(0,Math.min(Math.round(e[p]),n[p]-1)),i[p]=Math.max(0,Math.min(Math.round(i[p]),n[p]-1)),i[p]<e[p]){const t=i[p];i[p]=e[p],e[p]=t}const o=[i[0]-e[0]+1,i[1]-e[1]+1,i[2]-e[2]+1],a=o[0]*o[1]*o[2];if(a<=0)return U.warn("getVolumeData: Calculated slab size is zero or negative."),r;let l,h=t.img.constructor;"uint8"===s?h=Uint8Array:"int16"===s?h=Int16Array:"uint16"===s?h=Uint16Array:"float32"===s||"scaled"===s||"normalized"===s||"windowed"===s?h=Float32Array:"float64"===s?h=Float64Array:"same"!==s&&U.warn(`getVolumeData: Unsupported dataType '${s}'. Using 'same'.`);try{l=new h(a)}catch(A){return U.error(`getVolumeData: Failed to create output array for dataType '${s}'.`,A),r}const c=t.img2RASstep,d=t.img2RASstart,m=t.img;let u=0;for(let p=e[2];p<=i[2];p++){const t=d[2]+p*c[2];for(let s=e[1];s<=i[1];s++){const r=d[1]+s*c[1];for(let s=e[0];s<=i[0];s++){const e=d[0]+s*c[0]+r+t;let i=0;e>=0&&e<m.length&&(i=m[e]),l[u++]=i}}}const f=isNaN(t.hdr.scl_slope)||0===t.hdr.scl_slope?1:t.hdr.scl_slope,g=isNaN(t.hdr.scl_inter)?0:t.hdr.scl_inter;if("scaled"===s||"normalized"===s||"windowed"===s){l instanceof Float32Array||(U.warn(`getVolumeData: Converting output to Float32 for scaling type '${s}'.`),l=Float32Array.from(l));for(let t=0;t<l.length;t++)l[t]=l[t]*f+g}if("normalized"===s||"windowed"===s){let e=t.cal_min,i=t.cal_max;"normalized"===s&&(e=t.global_min,i=t.global_max);const r=i-e,n=0===r?0:1/r;for(let t=0;t<l.length;t++)l[t]=(l[t]-e)*n,l[t]=Math.max(0,Math.min(l[t],1))}return[l,o]}(this,t,e,i)}setVolumeData(t,e,i){void 0===t&&(t=[-1,0,0]),void 0===e&&(e=[0,0,0]),void 0===i&&(i=new Uint8Array),function(t,e,i,s){if(void 0===e&&(e=[-1,0,0]),void 0===i&&(i=[0,0,0]),void 0===s&&(s=new Uint8Array),!(t.hdr&&t.img&&t.dimsRAS&&t.img2RASstep&&t.img2RASstart))return void U.error("setVolumeData: Missing required NVImage properties (hdr, img, dimsRAS, img2RASstep/start).");if(s.length<1)return void U.warn("setVolumeData: Input slabData is empty.");if(e=e.slice(0,3),i=i.slice(0,3),Math.min(...e)<0||Math.min(...i)<0)return void U.warn("setVolumeData: Invalid start or end coordinates provided.");const r=t.dimsRAS.slice(1,4);for(let d=0;d<3;d++)if(e[d]=Math.max(0,Math.min(Math.round(e[d]),r[d]-1)),i[d]=Math.max(0,Math.min(Math.round(i[d]),r[d]-1)),i[d]<e[d]){const t=i[d];i[d]=e[d],e[d]=t}const n=[i[0]-e[0]+1,i[1]-e[1]+1,i[2]-e[2]+1],o=n[0]*n[1]*n[2];if(o<=0)return void U.warn("setVolumeData: Calculated slab size is zero or negative.");if(s.length<o)return void U.error(`setVolumeData: Input slabData length (${s.length}) is less than the calculated slab size (${o}).`);const a=t.img2RASstep,l=t.img2RASstart,h=t.img;let c=0;for(let d=e[2];d<=i[2];d++){const t=l[2]+d*a[2];for(let r=e[1];r<=i[1];r++){const n=l[1]+r*a[1];for(let r=e[0];r<=i[0];r++){const e=l[0]+r*a[0]+n+t;e>=0&&e<h.length&&(h[e]=s[c]),c++}}}}(this,t,e,i)}static async loadFromBase64(t){let{base64:e,name:i="",colormap:s="",opacity:r=1,cal_min:n=NaN,cal_max:o=NaN,trustCalMinMax:a=!0,percentileFrac:l=.02,ignoreZeroVoxels:h=!1,useQFormNotSForm:c=!1,colormapNegative:d="",frame4D:m=0,imageType:u=ue.UNKNOWN,cal_minNeg:f=NaN,cal_maxNeg:g=NaN,colorbarVisible:A=!0,colormapLabel:p=null}=t;let v=null;try{const t=function(t){const e=window.atob(t),i=e.length,s=new Uint8Array(i);for(let r=0;r<i;r++)s[r]=e.charCodeAt(r);return s.buffer}(e),x=null;v=await this.new(t,i,s,r,x,n,o,a,l,h,c,d,m,u,f,g,A,p,0,null)}catch(x){U.debug(x)}if(null===v)throw new Error("could not load NVImage");return v}clone(){const e=new t;return e.id=(0,a.v4)(),e.hdr=Object.assign({},this.hdr),e.img=this.img.slice(),e.calculateRAS(),e.calMinMax(),e}zeroImage(){this.img.fill(0)}getImageMetadata(){if(!this.hdr)throw new Error("hdr undefined");const t=this.id,e=this.hdr.datatypeCode,i=this.hdr.dims,s=i[1],r=i[2],n=i[3],o=Math.max(1,i[4]),a=this.hdr.pixDims;return{id:t,datatypeCode:e,nx:s,ny:r,nz:n,nt:o,dx:a[1],dy:a[2],dz:a[3],dt:a[4],bpv:Math.floor(this.hdr.numBitsPerVoxel/8)}}static zerosLike(t,e){void 0===e&&(e="same");const i=t.clone();return i.zeroImage(),"uint8"===e&&(i.img=Uint8Array.from(i.img),i.hdr.datatypeCode=2,i.hdr.numBitsPerVoxel=8),"float32"===e&&(i.img=Float32Array.from(i.img),i.hdr.datatypeCode=16,i.hdr.numBitsPerVoxel=32),i}getValue(t,e,i,s,r){return void 0===s&&(s=0),void 0===r&&(r=!1),function(t,e,i,s,r,n){void 0===r&&(r=0),void 0===n&&(n=!1);const o=ye(t,e,i,s,r,n);return o.length<3?o[0]:.2126*o[0]+.7152*o[1]+.0722*o[2]}(this,t,e,i,s,r)}getValues(t,e,i,s,r){return void 0===s&&(s=0),void 0===r&&(r=!1),ye(this,t,e,i,s,r)}applyOptionsUpdate(t){this.hdr.cal_min=t.cal_min,this.hdr.cal_max=t.cal_max,Object.assign(this,t)}getImageOptions(){return fe("","",this.name,this._colormap,this.opacity,this.hdr.cal_min,this.hdr.cal_max,this.trustCalMinMax,this.percentileFrac,this.ignoreZeroVoxels,this.useQFormNotSForm,this.colormapNegative,this.frame4D,this.imageType,this.colormapType)}toUint8Array(t){return void 0===t&&(t=null),we(this,t)}convertVox2Frac(t){return r.fA((t[0]+.5)/this.dimsRAS[1],(t[1]+.5)/this.dimsRAS[2],(t[2]+.5)/this.dimsRAS[3])}convertFrac2Vox(t){return r.fA(Math.round(t[0]*this.dims[1]-.5),Math.round(t[1]*this.dims[2]-.5),Math.round(t[2]*this.dims[3]-.5))}convertFrac2MM(t,e){void 0===e&&(e=!1);const i=s.fA(t[0],t[1],t[2],1);return e?s.Z0(i,i,this.frac2mm):s.Z0(i,i,this.frac2mmOrtho),i}convertMM2Frac(t,e){void 0===e&&(e=!1);const i=s.fA(t[0],t[1],t[2],1),o=this.dimsRAS,a=r.fA(0,0,0);if(void 0===o)return a;if(!e){const t=n.o8(this.frac2mmOrtho);return n.B8(t,t),s.Z0(i,i,t),a[0]=i[0],a[1]=i[1],a[2]=i[2],a}if(o[1]<1||o[2]<1||o[3]<1)return a;const l=n.o8(this.matRAS);return n.B8(l,l),n.mg(l,l),s.Z0(i,i,l),a[0]=(i[0]+.5)/o[1],a[1]=(i[1]+.5)/o[2],a[2]=(i[2]+.5)/o[3],a}},Ue=(t=>(t[t.AXIAL=0]="AXIAL",t[t.CORONAL=1]="CORONAL",t[t.SAGITTAL=2]="SAGITTAL",t[t.MULTIPLANAR=3]="MULTIPLANAR",t[t.RENDER=4]="RENDER",t))(Ue||{}),Re=(t=>(t[t.NEVER=0]="NEVER",t[t.ALWAYS=1]="ALWAYS",t[t.AUTO=2]="AUTO",t))(Re||{}),Ne=(t=>(t[t.AUTO=0]="AUTO",t[t.COLUMN=1]="COLUMN",t[t.GRID=2]="GRID",t[t.ROW=3]="ROW",t))(Ne||{}),Pe=(t=>(t[t.none=0]="none",t[t.contrast=1]="contrast",t[t.measurement=2]="measurement",t[t.pan=3]="pan",t[t.slicer3D=4]="slicer3D",t[t.callbackOnly=5]="callbackOnly",t[t.roiSelection=6]="roiSelection",t[t.angle=7]="angle",t[t.crosshair=8]="crosshair",t[t.windowing=9]="windowing",t))(Pe||{}),Le={textHeight:-1,fontSizeScaling:.4,fontMinPx:13,colorbarHeight:.05,colorbarWidth:-1,showColorbarBorder:!0,crosshairWidth:1,crosshairWidthUnit:"voxels",crosshairGap:0,rulerWidth:4,show3Dcrosshair:!1,backColor:[0,0,0,1],crosshairColor:[1,0,0,1],fontColor:[.5,.5,.5,1],selectionBoxColor:[1,1,1,.5],clipPlaneColor:[.7,0,.7,.5],paqdUniforms:[.3,.5,.5,1],clipThick:2,clipVolumeLow:[0,0,0],clipVolumeHigh:[1,1,1],rulerColor:[1,0,0,.8],colorbarMargin:.05,trustCalMinMax:!0,clipPlaneHotKey:"KeyC",viewModeHotKey:"KeyV",doubleTouchTimeout:500,longTouchTimeout:1e3,keyDebounceTime:50,isNearestInterpolation:!1,isResizeCanvas:!0,atlasOutline:0,atlasActiveIndex:0,isRuler:!1,isColorbar:!1,isOrientCube:!1,tileMargin:0,multiplanarPadPixels:0,multiplanarForceRender:!1,multiplanarEqualSize:!1,multiplanarShowRender:2,isRadiologicalConvention:!1,meshThicknessOn2D:1/0,dragMode:1,dragModePrimary:8,mouseEventConfig:void 0,touchEventConfig:void 0,yoke3Dto2DZoom:!1,isDepthPickMesh:!1,isCornerOrientationText:!1,isOrientationTextVisible:!0,showAllOrientationMarkers:!1,heroImageFraction:0,heroSliceType:4,sagittalNoseLeft:!1,isSliceMM:!1,isV1SliceShader:!1,forceDevicePixelRatio:0,logLevel:"info",loadingText:"loading ...",isForceMouseClickToVoxelCenters:!1,dragAndDropEnabled:!0,drawingEnabled:!1,penValue:1,penType:0,floodFillNeighbors:6,isFilledPen:!1,thumbnail:"",maxDrawUndoBitmaps:8,sliceType:3,meshXRay:0,isAntiAlias:null,limitFrames4D:NaN,isAdditiveBlend:!1,showLegend:!0,legendBackgroundColor:[.3,.3,.3,.5],legendTextColor:[1,1,1,1],multiplanarLayout:0,renderOverlayBlend:1,sliceMosaicString:"",centerMosaic:!1,penSize:1,interactive:!0,clickToSegment:!1,clickToSegmentRadius:3,clickToSegmentBright:!0,clickToSegmentAutoIntensity:!1,clickToSegmentIntensityMax:NaN,clickToSegmentIntensityMin:NaN,clickToSegmentPercent:0,clickToSegmentMaxDistanceMM:Number.POSITIVE_INFINITY,clickToSegmentIs2D:!1,selectionBoxLineThickness:4,selectionBoxIsOutline:!1,scrollRequiresFocus:!1,showMeasureUnits:!0,measureTextJustify:"center",measureTextColor:[1,0,0,1],measureLineColor:[1,0,0,1],measureTextHeight:.06,isAlphaClipDark:!1,gradientOrder:1,gradientOpacity:0,renderSilhouette:0,gradientAmount:0,invertScrollDirection:!1,is2DSliceShader:!1,bounds:null,showBoundsBorder:!1,boundsBorderColor:[1,1,1,1]},ke={gamma:1,azimuth:110,elevation:10,crosshairPos:r.fA(.5,.5,.5),clipPlane:[0,0,0,0],clipPlaneDepthAziElev:[2,0,0],volScaleMultiplier:1,pan2Dxyzmm:s.fA(0,0,0,1),clipThick:2,clipVolumeLow:[0,0,0],clipVolumeHigh:[1,1,1]};var Oe=class t{constructor(){M(this,"data",{title:"Untitled document",imageOptionsArray:[],meshOptionsArray:[],opts:{...Le},previewImageDataURL:"",labels:[],encodedImageBlobs:[],encodedDrawingBlob:""}),M(this,"scene"),M(this,"volumes",[]),M(this,"meshDataObjects"),M(this,"meshes",[]),M(this,"drawBitmap",null),M(this,"imageOptionsMap",new Map),M(this,"meshOptionsMap",new Map),M(this,"completedMeasurements",[]),M(this,"completedAngles",[]),M(this,"_optsProxy",null),M(this,"_optsChangeCallback",null),this.scene={onAzimuthElevationChange:()=>{},onZoom3DChange:()=>{},sceneData:{...ke,pan2Dxyzmm:s.fA(0,0,0,1),crosshairPos:r.fA(.5,.5,.5)},get renderAzimuth(){return this.sceneData.azimuth},set renderAzimuth(t){this.sceneData.azimuth=t,this.onAzimuthElevationChange&&this.onAzimuthElevationChange(this.sceneData.azimuth,this.sceneData.elevation)},get renderElevation(){return this.sceneData.elevation},set renderElevation(t){this.sceneData.elevation=t,this.onAzimuthElevationChange&&this.onAzimuthElevationChange(this.sceneData.azimuth,this.sceneData.elevation)},get volScaleMultiplier(){return this.sceneData.volScaleMultiplier},set volScaleMultiplier(t){this.sceneData.volScaleMultiplier=t,this.onZoom3DChange(t)},get crosshairPos(){return this.sceneData.crosshairPos},set crosshairPos(t){this.sceneData.crosshairPos=t},get clipPlane(){return this.sceneData.clipPlane},set clipPlane(t){this.sceneData.clipPlane=t},get clipPlaneDepthAziElev(){return this.sceneData.clipPlaneDepthAziElev},set clipPlaneDepthAziElev(t){this.sceneData.clipPlaneDepthAziElev=t},get pan2Dxyzmm(){return this.sceneData.pan2Dxyzmm},set pan2Dxyzmm(t){this.sceneData.pan2Dxyzmm=t},get gamma(){return this.sceneData.gamma},set gamma(t){this.sceneData.gamma=t}}}get title(){return this.data.title}get previewImageDataURL(){return this.data.previewImageDataURL}set previewImageDataURL(t){this.data.previewImageDataURL=t}set title(t){this.data.title=t}get imageOptionsArray(){return this.data.imageOptionsArray}get encodedImageBlobs(){return this.data.encodedImageBlobs}get encodedDrawingBlob(){return this.data.encodedDrawingBlob}get opts(){return this._optsProxy||this._createOptsProxy(),this._optsProxy}set opts(t){this.data.opts={...t},this._optsProxy=null}get labels(){return this.data.labels}set labels(t){this.data.labels=t}get customData(){return this.data.customData}set customData(t){this.data.customData=t}hasImage(t){return void 0!==this.volumes.find((e=>e.id===t.id))}hasImageFromUrl(t){return void 0!==this.data.imageOptionsArray.find((e=>e.url===t))}addImageOptions(t,e){if(!this.hasImage(t)&&!e.name)if(e.url){const t=/^(?:[a-z+]+:)?\/\//i.test(e.url)?new URL(e.url):new URL(e.url,window.location.href);e.name=t.pathname.split("/").pop(),e.name.toLowerCase().endsWith(".gz")&&(e.name=e.name.slice(0,-3)),e.name.toLowerCase().endsWith(".nii")||(e.name+=".nii")}else e.name="untitled.nii";e.imageType=ue.NII,this.data.imageOptionsArray.push(e),this.imageOptionsMap.set(t.id,this.data.imageOptionsArray.length-1)}removeImage(t){if(this.imageOptionsMap.has(t.id)){const e=this.imageOptionsMap.get(t.id);this.data.imageOptionsArray.length>e&&this.data.imageOptionsArray.splice(e,1),this.imageOptionsMap.delete(t.id)}this.volumes=this.volumes.filter((e=>e.id!==t.id))}async fetchLinkedData(){if(this.data.encodedImageBlobs=[],this.imageOptionsArray?.length)for(const e of this.imageOptionsArray)if(e.url)try{const t=await fetch(e.url);if(!t.ok){console.warn("Failed to fetch image:",e.url);continue}const i=await t.arrayBuffer(),s=new Uint8Array(i),r=ae.uint8tob64(s);this.data.encodedImageBlobs.push(r),console.info("fetch linked data fetched from ",e.url)}catch(t){console.warn(`Failed to fetch/encode image from ${e.url}:`,t)}}getImageOptions(t){return this.imageOptionsMap.has(t.id)?this.data.imageOptionsArray[this.imageOptionsMap.get(t.id)]:null}json(t,e){void 0===t&&(t=!0),void 0===e&&(e=!0);const i={encodedImageBlobs:[],previewImageDataURL:this.data.previewImageDataURL,imageOptionsMap:new Map},s=[];i.sceneData={...this.scene.sceneData},i.opts=function(t,e){const i={};for(const s in t){const r=t[s],n=e[s],o=Array.isArray(r)&&Array.isArray(n);(o&&r.some(((t,e)=>t!==n[e]))||!o&&r!==n)&&(i[s]=r)}return i}(this.opts,Le),this.opts.meshThicknessOn2D===1/0&&(i.opts.meshThicknessOn2D="infinity"),this.opts.meshThicknessOn2D===1/0&&(i.opts.meshThicknessOn2D="infinity"),i.labels=[...this.data.labels];for(const n of i.labels)delete n.onClick;if(i.customData=this.customData,i.completedMeasurements=[...this.completedMeasurements],i.completedAngles=[...this.completedAngles],this.volumes.length)for(let n=0;n<this.volumes.length;n++){const e=this.volumes[n];let r=this.getImageOptions(e);if(null===r?(U.warn("no options found for image, using options from the volume directly"),r={name:e?.name??"",colormap:e?._colormap??"gray",opacity:e?._opacity??1,pairedImgData:null,cal_min:e?.cal_min??NaN,cal_max:e?.cal_max??NaN,trustCalMinMax:e?.trustCalMinMax??!0,percentileFrac:e?.percentileFrac??.02,ignoreZeroVoxels:e?.ignoreZeroVoxels??!1,useQFormNotSForm:e?.useQFormNotSForm??!1,colormapNegative:e?.colormapNegative??"",colormapLabel:e?.colormapLabel??null,imageType:e?.imageType??ue.NII,frame4D:e?.frame4D??0,limitFrames4D:e?.limitFrames4D??NaN,url:e?.url??"",urlImageData:e?.urlImgData??"",alphaThreshold:!1,cal_minNeg:e?.cal_minNeg??NaN,cal_maxNeg:e?.cal_maxNeg??NaN,colorbarVisible:e?.colorbarVisible??!0}):"imageType"in r||(r.imageType=ue.NII),r.colormap=e.colormap,r.colormapLabel=e.colormapLabel,r.opacity=e.opacity,r.cal_max=e.cal_max??NaN,r.cal_min=e.cal_min??NaN,s.push(r),t){const t=ae.uint8tob64(e.toUint8Array());i.encodedImageBlobs.push(t)}i.imageOptionsMap.set(e.id,n)}i.imageOptionsArray=[...s];const r=[];i.connectomes=[];for(const n of this.meshes){if("connectome"===n.type){i.connectomes.push(JSON.stringify(n.json()));continue}const t={pts:n.pts,tris:n.tris,name:n.name,rgba255:Uint8Array.from(n.rgba255),opacity:n.opacity,connectome:n.connectome,dpg:n.dpg,dps:n.dps,dpv:n.dpv,meshShaderIndex:n.meshShaderIndex,layers:n.layers.map((t=>({values:t.values,nFrame4D:t.nFrame4D,frame4D:0,outlineBorder:t.outlineBorder,global_min:t.global_min,global_max:t.global_max,cal_min:t.cal_min,cal_max:t.cal_max,opacity:t.opacity,colormap:t.colormap,colormapNegative:t.colormapNegative,colormapLabel:t.colormapLabel,useNegativeCmap:t.useNegativeCmap}))),hasConnectome:n.hasConnectome,edgeColormap:n.edgeColormap,edgeColormapNegative:n.edgeColormapNegative,edgeMax:n.edgeMax,edgeMin:n.edgeMin,edges:n.edges&&Array.isArray(n.edges)?[...n.edges]:[],extentsMax:n.extentsMax,extentsMin:n.extentsMin,furthestVertexFromOrigin:n.furthestVertexFromOrigin,nodeColormap:n.nodeColormap,nodeColormapNegative:n.nodeColormapNegative,nodeMaxColor:n.nodeMaxColor,nodeMinColor:n.nodeMinColor,nodeScale:n.nodeScale,legendLineThickness:n.legendLineThickness,offsetPt0:n.offsetPt0,nodes:n.nodes};n.offsetPt0&&n.offsetPt0.length>0&&(t.offsetPt0=n.offsetPt0,t.fiberGroupColormap=n.fiberGroupColormap,t.fiberColor=n.fiberColor,t.fiberDither=n.fiberDither,t.fiberRadius=n.fiberRadius,t.colormap=n.colormap),r.push(t)}return i.meshesString=JSON.stringify((0,h.l)(r)),e&&this.drawBitmap&&(i.encodedDrawingBlob=ae.uint8tob64(this.drawBitmap)),i}async download(t,e,i){void 0===i&&(i={embedImages:!0});const s=this.json(i.embedImages),r=JSON.stringify(s),n=e?"application/gzip":"application/json",o=e?await ae.compressStringToArrayBuffer(r):r;ae.download(o,t,n)}static deserializeMeshDataObjects(t){if(t.data.meshesString&&"[]"!==t.data.meshesString){if(t.data.meshesString){t.meshDataObjects=(0,c.i)(JSON.parse(t.data.meshesString));for(const e of t.meshDataObjects)for(const t of e.layers)"colorMap"in t&&(t.colormap=t.colorMap,delete t.colorMap),"colorMapNegative"in t&&(t.colormapNegative=t.colorMapNegative,delete t.colorMapNegative)}}else t.meshDataObjects=[]}static async loadFromUrl(e){const i=await fetch(e),s=await i.arrayBuffer();let r;if(ae.isArrayBufferCompressed(s)){const t=await ae.decompressArrayBuffer(s);r=JSON.parse(t)}else{const t=new TextDecoder;r=JSON.parse(t.decode(s))}return t.loadFromJSON(r)}static async loadFromFile(e){const i=await ae.readFileAsync(e);let s;const r=new t;if(ae.isArrayBufferCompressed(i))s=await ae.decompressArrayBuffer(i);else{s=(new TextDecoder).decode(i)}return r.data=JSON.parse(s),"infinity"===r.data.opts.meshThicknessOn2D&&(r.data.opts.meshThicknessOn2D=1/0),r.scene.sceneData={...ke,...r.data.sceneData},t.deserializeMeshDataObjects(r),r}static loadFromJSON(e){const i=new t;return Object.assign(i.data,{...e,imageOptionsArray:e.imageOptionsArray??[],encodedImageBlobs:e.encodedImageBlobs??[],labels:e.labels??[],meshOptionsArray:e.meshOptionsArray??[],connectomes:e.connectomes??[],encodedDrawingBlob:e.encodedDrawingBlob??"",previewImageDataURL:e.previewImageDataURL??"",customData:e.customData??"",title:e.title??"untitled"}),i.data.opts={...Le,...e.opts||{}},"infinity"===i.data.opts.meshThicknessOn2D&&(i.data.opts.meshThicknessOn2D=1/0),i.scene.sceneData={...ke,...e.sceneData||{}},e.completedMeasurements&&(i.completedMeasurements=e.completedMeasurements.map((t=>({...t,startMM:r.o8(t.startMM),endMM:r.o8(t.endMM)})))),e.completedAngles&&(i.completedAngles=e.completedAngles.map((t=>({...t,firstLineMM:{start:r.o8(t.firstLineMM.start),end:r.o8(t.firstLineMM.end)},secondLineMM:{start:r.o8(t.secondLineMM.start),end:r.o8(t.secondLineMM.end)}})))),i.data.meshesString&&t.deserializeMeshDataObjects(i),i}static oldloadFromJSON(e){const i=new t;return i.data=e,"infinity"===i.data.opts.meshThicknessOn2D&&(i.data.opts.meshThicknessOn2D=1/0),i.scene.sceneData={...ke,...e.sceneData},t.deserializeMeshDataObjects(i),i}setOptsChangeCallback(t){this._optsChangeCallback=t,this._optsProxy=null}removeOptsChangeCallback(){this._optsChangeCallback=null,this._optsProxy=null}_createOptsProxy(){const t=this.data.opts;this._optsProxy=new Proxy(t,{set:(t,e,i)=>{const s=t[e];return s!==i&&(t[e]=i,this._optsChangeCallback&&"string"==typeof e&&e in Le&&this._optsChangeCallback(e,i,s)),!0},get:(t,e)=>t[e]})}},Ye={colormap:"gray",opacity:0,nFrame4D:0,frame4D:0,outlineBorder:0,cal_min:0,cal_max:0,cal_minNeg:0,cal_maxNeg:0,colormapType:0,values:new Array,useNegativeCmap:!1,showLegend:!0},Ge=class t{constructor(t,e,i,s,r,n,o,l,h,c,d,m,u){void 0===i&&(i=""),void 0===s&&(s=new Uint8Array([255,255,255,255])),void 0===r&&(r=1),void 0===n&&(n=!0),void 0===l&&(l=null),void 0===h&&(h=null),void 0===c&&(c=null),void 0===d&&(d=null),void 0===m&&(m=!0),void 0===u&&(u=""),M(this,"id"),M(this,"name"),M(this,"anatomicalStructurePrimary"),M(this,"colorbarVisible"),M(this,"furthestVertexFromOrigin"),M(this,"extentsMin"),M(this,"extentsMax"),M(this,"opacity"),M(this,"visible"),M(this,"meshShaderIndex",0),M(this,"offsetPt0",null),M(this,"colormapInvert",!1),M(this,"fiberGroupColormap",null),M(this,"indexBuffer"),M(this,"vertexBuffer"),M(this,"vao"),M(this,"vaoFiber"),M(this,"pts"),M(this,"tris"),M(this,"layers"),M(this,"type","mesh"),M(this,"data_type"),M(this,"rgba255"),M(this,"fiberLength"),M(this,"fiberLengths"),M(this,"fiberDensity"),M(this,"fiberDither",.1),M(this,"fiberColor","Global"),M(this,"fiberDecimationStride",1),M(this,"fiberSides",5),M(this,"fiberRadius",0),M(this,"fiberOcclusion",0),M(this,"f32PerVertex",5),M(this,"fiberMask"),M(this,"colormap"),M(this,"dpg"),M(this,"dps"),M(this,"dpv"),M(this,"hasConnectome",!1),M(this,"connectome"),M(this,"indexCount"),M(this,"vertexCount",1),M(this,"nodeScale",4),M(this,"edgeScale",1),M(this,"legendLineThickness",0),M(this,"showLegend",!0),M(this,"nodeColormap","warm"),M(this,"edgeColormap","warm"),M(this,"nodeColormapNegative"),M(this,"edgeColormapNegative"),M(this,"nodeMinColor"),M(this,"nodeMaxColor"),M(this,"edgeMin"),M(this,"edgeMax"),M(this,"nodes"),M(this,"edges"),M(this,"points"),this.anatomicalStructurePrimary=u,this.name=i,this.colorbarVisible=m,this.id=(0,a.v4)();const f=ne.getExtents(t);this.furthestVertexFromOrigin=f.mxDx,this.extentsMin=f.extentsMin,this.extentsMax=f.extentsMax,this.opacity=r>1?1:r,this.visible=n,this.meshShaderIndex=0,this.indexBuffer=o.createBuffer(),this.vertexBuffer=o.createBuffer(),this.vao=o.createVertexArray(),o.bindVertexArray(this.vao),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,this.indexBuffer),o.bindBuffer(o.ARRAY_BUFFER,this.vertexBuffer),o.enableVertexAttribArray(0),o.enableVertexAttribArray(1);if(7!==this.f32PerVertex?(o.vertexAttribPointer(0,3,o.FLOAT,!1,20,0),o.vertexAttribPointer(1,4,o.BYTE,!0,20,12),o.enableVertexAttribArray(2),o.vertexAttribPointer(2,4,o.UNSIGNED_BYTE,!0,20,16)):(o.vertexAttribPointer(0,3,o.FLOAT,!1,28,0),o.vertexAttribPointer(1,3,o.FLOAT,!1,28,12),o.enableVertexAttribArray(2),o.vertexAttribPointer(2,4,o.UNSIGNED_BYTE,!0,28,24)),o.bindVertexArray(null),this.vaoFiber=o.createVertexArray(),this.offsetPt0=null,this.hasConnectome=!1,this.colormapInvert=!1,this.fiberGroupColormap=null,this.pts=t,this.layers=[],this.type="mesh",this.tris=e,s[3]<1)return this.rgba255=s,this.fiberLength=2,this.fiberDither=.1,this.fiberColor="Global",this.fiberDecimationStride=1,this.fiberMask=[],this.colormap=l,this.dpg=h,this.dps=c,this.dpv=d,h&&this.initValuesArray(h),c&&this.initValuesArray(c),d&&this.initValuesArray(d),this.offsetPt0=new Uint32Array(e),this.tris=new Uint32Array(0),this.updateFibers(o),o.bindVertexArray(this.vaoFiber),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,this.indexBuffer),o.bindBuffer(o.ARRAY_BUFFER,this.vertexBuffer),o.enableVertexAttribArray(0),o.vertexAttribPointer(0,3,o.FLOAT,!1,16,0),o.enableVertexAttribArray(1),o.vertexAttribPointer(1,4,o.UNSIGNED_BYTE,!0,16,12),void o.bindVertexArray(null);if(l){this.connectome=l,this.hasConnectome=!0;const t=Object.keys(l);for(let e=0,i=t.length;e<i;e++)this[t[e]]=l[t[e]]}this.rgba255=s,this.updateMesh(o)}initValuesArray(t){for(let e=0;e<t.length;e++){const i=t[e].vals.reduce(((t,e)=>Math.min(t,e))),s=t[e].vals.reduce(((t,e)=>Math.max(t,e)));t[e].global_min=i,t[e].global_max=s,t[e].cal_min=i,t[e].cal_max=s}return t}linesToCylinders(t,e,i){function n(t){return r.fA(t[0],t[1],t[2])}const o=Math.pow(2,32)-1,a=i.length;let l=0,h=0;for(let s=0;s<a;s++)i[s]!==o?l++:h++;const c=this.fiberSides,d=c*l,m=this.f32PerVertex;if(5!==m)throw Error("fiberSides > 1 requires f32PerVertex == 5");const u=new Float32Array(d*m),f=new Uint8Array(u.buffer);let g=0,A=s.vt(),p=s.vt(),v=s.vt();const x=r.vt();let w=r.vt(),b=0;const y=this.fiberRadius;for(let I=0;I<a;I++){const t=i[I]===o;if(t&&b<1)continue;let l=4*i[I];if(b++,b<=1){A=s.fA(e[l+0],e[l+1],e[l+2],e[l+3]),p=s.o8(A),I+1<a&&i[I+1]!==o&&(l=4*i[I+1],v=s.fA(e[l+0],e[l+1],e[l+2],e[l+3]),r.Re(x,n(A),n(v)),r.S8(x,x),w=B.getFirstPerpVector(x));continue}v=t?s.o8(p):s.fA(e[l+0],e[l+1],e[l+2],e[l+3]),r.Re(x,n(A),n(v)),r.S8(x,x);const h=r.vt();r.$A(h,w,x);const d=r.vt();r.$A(d,x,h),w=r.o8(w);const C=r.vt();r.$A(C,x,d),r.S8(C,C);const M=r.vt();for(let e=0;e<c;e++){const t=Math.cos(e/c*2*Math.PI),i=Math.sin(e/c*2*Math.PI);M[0]=y*(t*d[0]+i*C[0]),M[1]=y*(t*d[1]+i*C[1]),M[2]=y*(t*d[2]+i*C[2]),r.WQ(M,n(p),M);const s=g*m;u[s+0]=M[0],u[s+1]=M[1],u[s+2]=M[2];const o=r.vt();r.Re(o,M,n(p)),r.S8(o,o);const a=4*(s+3);f[a+0]=127*o[0],f[a+1]=127*o[1],f[a+2]=127*o[2],u[s+4]=p[3],g++}A=s.o8(p),p=s.o8(v),t&&(b=0)}const C=(l-h)*c*2*3,M=new Uint32Array(C);let D=0;g=0;for(let s=1;s<a;s++){if(i[s]===o){g+=c;continue}if(i[s-1]===o)continue;let t=g,e=g+c;const r=e,n=e+c;for(let i=0;i<c;i++)M[D++]=t,M[D++]=e++,e===n&&(e=n-c),M[D++]=e,M[D++]=t++,t===r&&(t=r-c),M[D++]=e,M[D++]=t;g+=c}t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,Uint32Array.from(M),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,f,t.STATIC_DRAW),this.indexCount=C}createFiberDensityMap(){if(this.fiberDensity)return;const t=this.pts,e=t.length/3;let i=0;for(let f=0;f<3;f++){const t=this.extentsMax[f]-this.extentsMin[f];i=Math.max(i,t)}if(this.fiberDensity=new Float32Array(e),0===i)return;const s=64,r=i/63/2,n=63/i;let o=new Float32Array(262144);const a=[this.extentsMin[0]-r,this.extentsMin[1]-r,this.extentsMin[2]-r],l=[0,0,0];let h=0;for(let f=0;f<e;f++){l[0]=Math.round((t[h++]-a[0])*n),l[1]=Math.round((t[h++]-a[1])*n),l[2]=Math.round((t[h++]-a[2])*n);const e=l[0]+l[1]*s+4096*l[2];-1!==e&&o[e]++}function c(t,e){let i=t.slice(),s=-1;const r=e-1;for(let o=0;o<e;o++)for(let n=0;n<e;n++)for(let o=0;o<e;o++)s++,o<1||o>=r||(t[s]=i[s-1]+i[s]+i[s]+i[s+1]);s=-1,i=t.slice();for(let o=0;o<e;o++)for(let n=0;n<e;n++)for(let o=0;o<e;o++)s++,n<1||n>=r||(t[s]=i[s-e]+i[s]+i[s]+i[s+e]);const n=e*e;s=-1,i=t.slice();for(let o=0;o<e;o++)for(let a=0;a<e;a++)for(let l=0;l<e;l++)s++,o<1||o>=r||(t[s]=i[s-n]+i[s]+i[s]+i[n]);return t}o=c(o,s),o=c(o,s);let d=0,m=1/0;const u=262144;for(let f=0;f<u;f++)o[f]<=0||(d=Math.max(d,o[f]),m=Math.min(m,o[f]));if(!(d<=1||d<=m)){h=0;for(let t=0;t<u;t++)o[t]=Math.max(0,o[t]-m);d-=m;for(let i=0;i<e;i++){l[0]=Math.round((t[h++]-a[0])*n),l[1]=Math.round((t[h++]-a[1])*n),l[2]=Math.round((t[h++]-a[2])*n);const e=l[0]+l[1]*s+4096*l[2];this.fiberDensity[i]=o[e]/d}}}updateFibers(t){if(!this.offsetPt0||!this.fiberLength)return;const e=this.pts,i=this.offsetPt0,s=i.length-1,n=e.length/3;if(!this.fiberLengths){this.fiberLengths=new Uint32Array(s);for(let t=0;t<s;t++){const s=3*i[t],n=3*(i[t+1]-1);let o=0;for(let t=s;t<n;t+=3){const i=r.fA(e[t+0]-e[t+3],e[t+1]-e[t+4],e[t+2]-e[t+5]);o+=r.Il(i)}this.fiberLengths[t]=o}}const o=new Float32Array(4*n),a=new Uint32Array(o.buffer);let l=0,h=0;for(let r=0;r<n;r++)o[h+0]=e[l+0],o[h+1]=e[l+1],o[h+2]=e[l+2],l+=3,h+=4;const c=this.fiberDither,d=.5*c;function m(t,e,i){const s=255*(c*Math.random()-d);return(t=Math.max(Math.min(t+s,255),0))+((e=Math.max(Math.min(e+s,255),0))<<8)+((i=Math.max(Math.min(i+s,255),0))<<16)}function u(t,e,i,s,n,o,a){const l=r.fA(Math.abs(t-s),Math.abs(e-n),Math.abs(i-o));r.S8(l,l);const h=a-d;for(let r=0;r<3;r++)l[r]=255*Math.max(Math.min(Math.abs(l[r])+h,1),0);return l[0]+(l[1]<<8)+(l[2]<<16)}const f=this.fiberColor.toLowerCase();let g=null,A=null;if(f.startsWith("dps")&&this.dps&&this.dps.length>0){const t=parseInt(f.substring(3));t<this.dps.length&&this.dps[t].vals.length===s&&(g=this.dps[t].vals)}if(f.startsWith("dpv")&&this.dpv&&this.dpv.length>0){const t=parseInt(f.substring(3));t<this.dpv.length&&this.dpv[t].vals.length===n&&(A=this.dpv[t])}const p=new Int16Array(s);if(this.dpg&&null!==this.fiberGroupColormap){const t=new Uint8ClampedArray(4*this.dpg.length),e=new Array(this.dpg.length).fill(!1),r=this.fiberGroupColormap;void 0===r.A&&(r.A=Array.from(new Uint8ClampedArray(r.I.length).fill(255)));for(let i=0;i<r.I.length;i++){let s=r.I[i];s<0||s>=this.dpg.length||(r.A[i]<1||(e[s]=!0,s*=4,t[s]=r.R[i],t[s+1]=r.G[i],t[s+2]=r.B[i],t[s+3]=255))}p.fill(-1);for(let i=0;i<this.dpg.length;i++)if(e[i])for(let t=0;t<this.dpg[i].vals.length;t++)p[this.dpg[i].vals[t]]=i;for(let n=0;n<s;n++){if(p[n]<0)continue;const e=p[n]%256*4,s=m(t[e],t[e+1],t[e+2]),r=i[n],o=4*(i[n+1]-1)+3;for(let t=4*r+3;t<=o;t+=4)a[t]=s}}else if(A){const t=re.colormap(this.colormap,this.colormapInvert),e=A.cal_min,i=A.cal_max;let s=3;for(let r=0;r<n;r++){let n=Math.min(Math.max((A.vals[r]-e)/(i-e),0),1);n=4*Math.round(Math.max(Math.min(255,255*n)));const o=t[n]+(t[n+1]<<8)+(t[n+2]<<16);a[s]=o,s+=4}}else if(g){const t=re.colormap(this.colormap,this.colormapInvert);let e=g[0],r=g[0];for(let i=0;i<s;i++)e=Math.min(e,g[i]),r=Math.max(r,g[i]);r===e&&(e-=1);for(let n=0;n<s;n++){let s=(g[n]-e)/(r-e);s=4*Math.round(Math.max(Math.min(255,255*s)));const o=t[s]+(t[s+1]<<8)+(t[s+2]<<16),l=i[n],h=4*(i[n+1]-1)+3;for(let t=4*l+3;t<=h;t+=4)a[t]=o}}else if(f.includes("fixed"))if(0===c){const t=this.rgba255[0]+(this.rgba255[1]<<8)+(this.rgba255[2]<<16);let e=3;for(let i=0;i<n;i++)a[e]=t,e+=4}else for(let r=0;r<s;r++){const t=m(this.rgba255[0],this.rgba255[1],this.rgba255[2]),e=i[r],s=4*(i[r+1]-1)+3;for(let i=4*e+3;i<=s;i+=4)a[i]=t}else if(f.includes("local"))for(let r=0;r<s;r++){const t=i[r];let s=3*t;const n=3*(i[r+1]-1),o=c*Math.random();let l=u(e[s],e[s+1],e[s+2],e[s+4],e[s+5],e[s+6],o),h=4*t+3;for(;s<n;)a[h]=l,h+=4,s+=3,l=u(e[s-3],e[s-2],e[s-1],e[s+3],e[s+4],e[s+5],o);a[h]=a[h-4]}else for(let r=0;r<s;r++){const t=i[r],s=i[r+1]-1,n=3*t,o=3*s,l=u(e[n],e[n+1],e[n+2],e[o],e[o+1],e[o+2],c*Math.random()),h=4*s+3;for(let e=4*t+3;e<=h;e+=4)a[e]=l}if(this.fiberOcclusion>0){let t=function(t,e){return e*(255&t)+(e*(t>>8&255)<<8)+(e*(t>>16&255)<<16)};this.createFiberDensityMap();for(let e=0;e<s;e++){const s=i[e],r=4*s+3,n=4*(i[e+1]-1)+3;let o=s;const l=Math.min(this.fiberOcclusion,.99);for(let e=r;e<=n;e+=4){let i=this.fiberDensity[o++];if(i<=0)continue;i/=(1/l-2)*(1-i)+1;const s=1-Math.min(i,.9);let r=a[e];r=t(r,s),a[e]=r}}}const v=this.fiberLength,x=Math.pow(2,32)-1,w=[];let b=-1;for(let r=0;r<s;r++)if(!(p[r]<0||this.fiberLengths[r]<v||(b++,b%this.fiberDecimationStride!=0))){for(let t=i[r];t<i[r+1];t++)w.push(t);w.push(x)}this.fiberSides>2&&this.fiberRadius>0?this.linesToCylinders(t,o,w):(this.indexCount=w.length,t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,Uint32Array.from(a),t.STATIC_DRAW),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,Uint32Array.from(w),t.STATIC_DRAW))}indexNearestXYZmm(t,e,i){const s=this.pts,r=this.pts.length/3;let n=0,o=1/0,a=0;for(let l=0;l<r;l++){const r=Math.pow(s[n]-t,2)+Math.pow(s[n+1]-e,2)+Math.pow(s[n+2]-i,2);r<o&&(o=r,a=l),n+=3}return o=Math.sqrt(o),[a,o]}unloadMesh(t){if(t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.bindVertexArray(null),t.deleteBuffer(this.vertexBuffer),t.deleteBuffer(this.indexBuffer),t.deleteVertexArray(this.vao),t.deleteVertexArray(this.vaoFiber),this.offsetPt0=null,this.tris=null,this.pts=null,this.layers&&this.layers.length>0)for(let e=0;e<this.layers.length;e++)this.layers[e].values=null;if(this.dpg&&this.dpg.length>0)for(let e=0;e<this.dpg.length;e++)this.dpg[e].vals=null;if(this.dps&&this.dps.length>0)for(let e=0;e<this.dps.length;e++)this.dps[e].vals=null}scalars2RGBA(t,e,i,s){void 0===s&&(s=!1);const r=i.length;if(4*r<t.length)return U.error(`colormap2RGBA incorrectly specified ${r}*4 != ${t.length}`),t;const n=Math.round(255*e.opacity);let o=e.cal_min,a=e.cal_max,l=re.colormap(e.colormap,this.colormapInvert),h=1;if(s){if(!e.useNegativeCmap)return t;h=-1,l=re.colormap(e.colormapNegative,e.colormapInvert),o=e.cal_min,a=e.cal_max,isFinite(e.cal_minNeg)&&isFinite(e.cal_minNeg)&&(o=-e.cal_minNeg,a=-e.cal_maxNeg)}let c=o;e.isTransparentBelowCalMin||(c=Number.NEGATIVE_INFINITY);const d=2===e.colormapType;0!==e.colormapType&&(o=Math.min(o,0));const m=255/(a-o);for(let u=0;u<r;u++){let s=i[u]*h;if(isNaN(s))continue;let r=n;if(s<c){if(!(s>0&&d))continue;r=Math.round(255*e.opacity*Math.pow(s/c,2))}if(s=(s-o)*m,s<0&&e.isTransparentBelowCalMin)continue;s=4*Math.min(255,Math.max(0,Math.round(s)));const a=4*u;t[a+0]=l[s+0],t[a+1]=l[s+1],t[a+2]=l[s+2],t[a+3]=r}return t}blendColormap(t,e,i,s,r,n,o){void 0===o&&(o=!1);const a=this.pts.length/3,l=Math.min(i.opacity,1);function h(t,e,i){return t*(1-i)+e*i}function c(t,e){return Math.min(t+e,255)}const d=o?-1:1,m=a*Math.min(Math.max(i.frame4D,0),i.nFrame4D-1);let u=s;i.isTransparentBelowCalMin||(u=Number.NEGATIVE_INFINITY),0!==i.colormapType&&(s=Math.min(s,0));const f=255/(r-s);let g=new Array(a).fill(!1);if(0!==i.outlineBorder){const t=new Uint8Array(a).fill(0);for(let e=0;e<a;e++){d*i.values[e+m]>=u&&(t[e]=1)}g=ne.getClusterBoundaryU8(t,this.tris);for(let e=0;e<a;e++){d*i.values[e+m]<u&&(g[e]=!1)}}const A=new Float32Array(256).fill(l);if(u>s&&2===i.colormapType){let t=Math.round((u-s)*f);t=Math.max(t,1);for(let e=1;e<t;e++)A[e]=l*Math.pow(e/t,2);A[0]=0,u=s+Number.EPSILON}for(let p=0;p<a;p++){const r=d*i.values[p+m];if(r<u)continue;let o=Math.round((r-s)*f);if(o<0&&i.isTransparentBelowCalMin)continue;o=Math.max(0,o),o=Math.min(255,o);let a=A[o];o*=4;let l=28*p+24;if(7!==this.f32PerVertex&&(l=20*p+16),i.isAdditiveBlend){const t=4*p;e[t+0]=c(e[t+0],n[o+0]),e[t+1]=c(e[t+1],n[o+1]),e[t+2]=c(e[t+2],n[o+2]),e[t+3]=c(e[t+3],255)}else{if(g[p]&&(a=i.outlineBorder,i.outlineBorder<0)){t[l+0]=0,t[l+1]=0,t[l+2]=0;continue}t[l+0]=h(t[l+0],n[o+0],a),t[l+1]=h(t[l+1],n[o+1],a),t[l+2]=h(t[l+2],n[o+2],a)}}}updateMesh(t){if(this.offsetPt0)return void this.updateFibers(t);if(this.hasConnectome)return;if(!this.pts||!this.tris||!this.rgba255)return void U.warn("underspecified mesh");function e(t,e,i){return t*(1-i)+e*i}const i=this.generatePosNormClr(this.pts,this.tris,this.rgba255),s=this.pts.length/3,r=new Uint8Array(i.buffer);let n=0;const o=new Uint8Array(4*s);let a=this.tris;if(this.layers&&this.layers.length>0)for(let l=0;l<this.layers.length;l++){const t=this.layers[l],i=t.opacity;if(i<=0||t.cal_min>t.cal_max)continue;if(void 0===t.outlineBorder&&(t.outlineBorder=0),void 0===t.isAdditiveBlend&&(t.isAdditiveBlend=!1),t.colormapLabel&&t.colormapLabel.R&&!t.colormapLabel.lut&&(t.colormapLabel=re.makeLabelLut(t.colormapLabel)),t.colormapLabel&&t.colormapLabel.lut){const i=t.colormapLabel;let n=0;t.colormapLabel.min&&(n=t.colormapLabel.min);let o=i.lut;const l=Math.round(255*t.opacity);o[3]>0&&(o[3]=l);for(let t=7;t<o.length;t+=4)o[t]=l;const h=Math.floor(o.length/4);if(t.atlasValues&&h>0&&h===t.atlasValues.length&&t.colormap){const e=t.atlasValues;let i=!1,r=!0;for(let t=0;t<h;t++)isNaN(e[t])?i=!0:r=!1;if(r)return void U.debug("invisible mesh: all atlasValues are NaN.");if(i){U.debug("some vertices have NaN atlasValues (mesh will be decimated).");const i=new Array(s).fill(!1);for(let a=0;a<s;a++){const s=Math.round(t.values[a])-n;isNaN(e[s])&&(i[a]=!0)}const r=new Array(a.length).fill(!1);for(let t=0;t<a.length;t++)i[a[t]]&&(r[t]=!0);const o=this.tris;let l=0;for(let t=0;t<o.length;t+=3)r[t]||r[t+1]||r[t+2]||l++;0===l&&U.debug("invisible mesh: all triangles of a vertex with a NaN atlasValue."),a=new Uint32Array(3*l);let h=0;for(let t=0;t<o.length;t+=3)r[t]||r[t+1]||r[t+2]||(a[h++]=o[t],a[h++]=o[t+1],a[h++]=o[t+2])}o.fill(0),o=this.scalars2RGBA(o,t,e),t.useNegativeCmap&&(o=this.scalars2RGBA(o,t,e,!0))}else t.atlasValues&&U.warn(`Expected ${h} atlasValues but got ${t.atlasValues.length} for mesh layer`);if(t.showLegend&&h===t.colormapLabel.labels.length){t.labels=[];for(let e=0;e<h;e++){const i=Array.from(o.slice(4*e,4*e+4)).map((t=>t/255)),r=t.colormapLabel.labels[e],n=[0,0,0];let a=0;for(let o=0;o<s;o++)if(t.values[o]===e){const t=3*o;n[0]+=this.pts[t],n[1]+=this.pts[t+1],n[2]+=this.pts[t+2],a++}if(a>0&&(n[0]/=a,n[1]/=a,n[2]/=a),0===i[3]||!r||r.startsWith("_"))continue;i[3]=1;const l=new ce(r,{textColor:i,bulletScale:1,bulletColor:i,lineWidth:0,lineColor:i,textScale:1,textAlignment:"left",lineTerminator:"none"},n);t.labels.push(l),U.debug("label for mesh layer:",l)}}else delete t.labels;const c=s*Math.min(Math.max(t.frame4D,0),t.nFrame4D-1),d=new Uint8Array(4*s);let m=0;for(let e=0;e<s;e++){const i=t.values[e+c]-n,s=4*Math.min(Math.max(i,0),h-1);d[m+0]=o[s+0],d[m+1]=o[s+1],d[m+2]=o[s+2],d[m+3]=o[s+3],m+=4}let u=new Array(s).fill(!1);0!==t.outlineBorder&&(u=ne.getClusterBoundary(d,this.tris)),m=0;for(let a=0;a<s;a++){let i=28*a+24;7!==this.f32PerVertex&&(i=20*a+16);let s=d[m+3]/255;u[a]&&(s=t.outlineBorder,t.outlineBorder<0)?(r[i+0]=0,r[i+1]=0,r[i+2]=0,m+=4):(r[i+0]=e(r[i+0],d[m+0],s),r[i+1]=e(r[i+1],d[m+1],s),r[i+2]=e(r[i+2],d[m+2],s),m+=4)}continue}if(t.values instanceof Uint8Array){const n=new Uint8Array(t.values.buffer);let o=new Array(s).fill(!0);0!==t.outlineBorder&&(o=ne.getClusterBoundary(n,this.tris));let a=0;for(let s=0;s<t.values.length;s++){let l=28*s+24;7!==this.f32PerVertex&&(l=20*s+16);let h=i;o[s]&&(h=t.outlineBorder,t.outlineBorder<0)?(r[l+0]=0,r[l+1]=0,r[l+2]=0,a+=4):(r[l+0]=e(r[l+0],n[a+0],h),r[l+1]=e(r[l+1],n[a+1],h),r[l+2]=e(r[l+2],n[a+2],h),a+=4)}continue}t.useNegativeCmap&&(t.cal_min=Math.max(Number.EPSILON,t.cal_min),t.cal_max=Math.max(t.cal_min+1e-6,t.cal_max)),void 0===t.isTransparentBelowCalMin&&(t.isTransparentBelowCalMin=!0);const h=re.colormap(t.colormap,t.colormapInvert);if(t.isAdditiveBlend&&n++,this.blendColormap(r,o,t,t.cal_min,t.cal_max,h),t.useNegativeCmap){const e=re.colormap(t.colormapNegative,t.colormapInvert);let i=t.cal_min,s=t.cal_max;isFinite(t.cal_minNeg)&&isFinite(t.cal_minNeg)&&(i=-t.cal_minNeg,s=-t.cal_maxNeg),this.blendColormap(r,o,t,i,s,e,!0)}}if(n>0)for(let l=0;l<s;l++){let t=function(t,e){return Math.min(t*e*(1/255),255)},i=28*l+24;7!==this.f32PerVertex&&(i=20*l+16);const s=4*l,a=Math.min(n,o[s+3]/255);a<=0||(r[i+0]=t(r[i+0],o[s+0]),r[i+1]=t(r[i+1],o[s+1]),r[i+2]=t(r[i+2],o[s+2]),r[i+0]=e(r[i+0],o[s+0],a),r[i+1]=e(r[i+1],o[s+1],a),r[i+2]=e(r[i+2],o[s+2],a))}t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,Uint32Array.from(a),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),this.indexCount=a.length,this.vertexCount=this.pts.length}reverseFaces(t){if(this.offsetPt0)return;if(this.hasConnectome)return;const e=this.tris||[];for(let i=0;i<e.length;i+=3){const t=e[i];e[i]=e[i+1],e[i+1]=t}this.updateMesh(t)}hierarchicalOrder(){const t=this.tris.length/3,e=Math.log(t/20)/Math.log(4);if(t!==20*Math.pow(4,e))return NaN;if(this.pts.length/3!==10*Math.pow(4,e)+2)return NaN;for(let i=0;i<15;i+=3)if(0!==this.tris[i])return NaN;for(let i=15;i<24;i+=3)if(3!==this.tris[i])return NaN;for(let i=24;i<30;i+=3)if(4!==this.tris[i])return NaN;return e}decimateFaces(t,e){let i=this.tris;for(let s=t-1;s>=e;s--){const t=10*Math.pow(4,s+1)+2,e=10*Math.pow(4,s)+2,r=i.length/3,n=20*Math.pow(4,s);console.log(`order ${s+1} -> ${s} vertices ${t} -> ${e} faces ${r} -> ${n}`);const o=Array.from({length:t},((t,e)=>e+1));for(let s=0;s<r;s++){const t=i[3*s],e=i[3*s+1],r=i[3*s+2];o[t-1]=Math.min(o[t-1],e,r)}const a=new Uint32Array(3*n);for(let s=0;s<n;s++)a[3*s]=o[i[3*s]-1],a[3*s+1]=o[i[3*s+1]-1],a[3*s+2]=o[i[3*s+2]-1];i=a}this.tris=new Uint32Array(i)}decimateHierarchicalMesh(t,e){void 0===e&&(e=4);const i=this.hierarchicalOrder();if(isNaN(i))return U.warn("Unable to decimate mesh: it does not have a hierarchical structure"),!1;if(e>=i)return U.warn(`Unable to decimate mesh: input order (${i}) must be larger than downsampled order (${e})`),!1;const s=this.pts.length/3,r=10*Math.pow(4,e)+2;if(this.pts=new Float32Array(this.pts.slice(0,3*r)),this.decimateFaces(i,e),this.layers&&this.layers.length>0)for(let n=0;n<this.layers.length;n++){const t=this.layers[n];t.values instanceof Float32Array||t.values.length!==s?t.values=new Float32Array(t.values.slice(0,r)):U.warn("decimation logic needs to be updated")}return this.updateMesh(t),!0}async setLayerProperty(t,e,i,s){const r=this.layers[t];if(r&&e in r){if("colormapLabel"===e)if("object"==typeof i)r[e]=re.makeLabelLut(i);else{if("string"==typeof i){const t=await re.makeLabelLutFromUrl(i);return r[e]=t,void this.updateMesh(s)}U.error("colormapLabel requires a string or object")}else r[e]=i;this.updateMesh(s)}else U.warn("mesh does not have property ",e," for layer ",r)}setProperty(t,e,i){t in this?(this[t]=e,this.updateMesh(i)):console.warn("Mesh does not have property:",t,this)}generatePosNormClr(t,e,i){(t.length<3||i.length<4)&&(U.error("Catastrophic failure generatePosNormClr()"),U.debug("this",this),U.debug("pts",t),U.debug("rgba",i));const s=ne.generateNormals(t,e),r=t.length/3,n=r===i.length/4,o=this.f32PerVertex,a=new Float32Array(r*o),l=new Uint8Array(a.buffer);let h=0,c=0,d=0,m=4*(o-1);for(let u=0;u<r;u++)a[d+0]=t[h+0],a[d+1]=t[h+1],a[d+2]=t[h+2],7!==o?(l[m-4]=127*s[h+0],l[m-3]=127*s[h+1],l[m-2]=127*s[h+2]):(a[d+3]=s[h+0],a[d+4]=s[h+1],a[d+5]=s[h+2]),l[m]=i[c+0],l[m+1]=i[c+1],l[m+2]=i[c+2],l[m+3]=i[c+3],n&&(c+=4),h+=3,d+=o,m+=4*o;return a}static async readMesh(e,i,s,r,n,o){void 0===r&&(r=1),void 0===n&&(n=new Uint8Array([255,255,255,255])),void 0===o&&(o=!0);let a,l=new Uint32Array([]),h=new Float32Array([]),c="";const d=/(?:\.([^.]+))?$/;let m=d.exec(i)[1];if(m=m.toUpperCase(),"GZ"===m&&(m=d.exec(i.slice(0,-3))[1],m=m.toUpperCase()),"JCON"===m&&U.error("you should never see this message: load using nvconnectome not nvmesh"),"JSON"===m&&U.error("you should never see this message: load using nvconnectome not nvmesh"),n[3]=Math.max(1,n[3]),"TCK"===m||"TRK"===m||"TT"===m||"TRX"===m||"TRACT"===m){if(a="TCK"===m?he.readTCK(e):"TRACT"===m?he.readTRACT(e):"TT"===m?await he.readTT(e):"TRX"===m?await he.readTRX(e):await he.readTRK(e),void 0===a){a={pts:new Float32Array([0,0,0,0,0,0]),offsetPt0:new Uint32Array([0])},U.error("Creating empty tracts")}return n[3]=0,new t(a.pts,a.offsetPt0,i,n,r,o,s,"inferno",a.dpg||null,a.dps||null,a.dpv||null)}if("GII"===m)a=await he.readGII(e);else if("MZ3"===m)a=await he.readMZ3(e),"positions"in a||U.warn("MZ3 does not have positions (statistical overlay?)");else if("ASC"===m)a=he.readASC(e);else if("DFS"===m)a=he.readDFS(e);else if("BYU"===m||"G"===m)a=he.readGEO(e);else if("GEO"===m)a=he.readGEO(e,!0);else if("ICO"===m||"TRI"===m)a=he.readICO(e);else if("OFF"===m)a=he.readOFF(e);else if("NV"===m)a=he.readNV(e);else if("OBJ"===m)a=await he.readOBJ(e);else if("PLY"===m)a=he.readPLY(e);else if("WRL"===m)a=he.readWRL(e);else if("X3D"===m)a=he.readX3D(e);else if("FIB"===m||"VTK"===m){if(a=he.readVTK(e),"offsetPt0"in a)return n[3]=0,new t(a.pts,a.offsetPt0,i,n,r,o,s,"inferno")}else a="SRF"===m?await he.readSRF(e):"STL"===m?he.readSTL(e):he.readFreeSurfer(e);if(a.anatomicalStructurePrimary&&(c=a.anatomicalStructurePrimary),a instanceof Float32Array)throw new Error("fatal: unknown mesh type loaded");if(!("positions"in a))throw new Error("positions not loaded");if(!a.indices)throw new Error("indices not loaded");if(h=a.positions,l=a.indices,"rgba255"in a&&a.rgba255.length>0&&(n=a.rgba255),"colors"in a&&a.colors&&a.colors.length===h.length){const t=h.length/3;n=new Uint8Array(4*t);let e=0,i=0;for(let s=0;s<t;s++)n[i++]=255*a.colors[e],n[i++]=255*a.colors[e+1],n[i++]=255*a.colors[e+2],n[i++]=255,e+=3}const u=h.length/3;if(l.length/3<1||u<3)throw new Error("Mesh should have at least one triangle and three vertices");n[3]=Math.max(1,n[3]);const f=new t(h,l,i,n,r,o,s,null,null,null,null,!0,c);if("scalars"in a&&a.scalars.length>0){const t=await he.readLayer(i,e,f,r,"gray");void 0===t?U.warn("readLayer() failed to convert scalars"):(f.layers.push(t),f.updateMesh(s))}return f}static async loadLayer(t,e){let i,s=(new Uint8Array).buffer;if(void 0!==t.base64)s=function(t){const e=window.atob(t),i=e.length,s=new Uint8Array(i);for(let r=0;r<i;r++)s[r]=e.charCodeAt(r);return s.buffer}(t.base64);else{if(!t.url)throw new Error("layer: missing url");const e=await fetch(t.url,{headers:t.headers});if(!e.ok)throw Error(e.statusText);s=await e.arrayBuffer()}let r=[];if(t.name&&""!==t.name)i=t.name;else{if(!t.url)throw new Error("layer: missing url");try{r=new URL(t.url).pathname.split("/")}catch(m){r=t.url.split("/")}finally{i=r.slice(-1)[0]}}i.indexOf("?")>-1&&(i=i.slice(0,i.indexOf("?")));let n=.5;"opacity"in t&&(n=t.opacity);let o="warm";"colormap"in t&&(o=t.colormap);let a="winter";"colormapNegative"in t&&(a=t.colormapNegative);let l=!1;"useNegativeCmap"in t&&(l=t.useNegativeCmap);let h=null;"cal_min"in t&&(h=t.cal_min);let c=null;"cal_max"in t&&(c=t.cal_max);const d=await he.readLayer(i,s,e,n,o,a,l,h,c);d&&e.layers.push(d)}static async loadFromUrl(e){let i,{url:s="",headers:r={},gl:n,name:o="",opacity:a=1,rgba255:l=[255,255,255,255],visible:h=!0,layers:c=[],buffer:d=new ArrayBuffer(0)}=void 0===e?{}:e,m=s.split("/");if(""===o){try{m=new URL(s).pathname.split("/")}catch(f){m=s.split("/")}o=m.slice(-1)[0],o.indexOf("?")>-1&&(o=o.slice(0,o.indexOf("?")))}if(""===s)throw Error("url must not be empty");if(!n)throw Error("gl context is null");if(d.byteLength>0)i=d;else{const t=await fetch(s,{headers:r});if(!t.ok)throw Error(t.statusText);i=await t.arrayBuffer()}const u=await this.readMesh(i,o,n,a,new Uint8Array(l),h);if(!c||c.length<1)return u;for(let g=0;g<c.length;g++)await t.loadLayer(c[g],u);return u.updateMesh(n),u}static async readFileAsync(t){return new Promise(((e,i)=>{const s=new FileReader;s.onload=()=>{e(s.result)},s.onerror=i,s.readAsArrayBuffer(t)}))}static async loadFromFile(e){let{file:i,gl:s,name:r="",opacity:n=1,rgba255:o=[255,255,255,255],visible:a=!0,layers:l=[]}=void 0===e?{}:e;if(!i)throw new Error("file must be set");if(!s)throw new Error("rendering context must be set");const h=await t.readFileAsync(i),c=await t.readMesh(h,r,s,n,new Uint8Array(o),a);if(!l||l.length<1)return c;for(let d=0;d<l.length;d++)await t.loadLayer(l[d],c);return c.updateMesh(s),c}async loadFromBase64(e){let{base64:i,gl:s,name:r="",opacity:n=1,rgba255:o=[255,255,255,255],visible:a=!0,layers:l=[]}=void 0===e?{}:e;if(!i)throw new Error("base64 must bet set");if(!s)throw new Error("rendering context must be set");const h=function(t){const e=window.atob(t),i=e.length,s=new Uint8Array(i);for(let r=0;r<i;r++)s[r]=e.charCodeAt(r);return s.buffer}(i),c=await t.readMesh(h,r,s,n,new Uint8Array(o),a);if(!l||l.length<1)return c;for(let d=0;d<l.length;d++)await t.loadLayer(l[d],c);return c.updateMesh(s),c}},We="data:image/png;base64,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",Ke={atlas:{type:"msdf",distanceRange:2,size:59.65625,width:512,height:256,yOrigin:"bottom"},metrics:{emSize:1,lineHeight:1.171875,ascender:.927734375,descender:-.244140625,underlineY:-.09765625,underlineThickness:.048828125},glyphs:[{unicode:32,advance:.24755859375},{unicode:33,advance:.25732421875,planeBounds:{left:.056159633438645884,bottom:-.02437761405677056,right:.20702396031135412,top:.7299440203067705},atlasBounds:{left:488.5,bottom:145.5,right:497.5,top:190.5}},{unicode:34,advance:.31982421875,planeBounds:{left:.049409125974004715,bottom:.48691155587022,right:.2840869677759953,top:.77187750662978},atlasBounds:{left:486.5,bottom:213.5,right:500.5,top:230.5}},{unicode:35,advance:.61572265625,planeBounds:{left:.037219103997511785,bottom:-.02169206718177056,right:.6239137085024882,top:.7326295671817705},atlasBounds:{left:66.5,bottom:51.5,right:101.5,top:96.5}},{unicode:36,advance:.5615234375,planeBounds:{left:.02956531458715296,bottom:-.12381369908983761,right:.5324464041628472,top:.8484230740898377},atlasBounds:{left:109.5,bottom:197.5,right:139.5,top:255.5}},{unicode:37,advance:.732421875,planeBounds:{left:.026481776289942378,bottom:-.030073418674698794,right:.7137525987100576,top:.7410109186746989},atlasBounds:{left:88.5,bottom:144.5,right:129.5,top:190.5}},{unicode:38,advance:.62158203125,planeBounds:{left:.03225572125458355,bottom:-.030073418674698794,right:.6357130287454166,top:.7410109186746989},atlasBounds:{left:130.5,bottom:144.5,right:166.5,top:190.5}},{unicode:39,advance:.17431640625,planeBounds:{left:.028244602049502358,bottom:.49895501673814824,right:.14558352295049765,top:.7671582645118518},atlasBounds:{left:498.5,bottom:62.5,right:505.5,top:78.5}},{unicode:40,advance:.341796875,planeBounds:{left:.042983329377291775,bottom:-.250029542422407,right:.34471198312270823,top:.8227834486724072},atlasBounds:{left:.5,bottom:191.5,right:18.5,top:255.5}},{unicode:41,advance:.34765625,planeBounds:{left:-.003159248747708225,bottom:-.250029542422407,right:.29856940499770823,top:.8227834486724072},atlasBounds:{left:19.5,bottom:191.5,right:37.5,top:255.5}},{unicode:42,advance:.4306640625,planeBounds:{left:-.011208599684062338,bottom:.27785390031593765,right:.44138438093406235,top:.7304468809340623},atlasBounds:{left:449.5,bottom:23.5,right:476.5,top:50.5}},{unicode:43,advance:.56689453125,planeBounds:{left:.01353503347629649,bottom:.053493525733368255,right:.5499415290237036,top:.6066627242666317},atlasBounds:{left:361.5,bottom:17.5,right:393.5,top:50.5}},{unicode:44,advance:.1962890625,planeBounds:{left:-.009919475797210583,bottom:-.15981695975478,right:.1744702570472106,top:.12514899100478},atlasBounds:{left:498.5,bottom:79.5,right:509.5,top:96.5}},{unicode:45,advance:.27587890625,planeBounds:{left:-.00527594412977999,bottom:.24333249267450235,right:.27969000662978,top:.36067141357549765},atlasBounds:{left:52.5,bottom:7.5,right:69.5,top:14.5}},{unicode:46,advance:.26318359375,planeBounds:{left:.051032680313645884,bottom:-.027092319686354116,right:.20189700718635412,top:.12377200718635412},atlasBounds:{left:501.5,bottom:221.5,right:510.5,top:230.5}},{unicode:47,advance:.412109375,planeBounds:{left:-.013733006073205867,bottom:-.08573505127848349,right:.4053345685732059,top:.7356373950284835},atlasBounds:{left:252.5,bottom:206.5,right:277.5,top:255.5}},{unicode:48,advance:.5615234375,planeBounds:{left:.037458384830081196,bottom:-.030073418674698794,right:.5235767714199189,top:.7410109186746989},atlasBounds:{left:167.5,bottom:144.5,right:196.5,top:190.5}},{unicode:49,advance:.5615234375,planeBounds:{left:.06023674350936354,bottom:-.01998308280677056,right:.37872810024063647,top:.7343385515567705},atlasBounds:{left:488.5,bottom:97.5,right:507.5,top:142.5}},{unicode:50,advance:.5615234375,planeBounds:{left:.025334353719224725,bottom:-.01680925468177056,right:.5449781462807752,top:.7375123796817705},atlasBounds:{left:278.5,bottom:51.5,right:309.5,top:96.5}},{unicode:51,advance:.5615234375,planeBounds:{left:.028181041080081196,bottom:-.030073418674698794,right:.5142994276699189,top:.7410109186746989},atlasBounds:{left:197.5,bottom:144.5,right:226.5,top:190.5}},{unicode:52,advance:.5615234375,planeBounds:{left:.005886103858368255,bottom:-.02169206718177056,right:.5590553023916317,top:.7326295671817705},atlasBounds:{left:310.5,bottom:51.5,right:343.5,top:96.5}},{unicode:53,advance:.5615234375,planeBounds:{left:.055524791080081196,bottom:-.02657487968177056,right:.5416431776699189,top:.7277467546817705},atlasBounds:{left:344.5,bottom:51.5,right:373.5,top:96.5}},{unicode:54,advance:.5615234375,planeBounds:{left:.046003306705081196,bottom:-.034712090549698794,right:.5321216932949189,top:.7363722467996989},atlasBounds:{left:227.5,bottom:144.5,right:256.5,top:190.5}},{unicode:55,advance:.5615234375,planeBounds:{left:.018010134969224725,bottom:-.02169206718177056,right:.5376539275307752,top:.7326295671817705},atlasBounds:{left:374.5,bottom:51.5,right:405.5,top:96.5}},{unicode:56,advance:.5615234375,planeBounds:{left:.037702525455081196,bottom:-.030073418674698794,right:.5238209120449189,top:.7410109186746989},atlasBounds:{left:257.5,bottom:144.5,right:286.5,top:190.5}},{unicode:57,advance:.5615234375,planeBounds:{left:.029401744205081196,bottom:-.025434746799698794,right:.5155201307949189,top:.7456495905496989},atlasBounds:{left:287.5,bottom:144.5,right:316.5,top:190.5}},{unicode:58,advance:.2421875,planeBounds:{left:.046394008438645884,bottom:-.029431286627488215,right:.19725833531135412,top:.5572633178774882},atlasBounds:{left:439.5,bottom:61.5,right:448.5,top:96.5}},{unicode:59,advance:.21142578125,planeBounds:{left:.001066852327789419,bottom:-.16459733294591408,right:.1854565851722106,top:.556198895445914},atlasBounds:{left:406.5,bottom:53.5,right:417.5,top:96.5}},{unicode:60,advance:.50830078125,planeBounds:{left:.016948142433865897,bottom:.0726146348300812,right:.4527784200661341,top:.5587330214199189},atlasBounds:{left:394.5,bottom:21.5,right:420.5,top:50.5}},{unicode:61,advance:.548828125,planeBounds:{left:.051535540940937666,bottom:.17620354038436353,right:.5041285215590624,top:.49469489711563647},atlasBounds:{left:477.5,bottom:31.5,right:504.5,top:50.5}},{unicode:62,advance:.5224609375,planeBounds:{left:.047629290940937666,bottom:.0731029160800812,right:.5002222715590624,top:.5592213026699189},atlasBounds:{left:421.5,bottom:21.5,right:448.5,top:50.5}},{unicode:63,advance:.47216796875,planeBounds:{left:.016704001808865897,bottom:-.027876153049698794,right:.4525342794411341,top:.7432081842996989},atlasBounds:{left:317.5,bottom:144.5,right:343.5,top:190.5}},{unicode:64,advance:.89794921875,planeBounds:{left:.034064457306783605,bottom:-.23896750384690937,right:.8721996065996072,top:.7165065663469093},atlasBounds:{left:155.5,bottom:198.5,right:205.5,top:255.5}},{unicode:65,advance:.65234375,planeBounds:{left:-.008838044092129387,bottom:-.02169206718177056,right:.6616700753421295,top:.7326295671817705},atlasBounds:{left:237.5,bottom:51.5,right:277.5,top:96.5}},{unicode:66,advance:.62255859375,planeBounds:{left:.06464099434422473,bottom:-.02169206718177056,right:.5842847869057752,top:.7326295671817705},atlasBounds:{left:205.5,bottom:51.5,right:236.5,top:96.5}},{unicode:67,advance:.65087890625,planeBounds:{left:.038439807122511785,bottom:-.030073418674698794,right:.6251344116274882,top:.7410109186746989},atlasBounds:{left:344.5,bottom:144.5,right:379.5,top:190.5}},{unicode:68,advance:.65576171875,planeBounds:{left:.06301501010836826,bottom:-.02169206718177056,right:.6161842086416317,top:.7326295671817705},atlasBounds:{left:162.5,bottom:51.5,right:195.5,top:96.5}},{unicode:69,advance:.568359375,planeBounds:{left:.0652904160800812,bottom:-.02169206718177056,right:.5514088026699189,top:.7326295671817705},atlasBounds:{left:132.5,bottom:51.5,right:161.5,top:96.5}},{unicode:70,advance:.552734375,planeBounds:{left:.059675181705081196,bottom:-.02169206718177056,right:.5457935682949189,top:.7326295671817705},atlasBounds:{left:102.5,bottom:51.5,right:131.5,top:96.5}},{unicode:71,advance:.68115234375,planeBounds:{left:.040148791497511785,bottom:-.030073418674698794,right:.6268433960024882,top:.7410109186746989},atlasBounds:{left:380.5,bottom:144.5,right:415.5,top:190.5}},{unicode:72,advance:.712890625,planeBounds:{left:.062365588372511785,bottom:-.02169206718177056,right:.6490601928774882,top:.7326295671817705},atlasBounds:{left:30.5,bottom:51.5,right:65.5,top:96.5}},{unicode:73,advance:.27197265625,planeBounds:{left:.06917965680657412,bottom:-.02169206718177056,right:.20328128069342588,top:.7326295671817705},atlasBounds:{left:196.5,bottom:51.5,right:204.5,top:96.5}},{unicode:74,advance:.5517578125,planeBounds:{left:.007184947330081194,bottom:-.02657487968177056,right:.4933033339199188,top:.7277467546817705},atlasBounds:{left:.5,bottom:51.5,right:29.5,top:96.5}},{unicode:75,advance:.626953125,planeBounds:{left:.061633166497511785,bottom:-.02169206718177056,right:.6483277710024882,top:.7326295671817705},atlasBounds:{left:452.5,bottom:97.5,right:487.5,top:142.5}},{unicode:76,advance:.5380859375,planeBounds:{left:.06341786132300943,bottom:-.02169206718177056,right:.5327735449269906,top:.7326295671817705},atlasBounds:{left:423.5,bottom:97.5,right:451.5,top:142.5}},{unicode:77,advance:.873046875,planeBounds:{left:.05911847969322944,bottom:-.02169206718177056,right:.8134401140567705,top:.7326295671817705},atlasBounds:{left:377.5,bottom:97.5,right:422.5,top:142.5}},{unicode:78,advance:.712890625,planeBounds:{left:.062365588372511785,bottom:-.02169206718177056,right:.6490601928774882,top:.7326295671817705},atlasBounds:{left:341.5,bottom:97.5,right:376.5,top:142.5}},{unicode:79,advance:.6875,planeBounds:{left:.033395854136655315,bottom:-.030073418674698794,right:.6536158646133446,top:.7410109186746989},atlasBounds:{left:416.5,bottom:144.5,right:453.5,top:190.5}},{unicode:80,advance:.630859375,planeBounds:{left:.061550166358368255,bottom:-.02169206718177056,right:.6147193648916317,top:.7326295671817705},atlasBounds:{left:273.5,bottom:97.5,right:306.5,top:142.5}},{unicode:81,advance:.6875,planeBounds:{left:.030466166636655315,bottom:-.14391866037519643,right:.6506861771133446,top:.7445045978751964},atlasBounds:{left:214.5,bottom:202.5,right:251.5,top:255.5}},{unicode:82,advance:.61572265625,planeBounds:{left:.06350329135836826,bottom:-.02169206718177056,right:.6166724898916317,top:.7326295671817705},atlasBounds:{left:186.5,bottom:97.5,right:219.5,top:142.5}},{unicode:83,advance:.59326171875,planeBounds:{left:.020778681983368255,bottom:-.030073418674698794,right:.5739478805166317,top:.7410109186746989},atlasBounds:{left:454.5,bottom:144.5,right:487.5,top:190.5}},{unicode:84,advance:.5966796875,planeBounds:{left:.005480822747511787,bottom:-.02169206718177056,right:.5921754272524882,top:.7326295671817705},atlasBounds:{left:112.5,bottom:97.5,right:147.5,top:142.5}},{unicode:85,advance:.6484375,planeBounds:{left:.049098994483368255,bottom:-.02657487968177056,right:.6022681930166317,top:.7277467546817705},atlasBounds:{left:78.5,bottom:97.5,right:111.5,top:142.5}},{unicode:86,advance:.63623046875,planeBounds:{left:-.008269192599201152,bottom:-.02169206718177056,right:.6454762238492011,top:.7326295671817705},atlasBounds:{left:38.5,bottom:97.5,right:77.5,top:142.5}},{unicode:87,advance:.88720703125,planeBounds:{left:.011923628617731797,bottom:-.02169206718177056,right:.8835841838822683,top:.7326295671817705},atlasBounds:{left:220.5,bottom:97.5,right:272.5,top:142.5}},{unicode:88,advance:.626953125,planeBounds:{left:.004098979136655316,bottom:-.02169206718177056,right:.6243189896133446,top:.7326295671817705},atlasBounds:{left:.5,bottom:97.5,right:37.5,top:142.5}},{unicode:89,advance:.6005859375,planeBounds:{left:-.010793598988344685,bottom:-.02169206718177056,right:.6094264114883446,top:.7326295671817705},atlasBounds:{left:148.5,bottom:97.5,right:185.5,top:142.5}},{unicode:90,advance:.5986328125,planeBounds:{left:.024196650733368255,bottom:-.02169206718177056,right:.5773658492666317,top:.7326295671817705},atlasBounds:{left:307.5,bottom:97.5,right:340.5,top:142.5}},{unicode:91,advance:.26513671875,planeBounds:{left:.05437250871693295,bottom:-.17280296457569408,right:.27228764753306706,top:.8329592145756942},atlasBounds:{left:59.5,bottom:195.5,right:72.5,top:255.5}},{unicode:92,advance:.41015625,planeBounds:{left:.0014037126767941326,bottom:-.08573505127848349,right:.4204712873232059,top:.7356373950284835},atlasBounds:{left:278.5,bottom:206.5,right:303.5,top:255.5}},{unicode:93,advance:.26513671875,planeBounds:{left:-.020659233400995285,bottom:-.17280296457569408,right:.2140186084009953,top:.8329592145756942},atlasBounds:{left:94.5,bottom:195.5,right:108.5,top:255.5}},{unicode:94,advance:.41796875,planeBounds:{left:.006855376669722368,bottom:.33229482979472236,right:.40916024833027764,top:.7345997014552776},atlasBounds:{left:486.5,bottom:231.5,right:510.5,top:255.5}},{unicode:95,advance:.451171875,planeBounds:{left:-.017473255794918804,bottom:-.09553469482549765,right:.4686451307949188,top:.021804226075497646},atlasBounds:{left:70.5,bottom:7.5,right:99.5,top:14.5}},{unicode:96,advance:.30908203125,planeBounds:{left:.00391839948107648,bottom:.5860277898277895,right:.2553589442689235,top:.7704175226722105},atlasBounds:{left:36.5,bottom:3.5,right:51.5,top:14.5}},{unicode:97,advance:.5439453125,planeBounds:{left:.028181041080081196,bottom:-.029187146002488215,right:.5142994276699189,top:.5575074585024882},atlasBounds:{left:30.5,bottom:15.5,right:59.5,top:50.5}},{unicode:98,advance:.56103515625,planeBounds:{left:.048932994205081196,bottom:-.032187684160555265,right:.5350513807949189,top:.7724220591605554},atlasBounds:{left:304.5,bottom:207.5,right:333.5,top:255.5}},{unicode:99,advance:.5234375,planeBounds:{left:.024518931705081196,bottom:-.029187146002488215,right:.5106373182949189,top:.5575074585024882},atlasBounds:{left:.5,bottom:15.5,right:29.5,top:50.5}},{unicode:100,advance:.56396484375,planeBounds:{left:.026227916080081196,bottom:-.032187684160555265,right:.5123463026699189,top:.7724220591605554},atlasBounds:{left:334.5,bottom:207.5,right:363.5,top:255.5}},{unicode:101,advance:.52978515625,planeBounds:{left:.026472056705081196,bottom:-.029187146002488215,right:.5125904432949189,top:.5575074585024882},atlasBounds:{left:468.5,bottom:61.5,right:497.5,top:96.5}},{unicode:102,advance:.34716796875,planeBounds:{left:.004575110905578838,bottom:-.022177918535555265,right:.3733545765944212,top:.7824318247855554},atlasBounds:{left:364.5,bottom:207.5,right:386.5,top:255.5}},{unicode:103,advance:.56103515625,planeBounds:{left:.026960337955081196,bottom:-.22888445766762702,right:.5130787245449189,top:.558962582667627},atlasBounds:{left:28.5,bottom:143.5,right:57.5,top:190.5}},{unicode:104,advance:.55078125,planeBounds:{left:.049826556565937666,bottom:-.01892352016762703,right:.5024195371840624,top:.768923520167627},atlasBounds:{left:.5,bottom:143.5,right:27.5,top:190.5}},{unicode:105,advance:.24267578125,planeBounds:{left:.046882289688645884,bottom:-.01680925468177056,right:.19774661656135412,top:.7375123796817705},atlasBounds:{left:498.5,bottom:145.5,right:507.5,top:190.5}},{unicode:106,advance:.23876953125,planeBounds:{left:-.048979545900995285,bottom:-.2324562772148376,right:.1856982959009953,top:.7397804959648377},atlasBounds:{left:140.5,bottom:197.5,right:154.5,top:255.5}},{unicode:107,advance:.5068359375,planeBounds:{left:.044294322330081196,bottom:-.01892352016762703,right:.5304127089199189,top:.768923520167627},atlasBounds:{left:58.5,bottom:143.5,right:87.5,top:190.5}},{unicode:108,advance:.24267578125,planeBounds:{left:.05428707868157412,bottom:-.01892352016762703,right:.18838870256842588,top:.768923520167627},atlasBounds:{left:477.5,bottom:208.5,right:485.5,top:255.5}},{unicode:109,advance:.87646484375,planeBounds:{left:.04430890170737297,bottom:-.024304333502488215,right:.832155942042627,top:.5623902710024882},atlasBounds:{left:116.5,bottom:15.5,right:163.5,top:50.5}},{unicode:110,advance:.5517578125,planeBounds:{left:.049826556565937666,bottom:-.024304333502488215,right:.5024195371840624,top:.5623902710024882},atlasBounds:{left:60.5,bottom:15.5,right:87.5,top:50.5}},{unicode:111,advance:.5703125,planeBounds:{left:.025090213094224725,bottom:-.029187146002488215,right:.5447340056557752,top:.5575074585024882},atlasBounds:{left:193.5,bottom:15.5,right:224.5,top:50.5}},{unicode:112,advance:.56103515625,planeBounds:{left:.048444712955081196,bottom:-.22644305141762702,right:.5345630995449189,top:.561403988917627},atlasBounds:{left:447.5,bottom:208.5,right:476.5,top:255.5}},{unicode:113,advance:.568359375,planeBounds:{left:.025983775455081196,bottom:-.22644305141762702,right:.5121021620449189,top:.561403988917627},atlasBounds:{left:417.5,bottom:208.5,right:446.5,top:255.5}},{unicode:114,advance:.33837890625,planeBounds:{left:.045180595002291775,bottom:-.024304333502488215,right:.34690924874770823,top:.5623902710024882},atlasBounds:{left:449.5,bottom:61.5,right:467.5,top:96.5}},{unicode:115,advance:.515625,planeBounds:{left:.021669814448009427,bottom:-.029187146002488215,right:.4910254980519906,top:.5575074585024882},atlasBounds:{left:164.5,bottom:15.5,right:192.5,top:50.5}},{unicode:116,advance:.32666015625,planeBounds:{left:-.019433670483564695,bottom:-.02877457520298586,right:.3158203892335647,top:.675258950202986},atlasBounds:{left:418.5,bottom:54.5,right:438.5,top:96.5}},{unicode:117,advance:.55126953125,planeBounds:{left:.048117572190937666,bottom:-.034069958502488215,right:.5007105528090624,top:.5526246460024882},atlasBounds:{left:88.5,bottom:15.5,right:115.5,top:50.5}},{unicode:118,advance:.484375,planeBounds:{left:-.002092396419918806,bottom:-.02080579450955998,right:.4840259901699188,top:.5491261070095601},atlasBounds:{left:331.5,bottom:16.5,right:360.5,top:50.5}},{unicode:119,advance:.75146484375,planeBounds:{left:-.002649098431770561,bottom:-.02080579450955998,right:.7516725359317705,top:.5491261070095601},atlasBounds:{left:225.5,bottom:16.5,right:270.5,top:50.5}},{unicode:120,advance:.49560546875,planeBounds:{left:-.0046143729128470395,bottom:-.02080579450955998,right:.4982667166628471,top:.5491261070095601},atlasBounds:{left:300.5,bottom:16.5,right:330.5,top:50.5}},{unicode:121,advance:.47314453125,planeBounds:{left:-.007219349544918806,bottom:-.23645281704262702,right:.4788990370449188,top:.551394223292627},atlasBounds:{left:387.5,bottom:208.5,right:416.5,top:255.5}},{unicode:122,advance:.49560546875,planeBounds:{left:.018007705073009427,bottom:-.02080579450955998,right:.4873633886769906,top:.5491261070095601},atlasBounds:{left:271.5,bottom:16.5,right:299.5,top:50.5}},{unicode:123,advance:.33837890625,planeBounds:{left:.011572188891435306,bottom:-.20234398020069408,right:.3468262486085647,top:.8034181989506942},atlasBounds:{left:73.5,bottom:195.5,right:93.5,top:255.5}},{unicode:124,advance:.24365234375,planeBounds:{left:.06315671142450235,bottom:-.15466084787519643,right:.18049563232549765,top:.7337624103751964},atlasBounds:{left:206.5,bottom:202.5,right:213.5,top:255.5}},{unicode:125,advance:.33837890625,planeBounds:{left:-.010156326733564695,bottom:-.20234398020069408,right:.3250977329835647,top:.8034181989506942},atlasBounds:{left:38.5,bottom:195.5,right:58.5,top:255.5}},{unicode:126,advance:.68017578125,planeBounds:{left:.046984728997511785,bottom:.1766063915990047,right:.6336793335024882,top:.4112842334009953},atlasBounds:{left:.5,bottom:.5,right:35.5,top:14.5}}],kerning:[]},ze={name:"untitled connectome",nodeColormap:"warm",nodeColormapNegative:"winter",nodeMinColor:0,nodeMaxColor:4,nodeScale:3,edgeColormap:"warm",edgeColormapNegative:"winter",edgeMin:2,edgeMax:6,edgeScale:1,legendLineThickness:0,showLegend:!0},Qe=class t extends Ge{constructor(t,e){super(new Float32Array([]),new Uint32Array([]),e.name,new Uint8Array([]),1,!0,t,e),M(this,"gl"),M(this,"nodesChanged"),this.gl=t,this.type="connectome",this.nodes&&this.updateLabels(),this.nodesChanged=new EventTarget}static convertLegacyConnectome(t){const e={nodes:[],edges:[],...ze};for(const s in t)if(s in ze){const i=s;e[i]=t[i]}const i=t.nodes;for(let s=0;s<i.names.length;s++)e.nodes.push({name:i.names[s],x:i.X[s],y:i.Y[s],z:i.Z[s],colorValue:i.Color[s],sizeValue:i.Size[s]});for(let s=0;s<i.names.length-1;s++)for(let r=s+1;r<i.names.length;r++){const n=t.edges[s*i.names.length+r];e.edges.push({first:s,second:r,colorValue:n})}return e}static convertFreeSurferConnectome(t,e){void 0===e&&(e="warm");let i=!0;if("data_type"in t?"fs_pointset"!==t.data_type&&(i=!1):i=!1,"points"in t||(i=!1),!i)throw Error("not a valid FreeSurfer json pointset");const s=t.points.map((t=>({name:Array.isArray(t.comments)&&t.comments.length>0&&"text"in t.comments[0]?t.comments[0].text:"",x:t.coordinates.x,y:t.coordinates.y,z:t.coordinates.z,colorValue:1,sizeValue:1,metadata:t.comments})));return{...ze,nodeColormap:e,edgeColormap:e,nodes:s,edges:[]}}updateLabels(){const t=this.nodes;if(t&&t.length>0){const e=t.reduce(((t,e)=>t.sizeValue>e.sizeValue?t:e)).sizeValue;let i,s;if(void 0!==this.nodeMinColor&&isFinite(this.nodeMinColor))i=this.nodeMinColor;else{i=t[0].colorValue;for(let e=1;e<t.length;e++)t[e].colorValue<i&&(i=t[e].colorValue)}if(void 0!==this.nodeMaxColor&&isFinite(this.nodeMaxColor))s=this.nodeMaxColor;else{s=t[0].colorValue;for(let e=1;e<t.length;e++)t[e].colorValue>s&&(s=t[e].colorValue)}const r=re.colormap(this.nodeColormap,this.colormapInvert),n=re.colormap(this.nodeColormapNegative,this.colormapInvert),o="nodeColormapNegative"in this;let a=this.legendLineThickness?this.legendLineThickness:0;!1===this.showLegend&&(a=0);for(let l=0;l<t.length;l++){let h=t[l].colorValue,c=!1;if(o&&h<0&&(c=!0,h=-h),i<s){if(h<i){U.warn("color value lower than min");continue}h=(h-i)/(s-i)}else h=1;h=4*Math.round(Math.max(Math.min(255,255*h)));let d=[r[h],r[h+1],r[h+2],255];c&&(d=[n[h],n[h+1],n[h+2],255]),d=d.map((t=>t/255)),U.debug("adding label for ",t[l]),t[l].label=new ce(t[l].name,{textColor:d,bulletScale:t[l].sizeValue/e,bulletColor:d,lineWidth:a,lineColor:d,textScale:1,textAlignment:"left",lineTerminator:"none"},[t[l].x,t[l].y,t[l].z]),U.debug("label for node:",t[l].label)}}}addConnectomeNode(t){if(U.debug("adding node",t),!this.nodes)throw new Error("nodes not defined");this.nodes.push(t),this.updateLabels(),this.nodesChanged.dispatchEvent(new CustomEvent("nodeAdded",{detail:{node:t}}))}deleteConnectomeNode(t){const e=this.nodes.indexOf(t),i=this.edges;i&&(this.edges=i.filter((t=>t.first!==e&&t.second!==e))),this.nodes=this.nodes.filter((e=>e!==t)),this.updateLabels(),this.updateConnectome(this.gl),this.nodesChanged.dispatchEvent(new CustomEvent("nodeDeleted",{detail:{node:t}}))}updateConnectomeNodeByIndex(t,e){this.nodes[t]=e,this.updateLabels(),this.updateConnectome(this.gl),this.nodesChanged.dispatchEvent(new CustomEvent("nodeChanged",{detail:{node:e}}))}updateConnectomeNodeByPoint(t,e){const i=this.nodes;if(!i)throw new Error("Node to update does not exist");const s=i.find((e=>ae.arraysAreEqual([e.x,e.y,e.z],t)));if(!s)throw new Error(`Node with point ${t} to update does not exist`);const r=i.findIndex((t=>t===s));this.updateConnectomeNodeByIndex(r,e)}addConnectomeEdge(t,e,i){const s=this.edges;let r=s.find((i=>(i.first===t||i.second===t)&&i.first+i.second===t+e));return r||(r={first:t,second:e,colorValue:i},s.push(r),this.updateConnectome(this.gl),r)}deleteConnectomeEdge(t,e){const i=this.edges,s=i.find((i=>(i.first===t||i.first===e)&&i.first+i.second===t+e));if(!s)throw new Error(`edge between ${t} and ${e} not found`);return this.edges=i.filter((t=>t!==s)),this.updateConnectome(this.gl),s}findClosestConnectomeNode(t,e){const i=this.nodes;if(!i||0===i.length)return null;const s=i.map(((e,i)=>({node:e,distance:Math.sqrt(Math.pow(e.x-t[0],2)+Math.pow(e.y-t[1],2)+Math.pow(e.z-t[2],2)),index:i}))).filter((t=>t.distance<e)).sort(((t,e)=>t.distance-e.distance));return s.length>0?s[0].node:null}updateConnectome(t){const e=[],i=[],s=[];let n=re.colormap(this.nodeColormap,this.colormapInvert),o=re.colormap(this.nodeColormapNegative,this.colormapInvert),a="nodeColormapNegative"in this;void 0===this.nodeMinColor&&(this.nodeMinColor=NaN),void 0===this.nodeMaxColor&&(this.nodeMaxColor=NaN),void 0===this.edgeMin&&(this.edgeMin=NaN),void 0===this.edgeMax&&(this.edgeMax=NaN);let l=this.nodeMinColor,h=this.nodeMaxColor;if(!isFinite(l)||!isFinite(l)){const t=this.nodes;l=t[0].colorValue,h=t[0].colorValue;for(let e=0;e<t.length;e++)l=Math.min(l,t[e].colorValue),h=Math.max(h,t[e].colorValue)}const c=this.nodes,d=c.length;for(let p=0;p<d;p++){const t=c[p].sizeValue*this.nodeScale;if(t<=0)continue;let d=c[p].colorValue,m=!1;if(a&&d<0&&(m=!0,d=-d),l<h){if(d<l)continue;d=(d-l)/(h-l)}else d=1;d=4*Math.round(Math.max(Math.min(255,255*d)));let u=[n[d],n[d+1],n[d+2],255];m&&(u=[o[d],o[d+1],o[d+2],255]);const f=r.fA(c[p].x,c[p].y,c[p].z);B.makeColoredSphere(i,e,s,t,f,u)}n=re.colormap(this.edgeColormap,this.colormapInvert),o=re.colormap(this.edgeColormapNegative,this.colormapInvert),a="edgeColormapNegative"in this;const m=this.edges;if(void 0!==m&&m.length>0){if(l=this.edgeMin,h=this.edgeMax,!isFinite(l)||!isFinite(l)){l=m[0].colorValue,h=m[0].colorValue;for(let t=0;t<m.length;t++)l=Math.min(l,m[t].colorValue),h=Math.max(h,m[t].colorValue)}for(const t of m){let d=t.colorValue;const m=a&&d<0;m&&(d=-d);const u=d*this.edgeScale;if(u<=0)continue;if(l<h){if(d<l)continue;d=(d-l)/(h-l)}else d=1;d=4*Math.round(Math.max(Math.min(255,255*d)));let f=[n[d],n[d+1],n[d+2],255];m&&(f=[o[d],o[d+1],o[d+2],255]);const g=r.fA(c[t.first].x,c[t.first].y,c[t.first].z),A=r.fA(c[t.second].x,c[t.second].y,c[t.second].z);B.makeColoredCylinder(i,e,s,g,A,u,f)}}const u=new Float32Array(i),f=new Uint32Array(e),g=ne.getExtents(u);this.furthestVertexFromOrigin=g.mxDx,this.extentsMin=g.extentsMin,this.extentsMax=g.extentsMax;const A=this.generatePosNormClr(u,f,new Uint8Array(s));t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,Uint32Array.from(f),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,Float32Array.from(A),t.STATIC_DRAW),this.indexCount=e.length}updateMesh(t){this.updateConnectome(t),this.updateLabels()}json(){const t={};for(const e in this)(e in ze||"nodes"===e||"edges"===e)&&(t[e]=this[e]);return t}static async loadConnectomeFromUrl(e,i){const s=await fetch(i),r=await s.json();return new t(e,r)}};function Xe(t,e,i){if(!(t.dimsRAS&&t.matRAS&&t.pixDimsRAS&&t.vox2mm))throw new Error("Cannot create NiivueObject3D: Missing required RAS properties or vox2mm access on NVImage.");const s=t.dimsRAS,n=t.matRAS,o=t.pixDimsRAS,a=-.5,l=-.5,h=-.5,c=s[1]-1+.5,d=s[2]-1+.5,m=s[3]-1+.5,u=t.vox2mm,f=u.call(t,[a,l,h],n),g=u.call(t,[a,d,h],n),A=u.call(t,[a,l,m],n),p=u.call(t,[a,d,m],n),v=u.call(t,[c,l,h],n),x=u.call(t,[c,d,h],n),w=u.call(t,[c,l,m],n),b=u.call(t,[c,d,m],n),y=[...A,0,0,1,...w,1,0,1,...b,1,1,1,...p,0,1,1,...f,0,0,0,...g,0,1,0,...x,1,1,0,...v,1,0,0],C=i.createBuffer();if(!C)throw new Error("Failed to create GL index buffer");i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,C);const M=[0,3,2,2,1,0,4,7,6,6,5,4,5,6,2,2,3,5,4,0,1,1,7,4,7,1,2,2,6,7,4,5,3,3,0,4];i.bufferData(i.ELEMENT_ARRAY_BUFFER,new Uint16Array(M),i.STATIC_DRAW);const D=i.createBuffer();if(!D)throw new Error("Failed to create GL vertex buffer");i.bindBuffer(i.ARRAY_BUFFER,D),i.bufferData(i.ARRAY_BUFFER,new Float32Array(y),i.STATIC_DRAW);const I=i.createVertexArray();if(!I)throw new Error("Failed to create GL VAO");i.bindVertexArray(I),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,C),i.bindBuffer(i.ARRAY_BUFFER,D);i.enableVertexAttribArray(0),i.vertexAttribPointer(0,3,i.FLOAT,!1,24,0),i.enableVertexAttribArray(1),i.vertexAttribPointer(1,3,i.FLOAT,!1,24,12),i.bindVertexArray(null);const T=new B(e,D,i.TRIANGLES,M.length,C,I),S=function(t,e){void 0===e&&(e=!0);const i=Math.round(t.length/3),s=r.fA(0,0,0),n=r.vt(),o=r.vt();let a=0,l=1;e&&(l=2);for(let h=0;h<l;h++){a=0;for(let l=0;l<i;l++){const e=r.fA(t[3*l],t[3*l+1],t[3*l+2]);0===l&&(r.C(n,e),r.C(o,e)),r.jk(n,n,e),r.T9(o,o,e),r.Re(e,e,s);const i=r.Il(e);a=Math.max(a,i)}if(h+1>=l)break;let e=!0;for(let t=0;t<3;++t)n[t]>s[t]&&(e=!1),o[t]<s[t]&&(e=!1);if(e)break;r.Cc(s,n,o,.5),U.debug("origin moved inside volume: ",s)}return{min:[n[0],n[1],n[2]],max:[o[0],o[1],o[2]],furthestVertexFromOrigin:a,origin:s}}([...A,...w,...b,...p,...f,...g,...x,...v]);return T.extentsMin=S.min.slice(),T.extentsMax=S.max.slice(),T.furthestVertexFromOrigin=S.furthestVertexFromOrigin,T.originNegate=r.o8(S.origin),r.ze(T.originNegate,T.originNegate),T.fieldOfViewDeObliqueMM=[s[1]*o[1],s[2]*o[2],s[3]*o[3]],T}function He(t,e){const i=new Uint8Array(t.buffer),s=new Int8Array(i.buffer);let r=0;const n=new Uint8Array(e);let o=0;for(;r<i.length;){const t=s[r];if(r++,t<0){const e=s[r];r++;for(let i=0;i<1-t;i++)n[o]=e,o++}else for(let e=0;e<t+1;e++)n[o]=s[r],r++,o++}return n}function qe(t,e,i,s){const{dimX:r,dimY:n,dimZ:o}=s;let a;if(0===e){a=new Float32Array(r*n);const e=t*r*n;for(let t=0;t<r*n;t++)a[t]=i[e+t]}else if(1===e){a=new Float32Array(r*o);for(let e=0;e<o;e++)for(let s=0;s<r;s++){const o=s+t*r+e*r*n;a[s+e*r]=i[o]}}else{if(2!==e)throw new Error("Invalid slice type");a=new Float32Array(n*o);for(let e=0;e<o;e++)for(let s=0;s<n;s++){const o=t+s*r+e*r*n;a[s+e*n]=i[o]}}return a}function Ze(t,e,i,s,r){const{dimX:n,dimY:o,dimZ:a}=s;let l;if(0===e){l=new Float32Array(n*o);const e=t*n*o;for(let t=0;t<n*o;t++)l[t]=i[e+t]/r}else if(1===e){l=new Float32Array(n*a);for(let e=0;e<a;e++)for(let s=0;s<n;s++){const a=s+t*n+e*n*o;l[s+e*n]=i[a]/r}}else{if(2!==e)throw new Error("Invalid slice type");l=new Float32Array(o*a);for(let e=0;e<a;e++)for(let s=0;s<o;s++){const a=t+s*n+e*n*o;l[s+e*o]=i[a]/r}}return l}function je(t,e,i,s,r,n,o){const{dimX:a,dimY:l,dimZ:h}=r;if(0===i){const i=e*a*l;for(let e=0;e<t.length;e++)t[e]>=n&&(s[i+e]=o)}else if(1===i)for(let c=0;c<h;c++)for(let i=0;i<a;i++){const r=i+e*a+c*a*l;t[i+c*a]>=n&&(s[r]=o)}else{if(2!==i)throw new Error("Invalid slice type");for(let i=0;i<h;i++)for(let r=0;r<l;r++){const h=e+r*a+i*a*l;t[r+i*l]>=n&&(s[h]=o)}}}function Je(t,e,i){if(e<3||i<3)return;const s=new Float32Array(t.length);for(let r=0;r<i;r++)for(let i=0;i<e;i++){const n=i+r*e;s[n]=0===i||i===e-1?t[n]:.25*(t[n-1]+2*t[n]+t[n+1])}for(let r=0;r<i;r++)for(let n=0;n<e;n++){const o=n+r*e;t[o]=0===r||r===i-1?s[o]:.25*(s[o-e]+2*s[o]+s[o+e])}}function _e(t,e,i,s){const r=Math.abs(i-t),n=Math.abs(i-e),o=Math.exp(-r*r/(2*s*s)),a=o+Math.exp(-n*n/(2*s*s));return a<1e-6?.5:o/a}function $e(t,e,i,s,r,n){const o=(i-s)/(r-s),a=1-o;for(let l=0;l<t.length;l++)n[l]=t[l]*a+e[l]*o}function ti(t,e,i,s,r,n,o,a,l,h){const c=(i-s)/(r-s),d=1-c;for(let m=0;m<t.length;m++)if(t[m]>0||e[m]>0){const i=_e(a[m],l[m],h[m],o.intensitySigma),s=o.intensityWeight,r=s*i+(1-s)*d,c=1-r;n[m]=t[m]*r+e[m]*c}else n[m]=t[m]*d+e[m]*c}var ei="#version 300 es\n#line 4\nlayout(location=0) in vec3 pos;\nlayout(location=1) in vec3 texCoords;\nuniform mat4 mvpMtx;\nout vec3 vColor;\nvoid main(void) {\n\tgl_Position = mvpMtx * vec4(pos, 1.0);\n\tvColor = texCoords;\n}",ii="\n\tvec4 drawColor(float scalar, float drawOpacity) {\n\t\tfloat nlayer = float(textureSize(colormap, 0).y);\n\t\tfloat layer = (nlayer - 0.5) / nlayer;\n\t\tvec4 dcolor = texture(colormap, vec2((scalar * 255.0)/256.0 + 0.5/256.0, layer)).rgba;\n\t\tdcolor.a *= drawOpacity;\n\t\treturn dcolor;\n}",si="vec3 GetBackPosition(vec3 startPositionTex) {\n\tvec3 startPosition = startPositionTex * volScale;\n\tvec3 invR = 1.0 / rayDir;\n\tvec3 tbot = invR * (vec3(0.0)-startPosition);\n\tvec3 ttop = invR * (volScale-startPosition);\n\tvec3 tmax = max(ttop, tbot);\n\tvec2 t = min(tmax.xx, tmax.yz);\n\tvec3 endPosition = startPosition + (rayDir * min(t.x, t.y));\n\t//convert world position back to texture position:\n\tendPosition = endPosition / volScale;\n\treturn endPosition;\n}\n\nvec4 applyClip (vec3 dir, inout vec4 samplePos, inout float len, inout bool isClip) {\n\tfloat cdot = dot(dir,clipPlane.xyz);\n\tisClip = false;\n\tif  ((clipPlane.a > 1.0) || (cdot == 0.0)) return samplePos;\n\tbool frontface = (cdot > 0.0);\n\tfloat dis = (-clipPlane.a - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;\n\tfloat thick = clipThick;\n\tif (thick <= 0.0) thick = 2.0;\n\tfloat  disBackFace = (-(clipPlane.a-thick) - dot(clipPlane.xyz, samplePos.xyz-0.5)) / cdot;\n\tif (((frontface) && (dis >= len)) || ((!frontface) && (dis <= 0.0))) {\n\t\tsamplePos.a = len + 1.0;\n\t\treturn samplePos;\n\t}\n\tif (frontface) {\n\t\tdis = max(0.0, dis);\n\t\tsamplePos = vec4(samplePos.xyz+dir * dis, dis);\n\t\tif (dis > 0.0) isClip = true;\n\t\tlen = min(disBackFace, len);\n\t}\n\tif (!frontface) {\n\t\tlen = min(dis, len);\n\t\tdisBackFace = max(0.0, disBackFace);\n\t\tif (len == dis) isClip = true;\n\t\tsamplePos = vec4(samplePos.xyz+dir * disBackFace, disBackFace);\n\t}\n\treturn samplePos;\n}\n\nvoid clipVolume(inout vec3 startPos, inout vec3 backPos, int dim, float frac, bool isLo) {\n\tvec3 dir = backPos - startPos;\n\tfloat len = length(dir);\n\tdir = normalize(dir);\n\t// Discard if both startPos and backPos are outside the clipping plane\n\tif (isLo && startPos[dim] < frac && backPos[dim] < frac) {\n\t\tdiscard;\n\t}\n\tif (!isLo && startPos[dim] > frac && backPos[dim] > frac) {\n\t\tdiscard;\n\t}\n\tvec4 plane = vec4(0.0, 0.0, 0.0, 0.5 - frac);\n\tplane[dim] = 1.0;\n\tfloat cdot = dot(dir, plane.xyz);\n\tfloat dis = (-plane.w - dot(plane.xyz, startPos - vec3(0.5))) / cdot;\n\t// Adjust startPos or backPos based on the intersection with the plane\n\tbool isFrontFace = (cdot > 0.0);\n\tif (!isLo)\n\t\tisFrontFace = !isFrontFace;\n\tif (dis > 0.0) {\n\t\tif (isFrontFace) {\n\t\t\t\tif (dis <= len) {\n\t\t\t\t\tstartPos = startPos + dir * dis;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (dis < len) {\n\t\t\t\tbackPos = startPos + dir * dis;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid clipVolumeStart (inout vec3 startPos, inout vec3 backPos) {\n\t// vec3 clipLo = vec3(0.1, 0.2, 0.4);\n\t// vec3 clipHi = vec3(0.8, 0.7, 0.7);\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (clipLo[i] > 0.0)\n\t\t\tclipVolume(startPos, backPos, i, clipLo[i], true);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (clipHi[i] < 1.0)\n\t\t\tclipVolume(startPos, backPos, i, clipHi[i], false);\n\t}\n}\n\nfloat frac2ndc(vec3 frac) {\n//https://stackoverflow.com/questions/7777913/how-to-render-depth-linearly-in-modern-opengl-with-gl-fragcoord-z-in-fragment-sh\n\tvec4 pos = vec4(frac.xyz, 1.0); //fraction\n\tvec4 dim = vec4(vec3(textureSize(volume, 0)), 1.0);\n\tpos = pos * dim;\n\tvec4 shim = vec4(-0.5, -0.5, -0.5, 0.0);\n\tpos += shim;\n\tvec4 mm = transpose(matRAS) * pos;\n\tfloat z_ndc = (mvpMtx * vec4(mm.xyz, 1.0)).z;\n\treturn (z_ndc + 1.0) / 2.0;\n}"+ii,ri="void main() {\n\tif (fColor.x > 2.0) {\n\t\tfColor = vec4(1.0, 0.0, 0.0, 0.5);\n\t\treturn;\n\t}\n\tfColor = vec4(0.0,0.0,0.0,0.0);\n\tvec4 clipPlaneColorX = clipPlaneColor;\n\t//if (clipPlaneColor.a < 0.0)\n\t//\tclipPlaneColorX.a = - 1.0;\n\tbool isColorPlaneInVolume = false;\n\tif (clipPlaneColorX.a < 0.0) {\n\t\tisColorPlaneInVolume = true;\n\t\tclipPlaneColorX.a = 0.0;\n\t}\n\t//fColor = vec4(vColor.rgb, 1.0); return;\n\tvec3 start = vColor;\n\tgl_FragDepth = 0.0;\n\tvec3 backPosition = GetBackPosition(start);\n\t// fColor = vec4(backPosition, 1.0); return;\n\tvec3 dir = normalize(backPosition - start);\n\tclipVolumeStart(start, backPosition);\n\tdir = normalize(dir);\n\tfloat len = length(backPosition - start);\n\tfloat lenVox = length((texVox * start) - (texVox * backPosition));\n\tif ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays\n\t\treturn;\n\t}\n\tfloat sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube\n\tfloat stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples\n\tfloat opacityCorrection = stepSize/sliceSize;\n\tvec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);\n\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\tfloat lenNoClip = len;\n\tbool isClip = false;\n\tvec4 clipPos = applyClip(dir, samplePos, len, isClip);\n\t//if ((clipPos.a != samplePos.a) && (len < 3.0)) {\n\t//start: OPTIONAL fast pass: rapid traversal until first hit\n\tfloat stepSizeFast = sliceSize * 1.9;\n\tvec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);\n\twhile (samplePos.a <= len) {\n\t\tfloat val = texture(volume, samplePos.xyz).a;\n\t\tif (val > 0.01)\n\t\t\tbreak;\n\t\tsamplePos += deltaDirFast; //advance ray position\n\t}\n\tfloat drawOpacityA = renderDrawAmbientOcclusionXY.y;\n\tif ((samplePos.a >= len) && (((overlays < 1.0) && (drawOpacityA <= 0.0) ) || (backgroundMasksOverlays > 0)))  {\n\t\tif (isClip)\n\t\t\tfColor += clipPlaneColorX;\n\t\treturn;\n\t}\n\tfColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t//gl_FragDepth = frac2ndc(samplePos.xyz); //crude due to fast pass resolution\n\tsamplePos -= deltaDirFast;\n\tif (samplePos.a < 0.0)\n\t\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\t//end: fast pass\n\tvec4 colAcc = vec4(0.0,0.0,0.0,0.0);\n\tvec4 firstHit = vec4(0.0,0.0,0.0,2.0 * lenNoClip);\n\tconst float earlyTermination = 0.95;\n\tfloat backNearest = len; //assume no hit\n\tfloat ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);\n\tsamplePos += deltaDir * ran; //jitter ray\n",ni="\n\tif (firstHit.a < len) {\n\t\tgl_FragDepth = frac2ndc(firstHit.xyz);\n\t\tvec4 paqdSample = texture(paqd, samplePos.xyz);\n\t\tif (paqdSample.a > 0.0) {\n\t\t\t//colAcc.rgb = paqdSample.rgb;\n\t\t\tfloat a = max(abs(paqdUniforms[2]), abs(paqdUniforms[3]));\n\t\t\tcolAcc.rgb = mix(colAcc.rgb, paqdSample.rgb, 0.5 * paqdSample.a * a);\n\t\t}\n\t\t\n\t}\n\tcolAcc.a = (colAcc.a / earlyTermination) * backOpacity;\n\tfColor = colAcc;\n\t//if (isClip) //CR\n\tif ((isColorPlaneInVolume) && (clipPos.a != samplePos.a) && (abs(firstHit.a - clipPos.a) < deltaDir.a))\n\t\tfColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, abs(clipPlaneColor.a));\n\t\t//fColor.rgb = mix(fColor.rgb, clipPlaneColorX.rgb, clipPlaneColorX.a * 0.65);\n\tfloat renderDrawAmbientOcclusionX = renderDrawAmbientOcclusionXY.x;\n\tfloat drawOpacity = renderDrawAmbientOcclusionXY.y;\n\tif ((overlays < 1.0) && (drawOpacity <= 0.0))\n\t\treturn;\n\t//overlay pass\n\tlen = lenNoClip;\n\tsamplePos = vec4(start.xyz, 0.0); //ray position\n\t//start: OPTIONAL fast pass: rapid traversal until first hit\n\tstepSizeFast = sliceSize * 1.0;\n\tdeltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);\n\twhile (samplePos.a <= len) {\n\t\tfloat val = texture(overlay, samplePos.xyz).a;\n\t\tif (drawOpacity > 0.0)\n\t\t\tval = max(val, texture(drawing, samplePos.xyz).r);\n\t\tif (val > 0.001)\n\t\t\tbreak;\n\t\tsamplePos += deltaDirFast; //advance ray position\n\t}\n\tif (samplePos.a >= len) {\n\t\tif (isClip && (fColor.a == 0.0))\n\t\t\t\tfColor += clipPlaneColorX;\n\t\t\treturn;\n\t}\n\tsamplePos -= deltaDirFast;\n\tif (samplePos.a < 0.0)\n\t\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\t//end: fast pass\n\tfloat overFarthest = len;\n\tcolAcc = vec4(0.0, 0.0, 0.0, 0.0);\n\n\tsamplePos += deltaDir * ran; //jitter ray\n\tvec4 overFirstHit = vec4(0.0,0.0,0.0,2.0 * len);\n\tif (backgroundMasksOverlays > 0)\n\t\tsamplePos = firstHit;\n\tbool firstDraw = true;\n\twhile (samplePos.a <= len) {\n\t\tvec4 colorSample = texture(overlay, samplePos.xyz);\n\t\tif ((colorSample.a < 0.01) && (drawOpacity > 0.0)) {\n\t\t\tfloat val = texture(drawing, samplePos.xyz).r;\n\t\t\tvec4 draw = drawColor(val, drawOpacity);\n\t\t\tif ((draw.a > 0.0) && (firstDraw)) {\n\t\t\t\tfirstDraw = false;\n\t\t\t\tfloat sum = 0.0;\n\t\t\t\tconst float mn = 1.0 / 256.0;\n\t\t\t\tconst float sampleRadius = 1.1;\n\t\t\t\tfloat dx = sliceSize * sampleRadius;\n\t\t\t\tvec3 center = samplePos.xyz;\n\t\t\t\t//six neighbors that share a face\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,+dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,0.0,-dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,0.0), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,0.0), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,0.0), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,0.0), dir)).r, mn);\n\t\t\t\t//float proportion = (sum / mn) / 6.0;\n\t\t\t\t\n\t\t\t\t//12 neighbors that share an edge\n\t\t\t\tdx = sliceSize * sampleRadius * sqrt(2.0) * 0.5;\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,+dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,+dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(+dx,+dx,0.0), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,-dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,-dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(-dx,-dx,0.0), dir)).r, mn);\n\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,+dx,-dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(+dx,0.0,-dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(+dx,-dx,0.0), dir)).r, mn);\n\t\t\t\t\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(0.0,-dx,+dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(-dx,0.0,+dx), dir)).r, mn);\n\t\t\t\tsum += min(texture(drawing, center.xyz + cross(vec3(-dx,+dx,0.0), dir)).r, mn);\n\t\t\t\tfloat proportion = (sum / mn) / 18.0; //proportion of six neighbors is non-zero\n\t\t\t\t\n\t\t\t\t//a high proportion of hits means crevice\n\t\t\t\t//since the AO term adds shadows that darken most voxels, it will result in dark surfaces\n\t\t\t\t//the term brighten adds a little illumination to balance this\n\t\t\t\t// without brighten, only the most extreme ridges will not be darker\n\t\t\t\tconst float brighten = 1.2;\n\t\t\t\tvec3 ao = draw.rgb * (1.0 - proportion) * brighten;\n\t\t\t\tdraw.rgb = mix (draw.rgb, ao , renderDrawAmbientOcclusionX);\n\t\t\t}\n\t\t\tcolorSample = draw;\n\t\t}\n\t\tsamplePos += deltaDir; //advance ray position\n\t\tif (colorSample.a >= 0.01) {\n\t\t\tif (overFirstHit.a > len)\n\t\t\t\toverFirstHit = samplePos;\n\t\t\tcolorSample.a *= renderOverlayBlend;\n\t\t\tcolorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);\n\t\t\tcolorSample.rgb *= colorSample.a;\n\t\t\tcolAcc= (1.0 - colAcc.a) * colorSample + colAcc;\n\t\t\toverFarthest = samplePos.a;\n\t\t\tif ( colAcc.a > earlyTermination )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t//if (samplePos.a >= len) {\n\tif (colAcc.a <= 0.0) {\n\t\tif (isClip && (fColor.a == 0.0))\n\t\t\tfColor += clipPlaneColorX;\n\t\treturn;\n\t}\n\tif (overFirstHit.a < firstHit.a)\n\t\tgl_FragDepth = frac2ndc(overFirstHit.xyz);\n\tfloat overMix = colAcc.a;\n\tfloat overlayDepth = 0.3;\n\tif (fColor.a <= 0.0)\n\t\toverMix = 1.0;\n\telse if (((overFarthest) > backNearest)) {\n\t\tfloat dx = (overFarthest - backNearest)/1.73;\n\t\tdx = fColor.a * pow(dx, overlayDepth);\n\t\toverMix *= 1.0 - dx;\n\t}\n\tfColor.rgb = mix(fColor.rgb, colAcc.rgb, overMix);\n\tfColor.a = max(fColor.a, colAcc.a);\n}",oi="#version 300 es\n#line 215\nprecision highp int;\nprecision highp float;\nuniform vec3 rayDir;\nuniform vec3 texVox;\nuniform int backgroundMasksOverlays;\nuniform vec3 volScale;\nuniform vec4 clipPlane;\nuniform highp sampler3D volume, overlay;\nuniform highp sampler3D paqd;\nuniform vec4 paqdUniforms;\nuniform float overlays;\nuniform float clipThick;\nuniform vec3 clipLo;\nuniform vec3 clipHi;\nuniform float backOpacity;\nuniform mat4 mvpMtx;\nuniform mat4 matRAS;\nuniform vec4 clipPlaneColor;\nuniform float renderOverlayBlend;\nuniform highp sampler3D drawing;\nuniform highp sampler2D colormap;\nuniform vec2 renderDrawAmbientOcclusionXY;\nin vec3 vColor;\nout vec4 fColor;\n"+si+"\n\tvoid main() {\n\tvec3 start = vColor;\n\tgl_FragDepth = 0.0;\n\tvec3 backPosition = GetBackPosition(start);\n\tvec3 dir = normalize(backPosition - start);\n\tclipVolumeStart(start, backPosition);\n\tfloat len = length(backPosition - start);\n\tfloat lenVox = length((texVox * start) - (texVox * backPosition));\n\tif ((lenVox < 0.5) || (len > 3.0)) { //length limit for parallel rays\n\t\tfColor = vec4(0.0,0.0,0.0,0.0);\n\t\treturn;\n\t}\n\tfloat sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube\n\tfloat stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples\n\tfloat opacityCorrection = stepSize/sliceSize;\n\tvec4 deltaDir = vec4(dir.xyz * stepSize, stepSize);\n\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\tvec4 colAcc = vec4(0.0,0.0,0.0,0.0);\n\tvec4 firstHit = vec4(0.0,0.0,0.0,2.0 * len);\n\tconst float earlyTermination = 0.95;\n\tfloat backNearest = len; //assume no hit\n\tfloat dis = len;\n\t//check if axial plane is closest\n\tvec4 aClip = vec4(0.0, 0.0, 1.0, (1.0- clipPlane.z) - 0.5);\n\tfloat adis = (-aClip.a - dot(aClip.xyz, samplePos.xyz-0.5)) / dot(dir,aClip.xyz);\n\tif (adis > 0.0)\n\t\tdis = min(adis, dis);\n\t//check of coronal plane is closest\n\tvec4 cClip = vec4(0.0, 1.0, 0.0, (1.0- clipPlane.y) - 0.5);\n\tfloat cdis = (-cClip.a - dot(cClip.xyz, samplePos.xyz-0.5)) / dot(dir,cClip.xyz);\n\tif (cdis > 0.0)\n\t\tdis = min(cdis, dis);\n\t//check if coronal slice is closest\n\tvec4 sClip = vec4(1.0, 0.0, 0.0, (1.0- clipPlane.x) - 0.5);\n\tfloat sdis = (-sClip.a - dot(sClip.xyz, samplePos.xyz-0.5)) / dot(dir,sClip.xyz);\n\tif (sdis > 0.0)\n\t\tdis = min(sdis, dis);\n\tif ((dis > 0.0) && (dis < len)) {\n\t\tsamplePos = vec4(samplePos.xyz+dir * dis, dis);\n\t\tcolAcc = texture(volume, samplePos.xyz);\n\t\tcolAcc.a = earlyTermination;\n\t\tfirstHit = samplePos;\n\t\tbackNearest = min(backNearest, samplePos.a);\n\t}\n\t//the following are only used by overlays\n\tvec4 clipPlaneColorX = clipPlaneColor;\n\tbool isColorPlaneInVolume = false;\n\tfloat lenNoClip = len;\n\tbool isClip = false;\n\tvec4 clipPos = applyClip(dir, samplePos, len, isClip);\n\tfloat stepSizeFast = sliceSize * 1.9;\n\tvec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);\n\tif (samplePos.a < 0.0)\n\t\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\tfloat ran = fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453);\n\tsamplePos += deltaDir * ran; //jitter ray\n"+ni,ai="#version 300 es\n#line 215\nprecision highp int;\nprecision highp float;\nuniform vec3 rayDir;\nuniform vec3 texVox;\nuniform int backgroundMasksOverlays;\nuniform vec3 volScale;\nuniform vec4 clipPlane;\nuniform highp sampler3D volume, overlay;\nuniform highp sampler3D paqd;\nuniform vec4 paqdUniforms;\nuniform float overlays;\nuniform float clipThick;\nuniform vec3 clipLo;\nuniform vec3 clipHi;\nuniform float backOpacity;\nuniform mat4 mvpMtx;\nuniform mat4 matRAS;\nuniform vec4 clipPlaneColor;\nuniform float renderOverlayBlend;\nuniform highp sampler3D drawing;\nuniform highp sampler2D colormap;\nuniform vec2 renderDrawAmbientOcclusionXY;\nin vec3 vColor;\nout vec4 fColor;\n"+si+ri+"while (samplePos.a <= len) {\n\t\tvec4 colorSample = texture(volume, samplePos.xyz);\n\t\tsamplePos += deltaDir; //advance ray position\n\t\tif (colorSample.a >= 0.01) {\n\t\t\tif (firstHit.a > lenNoClip)\n\t\t\t\tfirstHit = samplePos;\n\t\t\tbackNearest = min(backNearest, samplePos.a);\n\t\t\tcolorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);\n\t\t\tcolorSample.rgb *= colorSample.a;\n\t\t\tcolAcc= (1.0 - colAcc.a) * colorSample + colAcc;\n\t\t\tif ( colAcc.a > earlyTermination )\n\t\t\t\tbreak;\n\t\t}\n\t}\n"+ni,li=192,hi="#version 300 es\n#line 215\nprecision highp int;\nprecision highp float;\nuniform vec3 rayDir;\nuniform vec3 texVox;\nuniform int backgroundMasksOverlays;\nuniform vec3 volScale;\nuniform vec4 clipPlane;\nuniform highp sampler3D volume, overlay;\nuniform highp sampler3D paqd;\nuniform vec4 paqdUniforms;\nuniform float overlays;\nuniform float clipThick;\nuniform vec3 clipLo;\nuniform vec3 clipHi;\nuniform float backOpacity;\nuniform mat4 mvpMtx;\nuniform mat4 normMtx;\nuniform mat4 matRAS;\nuniform vec4 clipPlaneColor;\nuniform float renderOverlayBlend;\nuniform highp sampler3D drawing, gradient;\nuniform highp sampler2D colormap;\nuniform highp sampler2D matCap;\nuniform vec2 renderDrawAmbientOcclusionXY;\nuniform float gradientAmount;\nuniform float silhouettePower;\nuniform float gradientOpacity[192];\nin vec3 vColor;\nout vec4 fColor;\n",ci=hi+si+ri+'\n\tfloat startPos = samplePos.a;\n\tfloat clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane\n\tfloat brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25\n\t//vec4 prevGrad = vec4(0.0);\n\tfloat silhouetteThreshold = 1.0 - silhouettePower;\n\twhile (samplePos.a <= len) {\n\t\tvec4 colorSample = texture(volume, samplePos.xyz);\n\t\tif (colorSample.a >= 0.0) {\n\t\t\tvec4 grad = texture(gradient, samplePos.xyz);\n\t\t\tgrad.rgb = normalize(grad.rgb*2.0 - 1.0);\n\t\t\t//if (grad.a < prevGrad.a)\n\t\t\t//\tgrad.rgb = prevGrad.rgb;\n\t\t\t//prevGrad = grad;\n\t\t\tvec3 n = mat3(normMtx) * grad.rgb;\n\t\t\tn.y = - n.y;\n\t\t\tvec4 mc = vec4(texture(matCap, n.xy * 0.5 + 0.5).rgb, 1.0) * brighten;\n\t\t\tmc = mix(vec4(1.0), mc, gradientAmount);\n\t\t\tif (samplePos.a > clipClose)\n\t\t\t\tcolorSample.rgb *= mc.rgb;\n\t\t\tif (firstHit.a > lenNoClip)\n\t\t\t\tfirstHit = samplePos;\n\t\t\tbackNearest = min(backNearest, samplePos.a);\n\t\t\tcolorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);\n\t\t\tint gradIdx = int(grad.a * 192.0);\n\t\t\tcolorSample.a *= gradientOpacity[gradIdx];\n\t\t\tfloat lightNormDot = dot(grad.rgb, rayDir);\n\t\t\t// n.b. "lightNormDor" is cosTheta, "silhouettePower" is Fresnel effect exponent\n \t\t\tcolorSample.a *= pow(1.0 - abs(lightNormDot), silhouettePower);\n \t\t\tfloat viewAlign = abs(lightNormDot); // 0 = perpendicular, 1 = aligned\n \t\t\t// linearly map silhouettePower (0..1) to a threshold range, e.g., [1.0, 0.0]\n \t\t\t// Cull voxels that are too aligned with the view direction\n \t\t\tif (viewAlign > silhouetteThreshold)\n \t\t\t\tcolorSample.a = 0.0;\n\t\t\tcolorSample.rgb *= colorSample.a;\n\t\t\tcolAcc= (1.0 - colAcc.a) * colorSample + colAcc;\n\t\t\tif ( colAcc.a > earlyTermination )\n\t\t\t\tbreak;\n\t\t}\n\t\tsamplePos += deltaDir; //advance ray position\n\t}\n'+ni,di=hi+si+ri+"\n\tfloat startPos = samplePos.a;\n\tfloat clipClose = clipPos.a + 3.0 * deltaDir.a; //do not apply gradients near clip plane\n\tfloat brighten = 2.0; //modulating makes average intensity darker 0.5 * 0.5 = 0.25\n\t//vec4 prevGrad = vec4(0.0);\n\twhile (samplePos.a <= len) {\n\t\tvec4 colorSample = texture(volume, samplePos.xyz);\n\t\tif (colorSample.a >= 0.0) {\n\t\t\tvec4 grad = texture(gradient, samplePos.xyz);\n\t\t\tcolorSample.rgb = abs(normalize(grad.rgb*2.0 - 1.0));\n\t\t\tif (firstHit.a > lenNoClip)\n\t\t\t\tfirstHit = samplePos;\n\t\t\tbackNearest = min(backNearest, samplePos.a);\n\t\t\tcolorSample.a = 1.0-pow((1.0 - colorSample.a), opacityCorrection);\n\t\t\tcolorSample.rgb *= colorSample.a;\n\t\t\tcolAcc= (1.0 - colAcc.a) * colorSample + colAcc;\n\t\t\tif ( colAcc.a > earlyTermination )\n\t\t\t\tbreak;\n\t\t}\n\t\tsamplePos += deltaDir; //advance ray position\n\t}\n"+ni,mi="#version 300 es\n#line 392\nlayout(location=0) in vec3 pos;\nuniform int axCorSag;\nuniform mat4 mvpMtx;\nuniform mat4 frac2mm;\nuniform float slice;\nout vec3 texPos;\nvoid main(void) {\n\ttexPos = vec3(pos.x, pos.y, slice);\n\tif (axCorSag > 1)\n\t\ttexPos = vec3(slice, pos.x, pos.y);\n\telse if (axCorSag > 0)\n\t\ttexPos = vec3(pos.x, slice, pos.y);\n\tvec4 mm = frac2mm * vec4(texPos, 1.0);\n\tgl_Position = mvpMtx * mm;\n}",ui="#version 300 es\n#line 411\nprecision highp int;\nprecision highp float;\nuniform highp sampler3D volume, overlay;\nuniform highp sampler3D paqd;\nuniform vec4 paqdUniforms;\nuniform int backgroundMasksOverlays;\nuniform float overlayOutlineWidth;\nuniform float overlayAlphaShader;\nuniform int axCorSag;\nuniform float overlays;\nuniform float opacity;\nuniform float drawOpacity;\nuniform float drawRimOpacity;\nuniform bool isAlphaClipDark;\nuniform highp sampler3D drawing;\nuniform highp sampler2D colormap;\nin vec3 texPos;\nout vec4 color;\n"+ii+'\nvec4 blendRGBA(vec4 foreground, vec4 background) {\n  float alphaOut = foreground.a + background.a * (1.0 - foreground.a);\n  vec3 colorOut = (foreground.rgb * foreground.a + background.rgb * background.a * (1.0 - foreground.a)) / alphaOut;\n  return vec4(colorOut, alphaOut);\n}\nfloat paqdEaseAlpha(float alpha) {\n  // t are alpha transitions\n  // <t0 -> y0\n  // t0..t1  -> mix between y0..y1\n  // t1..t2 -> mix between y1..y2\n  // >t2 -> y2\n  float t0 = paqdUniforms[0]; // 0.3;\n  float t1 = 0.5 * (paqdUniforms[0] + paqdUniforms[1]); // 0.4;\n  float t2 = paqdUniforms[1]; // 0.9;\n  float y0 = 0.0;\n  float y1 = abs(paqdUniforms[2]); // 1.0;\n  float y2 = abs(paqdUniforms[3]); //0.25;\n  if (alpha <= t0) {\n    return y0;\n  } else if (alpha <= t1) {\n    return mix(y0, y1, (alpha - t0) / (t1 - t0)); // LERP 0.0 \u2192 1.0\n  } else if (alpha <= t2) {\n    return mix(y1, y2, (alpha - t1) / (t2 - t1)); // LERP 1.0 \u2192 0.2\n  } else {\n    return y2;\n  }\n}\n\nvoid main() {\n\t//color = vec4(1.0, 0.0, 1.0, 1.0);return;\n\tvec4 background = texture(volume, texPos);\n\tcolor = vec4(background.rgb, opacity);\n\tif ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range\n\tvec4 ocolor = vec4(0.0);\n\tfloat overlayAlpha = overlayAlphaShader;\n\tif (overlays > 0.0) {\n\t\tocolor = texture(overlay, texPos);\n\t\t//dFdx for "boxing" issue 435 has aliasing on some implementations (coarse vs fine)\n\t\t//however, this only identifies 50% of the edges due to aliasing effects\n\t\t// http://www.aclockworkberry.com/shader-derivative-functions/\n\t\t// https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b\n\t\t//if ((ocolor.a >= 1.0) && ((dFdx(ocolor.a) != 0.0) || (dFdy(ocolor.a) != 0.0)  ))\n\t\t//\tocolor.rbg = vec3(0.0, 0.0, 0.0);\n\t\tbool isOutlineBelowNotAboveThreshold = true;\n\t\tif (isOutlineBelowNotAboveThreshold) {\n\t\t\tif ((overlayOutlineWidth > 0.0) && (ocolor.a < 1.0)) { //check voxel neighbors for edge\n\t\t\t\tvec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));\n\t\t\t\t//6 voxel neighbors that share a face\n\t\t\t\tvec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);\n\t\t\t\tvec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);\n\t\t\t\tvec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);\n\t\t\t\tvec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);\n\t\t\t\tvec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);\n\t\t\t\tvec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);\n\t\t\t\tfloat a = 0.0;\n\t\t\t\tif (axCorSag != 2) {\n\t\t\t\t\ta = max(a, texture(overlay, vxR).a);\n\t\t\t\t\ta = max(a, texture(overlay, vxL).a);\n\t\t\t\t}\n\t\t\t\tif (axCorSag != 1) {\n\t\t\t\t\ta = max(a, texture(overlay, vxA).a);\n\t\t\t\t\ta = max(a, texture(overlay, vxP).a);\n\t\t\t\t}\n\t\t\t\tif (axCorSag != 0) {\n\t\t\t\t\ta = max(a, texture(overlay, vxS).a);\n\t\t\t\t\ta = max(a, texture(overlay, vxI).a);\n\t\t\t\t}\n\t\t\t\tbool isCheckCorners = true;\n\t\t\t\tif (isCheckCorners) {\n\t\t\t\t\t//12 voxel neighbors that share an edge\n\t\t\t\t\tvec3 vxRA = vec3(texPos.x+vx.x, texPos.y+vx.y, texPos.z);\n\t\t\t\t\tvec3 vxLA = vec3(texPos.x-vx.x, texPos.y+vx.y, texPos.z);\n\t\t\t\t\tvec3 vxRP = vec3(texPos.x+vx.x, texPos.y-vx.y, texPos.z);\n\t\t\t\t\tvec3 vxLP = vec3(texPos.x-vx.x, texPos.y-vx.y, texPos.z);\n\t\t\t\t\tvec3 vxRS = vec3(texPos.x+vx.x, texPos.y, texPos.z+vx.z);\n\t\t\t\t\tvec3 vxLS = vec3(texPos.x-vx.x, texPos.y, texPos.z+vx.z);\n\t\t\t\t\tvec3 vxRI = vec3(texPos.x+vx.x, texPos.y, texPos.z-vx.z);\n\t\t\t\t\tvec3 vxLI = vec3(texPos.x-vx.x, texPos.y, texPos.z-vx.z);\n\t\t\t\t\tvec3 vxAS = vec3(texPos.x, texPos.y+vx.y, texPos.z+vx.z);\n\t\t\t\t\tvec3 vxPS = vec3(texPos.x, texPos.y-vx.y, texPos.z+vx.z);\n\t\t\t\t\tvec3 vxAI = vec3(texPos.x, texPos.y+vx.y, texPos.z-vx.z);\n\t\t\t\t\tvec3 vxPI = vec3(texPos.x, texPos.y-vx.y, texPos.z-vx.z);\n\n\t\t\t\t\tif (axCorSag == 0) { //axial corners\n\t\t\t\t\t\ta = max(a, texture(overlay, vxRA).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxLA).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxRP).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxLP).a);\n\t\t\t\t\t}\n\t\t\t\t\tif (axCorSag == 1) { //coronal corners\n\t\t\t\t\t\ta = max(a, texture(overlay, vxRS).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxLS).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxRI).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxLI).a);\n\t\t\t\t\t}\n\t\t\t\t\tif (axCorSag == 2) { //sagittal corners\n\t\t\t\t\t\ta = max(a, texture(overlay, vxAS).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxPS).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxAI).a);\n\t\t\t\t\t\ta = max(a, texture(overlay, vxPI).a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a >= 1.0) {\n\t\t\t\t\tocolor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\toverlayAlpha = 1.0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif ((overlayOutlineWidth > 0.0) && (ocolor.a >= 1.0)) { //check voxel neighbors for edge\n\t\t\t\tvec3 vx = (overlayOutlineWidth ) / vec3(textureSize(overlay, 0));\n\t\t\t\tvec3 vxR = vec3(texPos.x+vx.x, texPos.y, texPos.z);\n\t\t\t\tvec3 vxL = vec3(texPos.x-vx.x, texPos.y, texPos.z);\n\t\t\t\tvec3 vxA = vec3(texPos.x, texPos.y+vx.y, texPos.z);\n\t\t\t\tvec3 vxP = vec3(texPos.x, texPos.y-vx.y, texPos.z);\n\t\t\t\tvec3 vxS = vec3(texPos.x, texPos.y, texPos.z+vx.z);\n\t\t\t\tvec3 vxI = vec3(texPos.x, texPos.y, texPos.z-vx.z);\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tif (axCorSag != 2) {\n\t\t\t\t\ta = min(a, texture(overlay, vxR).a);\n\t\t\t\t\ta = min(a, texture(overlay, vxL).a);\n\t\t\t\t}\n\t\t\t\tif (axCorSag != 1) {\n\t\t\t\t\ta = min(a, texture(overlay, vxA).a);\n\t\t\t\t\ta = min(a, texture(overlay, vxP).a);\n\t\t\t\t}\n\t\t\t\tif (axCorSag != 0) {\n\t\t\t\t\ta = min(a, texture(overlay, vxS).a);\n\t\t\t\t\ta = min(a, texture(overlay, vxI).a);\n\t\t\t\t}\n\t\t\t\tif (a < 1.0) {\n\t\t\t\t\tocolor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\toverlayAlpha = 1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t} //outline above threshold\n\t}\n\n',fi="#version 300 es\n#line 411\nprecision highp int;\nprecision highp float;\nuniform highp sampler2D volume, overlay;\nuniform int backgroundMasksOverlays;\nuniform float overlayOutlineWidth;\nuniform float overlayAlphaShader;\nuniform int axCorSag;\nuniform float overlays;\nuniform float opacity;\nuniform float drawOpacity;\nuniform bool isAlphaClipDark;\nuniform highp sampler2D drawing;\nuniform highp sampler2D colormap;\nin vec3 texPos;\nout vec4 color;"+ii+"void main() {\n\t//color = vec4(1.0, 0.0, 1.0, 1.0);return;\n\tvec4 background = texture(volume, texPos.xy);\n\tcolor = vec4(background.rgb, opacity);\n\tif ((isAlphaClipDark) && (background.a == 0.0)) color.a = 0.0; //FSLeyes clipping range\n\tvec4 dcolor = drawColor(texture(drawing, texPos.xy).r, drawOpacity);\n\tif (dcolor.a > 0.0) {\n\t\tcolor.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);\n\t\tcolor.a = max(drawOpacity, color.a);\n\t}\n}",gi="\tocolor.a *= overlayAlpha;\n\tfloat drawV = texture(drawing, texPos).r;\n\tvec4 dcolor = drawColor(drawV, drawOpacity);\n\tif (dcolor.a > 0.0) {\n\t\tif (drawRimOpacity >= 0.0) {\n\t\t\tvec3 vx = 1.0 / vec3(textureSize(drawing, 0));\n\t\t\t//6 voxel neighbors that share a face\n\t\t\tvec3 offsetX = dFdx(texPos); // left-right spacing\n\t\t\tvec3 offsetY = dFdy(texPos); // up-down spacing\n\t\t\tfloat L = texture(drawing, texPos - offsetX).r;\n\t\t\tfloat R = texture(drawing, texPos + offsetX).r;\n\t\t\tfloat T = texture(drawing, texPos - offsetY).r;\n\t\t\tfloat B = texture(drawing, texPos + offsetY).r;\n\t\t\tif (L != drawV || R != drawV || T != drawV || B != drawV)\n\t\t\t\tdcolor.a = drawRimOpacity;\n\t\t}\n\t\tcolor.rgb = mix(color.rgb, dcolor.rgb, dcolor.a);\n\t\tcolor.a = max(drawOpacity, color.a);\n\t}\n\tvec4 pcolor = texture(paqd, texPos);\n\tif (pcolor.a > 0.0) {\n\t\tpcolor.a = paqdEaseAlpha(pcolor.a);\n\t\tif (pcolor.a > 0.0) {\n\t\t\tif (paqdUniforms[3] < 0.0)\n\t\t\t\tocolor = blendRGBA(pcolor, ocolor);\n\t\t\telse\n\t\t\t\tocolor = blendRGBA(ocolor, pcolor);\n\t\t}\n\t}\n\tif ((backgroundMasksOverlays > 0) && (background.a == 0.0))\n\t\treturn;\n\tfloat a = color.a + ocolor.a * (1.0 - color.a); // premultiplied alpha\n\tif (a == 0.0) return;\n\tcolor.rgb = mix(color.rgb, ocolor.rgb, ocolor.a / a);\n\tcolor.a = a;\n}",Ai=ui+gi,pi=ui+"\tif (ocolor.a > 0.0) {\n\t\t//https://gamedev.stackexchange.com/questions/102889/is-it-possible-to-convert-vec4-to-int-in-glsl-using-opengl-es\n\t\tuint alpha = uint(ocolor.a * 255.0);\n\t\tvec3 xyzFlip = vec3(float((uint(1) & alpha) > uint(0)), float((uint(2) & alpha) > uint(0)), float((uint(4) & alpha) > uint(0)));\n\t\t//convert from 0 and 1 to -1 and 1\n\t\txyzFlip = (xyzFlip * 2.0) - 1.0;\n\t\t//https://math.stackexchange.com/questions/1905533/find-perpendicular-distance-from-point-to-line-in-3d\n\t\t//v1 principle direction of tensor for this voxel\n\t\tvec3 v1 = ocolor.rgb;\n\t\t//flips encode polarity to convert from 0..1 to -1..1 (27 bits vs 24 bit precision)\n\t\tv1 = normalize( v1 * xyzFlip);\n\t\tvec3 vxl = fract(texPos * vec3(textureSize(volume, 0))) - 0.5;\n\t\t//vxl coordinates now -0.5..+0.5 so 0,0,0 is origin\n\t\tvxl.x = -vxl.x;\n\t\tfloat t = dot(vxl,v1);\n\t\tvec3 P = t * v1;\n\t\tfloat dx = length(P-vxl);\n\t\tocolor.a = 1.0 - smoothstep(0.2,0.25, dx);\n\t\t//if modulation was applied, use that to scale alpha not color:\n\t\tocolor.a *= length(ocolor.rgb);\n\t\tocolor.rgb = normalize(ocolor.rgb);\n\t\t//compute distance one half voxel closer to viewer:\n\t\tfloat pan = 0.5;\n\t\tif (axCorSag == 0)\n\t\t\tvxl.z -= pan;\n\t\tif (axCorSag == 1)\n\t\t\tvxl.y -= pan;\n\t\tif (axCorSag == 2)\n\t\t\tvxl.x += pan;\n\t\tt = dot(vxl,v1);\n\t\tP = t * v1;\n\t\tfloat dx2 = length(P-vxl);\n\t\tocolor.rgb += (dx2-dx-(0.5 * pan)) * 1.0;\n\t}\n"+gi,vi="#version 300 es\n#line 480\nprecision highp int;\nprecision highp float;\nuniform vec4 lineColor;\nout vec4 color;\nvoid main() {\n\tcolor = lineColor;\n}",xi="#version 300 es\n#line 520\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform vec4 leftTopWidthHeight;\nvoid main(void) {\n\t//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1\n\tvec2 frac;\n\tfrac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1\n\tfrac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0\n\tfrac = (frac * 2.0) - 1.0;\n\tgl_Position = vec4(frac, 0.0, 1.0);\n}",wi="#version 300 es\n#line 613\nprecision highp int;\nprecision highp float;\nin vec3 vPos;\nout vec2 TexCoord;\nvoid main() {\n\tTexCoord = vPos.xy;\n\tgl_Position = vec4( (vPos.xy-vec2(0.5,0.5)) * 2.0, 0.0, 1.0);\n}",bi="#version 300 es\nuniform highp usampler3D intensityVol;\n",yi="#version 300 es\nuniform highp isampler3D intensityVol;\n",Ci="#version 300 es\nuniform highp sampler3D intensityVol;\n",Mi="#line 1042\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform bool isAdditiveBlend;\nuniform float coordZ;\nuniform float layer;\nuniform highp sampler2D colormap;\nuniform lowp sampler3D blend3D;\nuniform float opacity;\nuniform uint activeIndex;\nuniform vec4 xyzaFrac;\nuniform mat4 mtx;\nfloat textureWidth;\nfloat nlayer;\nfloat layerY;\n\nvec4 scalar2color(uint idx) {\n\tfloat fx = (float(idx) + 0.5) / textureWidth;\n\tvec4 clr = texture(colormap, vec2(fx, layerY)).rgba;\n\tif (clr.a > 0.0)\n\t\tclr.a = 1.0;\n\tclr.a *= opacity;\n\treturn clr;\n}\nvoid main(void) {\n\tvec4 vx = vec4(TexCoord.x, TexCoord.y, coordZ, 1.0) * mtx;\n\tuint idx = uint(texture(intensityVol, vx.xyz).r);\n\tif (idx == uint(0)) {\n\t\tif (layer < 1.0) {\n\t\t\tFragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\treturn;\n\t\t}\n\t\tFragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n\t\treturn;\n\t}\n\ttextureWidth = float(textureSize(colormap, 0).x);\n\tnlayer = float(textureSize(colormap, 0).y);\n\tlayerY = ((2.0 * layer) + 1.5) / nlayer;\n\t//idx = ((idx - uint(1)) % uint(100))+uint(1);\n\tFragColor = scalar2color(idx);\n\tbool isBorder = false;\n\tvx = vec4(TexCoord.x+xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;\n\tuint R = uint(texture(intensityVol, vx.xyz).r);\n\tvx = vec4(TexCoord.x-xyzaFrac.x, TexCoord.y, coordZ, 1.0) * mtx;\n\tuint L = uint(texture(intensityVol, vx.xyz).r);\n\tvx = vec4(TexCoord.x, TexCoord.y+xyzaFrac.y, coordZ, 1.0) * mtx;\n\tuint A = uint(texture(intensityVol, vx.xyz).r);\n\tvx = vec4(TexCoord.x, TexCoord.y-xyzaFrac.y, coordZ, 1.0) * mtx;\n\tuint P = uint(texture(intensityVol, vx.xyz).r);\n\tvx = vec4(TexCoord.x, TexCoord.y, coordZ+xyzaFrac.z, 1.0) * mtx;\n\tuint S = uint(texture(intensityVol, vx.xyz).r);\n\tvx = vec4(TexCoord.x, TexCoord.y, coordZ-xyzaFrac.z, 1.0) * mtx;\n\tuint I = uint(texture(intensityVol, vx.xyz).r);\n\tvec4 centerColor = FragColor;\n\tFragColor.a += scalar2color(R).a;\n\tFragColor.a += scalar2color(L).a;\n\tFragColor.a += scalar2color(A).a;\n\tFragColor.a += scalar2color(P).a;\n\tFragColor.a += scalar2color(S).a;\n\tFragColor.a += scalar2color(I).a;\n\tFragColor.a /= 7.0;\n\tif ((!isBorder) &&(idx == activeIndex)) {\n\t\tif (centerColor.a > 0.5)\n\t\t\tFragColor.a *= 0.4;\n\t\telse\n\t\t\tFragColor.a =0.8;\n\t}\n\tif (xyzaFrac.a != 0.0) { //outline\n\t\tif ((idx != R) || (idx != L) || (idx != A) || (idx != P) || (idx != S) || (idx != I)) {\n\t\t\tisBorder = true;\n\t\t\tif (xyzaFrac.a > 0.0)\n\t\t\t\tFragColor.a = xyzaFrac.a;\n\t\t\telse\n\t\t\t\tFragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\t}\n\t}\n\tif (layer < 1.0) return;\n\t\tvec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n\t\t// https://en.wikipedia.org/wiki/Alpha_compositing\n\t\tfloat aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;\n\t\tif (aout <= 0.0) return;\n\t\tif (isAdditiveBlend)\n\t\t\tFragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;\n\t\telse\n\t\t\tFragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;\n\t\tFragColor.a = aout;\n}",Di="#line 691\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float layer;\nuniform float scl_slope;\nuniform float scl_inter;\nuniform float cal_max;\nuniform float cal_min;\nuniform float cal_maxNeg;\nuniform float cal_minNeg;\nuniform bool isAlphaThreshold;\nuniform bool isColorbarFromZero;\nuniform bool isAdditiveBlend;\nuniform highp sampler2D colormap;\nuniform lowp sampler3D blend3D;\nuniform int modulation;\nuniform highp sampler3D modulationVol;\nuniform float opacity;\nuniform mat4 mtx;\nvoid main(void) {\n\tvec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;\n\tif ((vx.x < 0.0) || (vx.x > 1.0) || (vx.y < 0.0) || (vx.y > 1.0) || (vx.z < 0.0) || (vx.z > 1.0)) {\n\t\t//set transparent if out of range\n\t\t//https://webglfundamentals.org/webgl/webgl-3d-textures-repeat-clamp.html\n\t\tFragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n\t\treturn;\n\t}\n\tfloat f = (scl_slope * float(texture(intensityVol, vx.xyz).r)) + scl_inter;\n\tfloat mn = cal_min;\n\tfloat mx = cal_max;\n\tif ((isAlphaThreshold) || (isColorbarFromZero))\n\t\tmn = 0.0;\n\tfloat r = max(0.00001, abs(mx - mn));\n\tmn = min(mn, mx);\n\tfloat txl = mix(0.0, 1.0, (f - mn) / r);\n\tif (f > mn) { //issue1139: survives threshold, so round up to opaque voxel\n\t\ttxl = max(txl, 2.0/256.0);\n\t}\n\t//https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space\n\tfloat nlayer = float(textureSize(colormap, 0).y);\n\t//each volume has two color maps:\n\t// (layer*2) = negative and (layer * 2) + 1 = positive\n\tfloat y = ((2.0 * layer) + 1.5)/nlayer;\n\tFragColor = texture(colormap, vec2(txl, y)).rgba;\n\t//negative colors\n\tmn = cal_minNeg;\n\tmx = cal_maxNeg;\n\tif ((isAlphaThreshold) || (isColorbarFromZero))\n\t\tmx = 0.0;\n\t//if ((!isnan(cal_minNeg)) && ( f < mx)) {\n\tif ((cal_minNeg < cal_maxNeg) && ( f < mx)) {\n\t\tr = max(0.00001, abs(mx - mn));\n\t\tmn = min(mn, mx);\n\t\ttxl = 1.0 - mix(0.0, 1.0, (f - mn) / r);\n\t\t//issue1139: survives threshold, so round up to opaque voxel\n\t\ttxl = max(txl, 2.0/256.0);\n\t\ty = ((2.0 * layer) + 0.5)/nlayer;\n\t\tFragColor = texture(colormap, vec2(txl, y));\n\t}\n\tif (layer > 0.7)\n\t\tFragColor.a = step(0.00001, FragColor.a);\n\t//if (modulation > 10)\n\t//\tFragColor.a *= texture(modulationVol, vx.xyz).r;\n\t//\tFragColor.rgb *= texture(modulationVol, vx.xyz).r;\n\tif (isAlphaThreshold) {\n\t\tif ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))\n\t\t\tFragColor.a = pow(-f / -cal_maxNeg, 2.0);\n\t\telse if ((f > 0.0) && (cal_min > 0.0))\n\t\t\tFragColor.a *= pow(f / cal_min, 2.0); //issue435:  A = (V/X)**2\n\t\t//FragColor.g = 0.0;\n\t} else if (isColorbarFromZero) {\n\t\tif ((cal_minNeg != cal_maxNeg) && ( f < 0.0) && (f > cal_maxNeg))\n\t\t\tFragColor.a = 0.0;\n\t\telse if ((f > 0.0) && (cal_min > 0.0) && (f < cal_min))\n\t\t\tFragColor.a *= 0.0;\n\n\t}\n\tif (modulation == 1) {\n\t\tFragColor.rgb *= texture(modulationVol, vx.xyz).r;\n\t} else if (modulation == 2) {\n\t\tFragColor.a = texture(modulationVol, vx.xyz).r;\n\t}\n\tFragColor.a *= opacity;\n\tif (layer < 1.0) return;\n\tvec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n\t// https://en.wikipedia.org/wiki/Alpha_compositing\n\tfloat aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;\n\tif (aout <= 0.0) return;\n\tif (isAdditiveBlend)\n\t\tFragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a)) / aout;\n\telse\n\t\tFragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;\n\tFragColor.a = aout;\n}",Ii="#version 300 es\nlayout(location=0) in vec3 pos;\nlayout(location=1) in vec4 norm;\nlayout(location=2) in vec4 clr;\nuniform mat4 mvpMtx;\n//uniform mat4 modelMtx;\nuniform mat4 normMtx;\nout vec4 vClr;\nout vec3 vN;\nout vec4 vP;\nout vec4 vPc;\nvoid main(void) {\n\tvec3 lightPosition = vec3(0.0, 0.0, -10.0);\n\tvP = vec4(pos, 1.0);\n\tvPc = mvpMtx * vec4(pos, 1.0);\n\tgl_Position = vPc;\n\tvN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);\n\t//vV = -vec3(modelMtx*vec4(pos,1.0));\n\tvClr = clr;\n}",Ti="#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nflat in vec3 vN;\nout vec4 color;\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.35;\n\tfloat diffuse = 0.5;\n\tfloat specular = 0.2;\n\tfloat shininess = 10.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor = vec4(a + d + s, opacity);\n}",Si="#version 300 es\n#line 1260\n//precision highp int;\nprecision highp float;\nuniform vec3 rayDir;\nuniform vec3 volScale;\nuniform vec3 texVox;\nuniform vec4 clipPlane;\nuniform highp sampler3D volume, overlay;\nuniform highp sampler3D paqd;\nuniform vec4 paqdUniforms;\nuniform float overlays;\nuniform float clipThick;\nuniform vec3 clipLo;\nuniform vec3 clipHi;\nuniform mat4 matRAS;\nuniform mat4 mvpMtx;\nuniform float drawOpacity, renderOverlayBlend;\nuniform highp sampler3D drawing;\nuniform highp sampler2D colormap;\nuniform int backgroundMasksOverlays;\nin vec3 vColor;\nout vec4 fColor;\n"+si+"\nvoid main() {\n\tint id = 254;\n\tvec3 start = vColor;\n\tgl_FragDepth = 0.0;\n\tfColor = vec4(0.0, 0.0, 0.0, 0.0); //assume no hit: ID = 0\n\tfloat fid = float(id & 255)/ 255.0;\n\tvec3 backPosition = GetBackPosition(start);\n\tvec3 dir = normalize(backPosition - start);\n\tclipVolumeStart(start, backPosition);\n\tfloat len = length(backPosition - start);\n\tfloat lenVox = length((texVox * start) - (texVox * backPosition));\n\tif ((lenVox < 0.5) || (len > 3.0)) return;//discard; //length limit for parallel rays\n\tfloat sliceSize = len / lenVox; //e.g. if ray length is 1.0 and traverses 50 voxels, each voxel is 0.02 in unit cube\n\tfloat stepSize = sliceSize; //quality: larger step is faster traversal, but fewer samples\n\tfloat opacityCorrection = stepSize/sliceSize;\n\tdir = normalize(dir);\n\tvec4 samplePos = vec4(start.xyz, 0.0); //ray position\n\tfloat lenNoClip = len;\n\tbool isClip = false;\n\tvec4 clipPos = applyClip(dir, samplePos, len, isClip);\n\tif (isClip) fColor = vec4(samplePos.xyz, 253.0 / 255.0); //assume no hit: ID = 0\n\t//start: OPTIONAL fast pass: rapid traversal until first hit\n\tfloat stepSizeFast = sliceSize * 1.9;\n\tvec4 deltaDirFast = vec4(dir.xyz * stepSizeFast, stepSizeFast);\n\twhile (samplePos.a <= len) {\n\t\tfloat val = texture(volume, samplePos.xyz).a;\n\t\tif (val > 0.01) {\n\t\t\tfColor = vec4(samplePos.rgb, fid);\n\t\t\tgl_FragDepth = frac2ndc(samplePos.xyz);\n\t\t\tbreak;\n\t\t}\n\t\tsamplePos += deltaDirFast; //advance ray position\n\t}\n\t//end: fast pass\n\tif ((overlays < 1.0) || (backgroundMasksOverlays > 0)) {\n\t\treturn; //background hit, no overlays\n\t}\n\t//overlay pass\n\tlen = min(lenNoClip, samplePos.a); //only find overlay closer than background\n\tsamplePos = vec4(start.xyz, 0.0); //ray position\n\twhile (samplePos.a <= len) {\n\t\tfloat val = texture(overlay, samplePos.xyz).a;\n\t\tif (val > 0.01) {\n\t\t\tfColor = vec4(samplePos.rgb, fid);\n\t\t\tgl_FragDepth = frac2ndc(samplePos.xyz);\n\t\t\treturn;\n\t\t}\n\t\tsamplePos += deltaDirFast; //advance ray position\n\t}\n\t//if (fColor.a == 0.0) discard; //no hit in either background or overlays\n\t//you only get here if there is a hit with the background that is closer than any overlay\n}",Fi="#version 300 es\n#line 286\nprecision highp int;\nprecision highp float;\nin vec3 vPos;\nout vec2 TexCoord;\nvoid main() {\n    TexCoord = vPos.xy;\n    gl_Position = vec4( (vPos.xy-vec2(0.5,0.5))* 2.0, 0.0, 1.0);\n}",Ei="\n  gradientSample.a = log2(gradientSample.r*gradientSample.r + gradientSample.g*gradientSample.g + gradientSample.b*gradientSample.b + 1.922337562475971e-06) + 18.988706873717717;\n",Bi=`#version 300 es\n#line 323\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float dX;\nuniform float dY;\nuniform float dZ;\nuniform highp sampler3D intensityVol;\nvoid main(void) {\n  vec3 vx = vec3(TexCoord.xy, coordZ);\n  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft\n  float TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ)).r;\n  float TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ)).r;\n  float TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ)).r;\n  float TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ)).r;\n  float BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ)).r;\n  float BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ)).r;\n  float BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ)).r;\n  float BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ)).r;\n  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);\n  gradientSample.r = BAR+BAL+BPR+BPL -TAR-TAL-TPR-TPL;\n  gradientSample.g = TPR+TPL+BPR+BPL -TAR-TAL-BAR-BAL;\n  gradientSample.b = TAL+TPL+BAL+BPL -TAR-TPR-BAR-BPR;\n${Ei}\n\t// 0.04242020977371934 = 1/(log2(3*8) - log2(1/(255**2*8))) // 3*8 -> max for 1st order gradient\n\tgradientSample.a *= 0.04242020977371934;\n  gradientSample.rgb = normalize(gradientSample.rgb);\n  gradientSample.rgb = (gradientSample.rgb * 0.5)+0.5;\n  FragColor = gradientSample;\n}`,Vi=`#version 300 es\n#line 323\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float dX;\nuniform float dY;\nuniform float dZ;\nuniform float dX2;\nuniform float dY2;\nuniform float dZ2;\nuniform highp sampler3D intensityVol;\nvoid main(void) {\n  vec3 vx = vec3(TexCoord.xy, coordZ);\n  //Neighboring voxels 'T'op/'B'ottom, 'A'nterior/'P'osterior, 'R'ight/'L'eft\n  vec4 TAR = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));\n  vec4 TAL = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));\n  vec4 TPR = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));\n  vec4 TPL = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));\n  vec4 BAR = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));\n  vec4 BAL = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));\n  vec4 BPR = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));\n  vec4 BPL = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));\n  vec4 T = texture(intensityVol,vx+vec3(+dX2,0.0,0.0));\n  vec4 A = texture(intensityVol,vx+vec3(0.0,+dY2,0.0));\n  vec4 R = texture(intensityVol,vx+vec3(0.0,0.0,+dZ2));\n  vec4 B = texture(intensityVol,vx+vec3(-dX2,0.0,0.0));\n  vec4 P = texture(intensityVol,vx+vec3(0.0,-dY2,0.0));\n  vec4 L = texture(intensityVol,vx+vec3(0.0,0.0,-dZ2));\n  vec4 gradientSample = vec4 (0.0, 0.0, 0.0, 0.0);\n  gradientSample.r = -4.0*B.r +8.0*(BAR.r+BAL.r+BPR.r+BPL.r) -8.0*(TAR.r+TAL.r+TPR.r+TPL.r) +4.0*T.r;\n  gradientSample.g = -4.0*P.g +8.0*(TPR.g+TPL.g+BPR.g+BPL.g) -8.0*(TAR.g+TAL.g+BAR.g+BAL.g) +4.0*A.g;\n  gradientSample.b = -4.0*L.b +8.0*(TAL.b+TPL.b+BAL.b+BPL.b) -8.0*(TAR.b+TPR.b+BAR.b+BPR.b) +4.0*R.b;\n${Ei}\n\tgradientSample.a *= 0.0325;\n  gradientSample.rgb = normalize(gradientSample.rgb);\n  gradientSample.rgb =  (gradientSample.rgb * 0.5)+0.5;\n  FragColor = gradientSample;\n}`,Ui=class{constructor(t,e,i){M(this,"program"),M(this,"uniforms",{}),M(this,"isMatcap"),this.program=function(t,e,i){const s=t.createShader(t.VERTEX_SHADER);t.shaderSource(s,e),t.compileShader(s);const r=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(r,i),t.compileShader(r);const n=t.createProgram();if(t.attachShader(n,s),t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),t.getShaderParameter(s,t.COMPILE_STATUS)||console.log("Vertex shader compilation error:",t.getShaderInfoLog(s)),t.getShaderParameter(r,t.COMPILE_STATUS)||console.log("Fragment shader compilation error:",t.getShaderInfoLog(r)),U.error(t.getProgramInfoLog(n)),new Error("Shader failed to link, see console for log");return n}(t,e,i);const s=/uniform[^;]+[ ](\w+);/g,r=/uniform[^;]+[ ](\w+);/,n=e.match(s),o=i.match(s);n&&n.forEach((t=>{const e=t.match(r);this.uniforms[e[1]]=-1})),o&&o.forEach((t=>{const e=t.match(r);this.uniforms[e[1]]=-1}));for(const a in this.uniforms)this.uniforms[a]=t.getUniformLocation(this.program,a)}use(t){t.useProgram(this.program)}},Ri=(t,e)=>{const i=Math.floor(Math.log(t)/Math.log(10)),s=t/Math.pow(10,i);let r;return r=e?s<1.5?1:s<3?2:s<7?5:10:s<=1?1:s<=2?2:s<=5?5:10,r*Math.pow(10,i)};function Ni(t){return new Promise(((e,i)=>{let s;s=t instanceof File?Promise.resolve(t):new Promise(((e,i)=>{t.file(e,i)})),s.then((t=>{const s=new FileReader;s.onload=()=>{"string"==typeof s.result?e(s.result):i(new Error("Expected a string from FileReader.result"))},s.onerror=()=>{i(s.error??new Error("Unknown FileReader error"))},s.readAsDataURL(t)})).catch((t=>i(t)))}))}function Pi(t,e){return 0===t.scl_slope&&(t.scl_slope=1),e*t.scl_slope+t.scl_inter}function Li(t,e,i){void 0===i&&(i=4);const s=Ri(e-t,!1),r=Ri(s/(i-1),!0),n=Math.floor(t/r)*r,o=Math.ceil(e/r)*r;return[r,n,o,n===t&&o===e]}function ki(t,e){let i=Li(t,e,3);return i[3]||(i=Li(t,e,5)),i[3]||(i=Li(t,e,4)),i[3]||(i=Li(t,e,3)),i[3]||(i=Li(t,e,5)),[i[0],i[1],i[2]]}function Oi(t){return t*(Math.PI/180)}function Yi(t,e,i,s){let r=-t,n=-e;return isFinite(i)&&isFinite(s)&&(r=i,n=s),r>n&&([r,n]=[n,r]),[r,n]}function Gi(t,e,i){return Math.min(Math.max(t,e),i)}function Wi(t,e){void 0===e&&(e=[0,1,2]);const i=r.vt();return i[0]=t[e[0]],i[1]=t[e[1]],i[2]=t[e[2]],i}function Ki(t){const e=s.fA(1,0,0,0),i=s.vt();return s.Z0(i,e,t),i[0]}var zi,{version:Qi}={name:"@niivue/niivue",version:"0.62.1",description:"minimal webgl2 nifti image viewer",types:"./build/niivue/index.d.ts",main:"./build/niivue/index.js",type:"module",unpkg:"./dist/index.min.js",module:"./build/niivue/index.js",exports:{".":{import:"./build/niivue/index.js",types:"./build/niivue/index.d.ts"},"./drawing":{import:"./build/drawing/index.js",types:"./build/drawing/index.d.ts"},"./utils":{import:"./build/utils/index.js",types:"./build/utils/index.d.ts"},"./min":{import:"./build/index.min.js"}},scripts:{dev:"vite","build:umd":"vite build --config vite.config.js --base=./ && vite build --config vite.config_inject.js --base=./",build:"tsup --config tsup.config.ts && npm run build:forTests && npm run build:min && npm run build:umd","build:forTests":"tsup --config tsup.config.tests.ts && npm run build:mindemos","build:min":"node bundle.js","build:mindemos":"node bundleForDemos.js",demo:"npm run build:forTests && rm -rf demos/dist && cp -r dist demos/dist && npx http-server demos/ --cors","demo-win":"npm run build && npx http-server demos/",test:"npm run build:forTests && npm run test:unit && jest --maxWorkers=1","test-win":"npm run build-win && jest","test-playwright":'npx playwright test --grep-invert "niivue demo file:"',"test-demos":"npx playwright test playwright/e2e/test.demos.spec.ts",docs:"typedoc && rm -rf ../docs/docs/api && cp -r devdocs ../docs/docs/api","test:unit":"vitest --run --coverage","serve-docs":"npx http-server devdocs",pub:"npm run build && npm publish --access public",lint:"eslint .","lint:ts":"tsc --noEmit","lint:fix":"eslint --fix .","lint:debug":"DEBUG=eslint:cli-engine eslint .","pretest-playwright":"npm run build:forTests && node preplaywrighttest.cjs && tsc --incremental -p playwright/e2e/tsconfig.json","pretest-demos":"npm run build:forTests && node preplaywrighttest.cjs && tsc --incremental -p playwright/e2e/tsconfig.json"},files:["src","build","dist"],repository:{type:"git",url:"git+https://github.com/niivue/niivue.git"},keywords:["niivue","webgl2","nifti","image","viewer"],author:"niivue authors",license:"BSD-2-Clause",bugs:{url:"https://github.com/niivue/niivue/issues"},homepage:"https://github.com/niivue/niivue#readme",dependencies:{"@lukeed/uuid":"^2.0.1","@ungap/structured-clone":"^1.2.0","array-equal":"^1.0.2",fflate:"^0.8.2","gl-matrix":"^3.4.3","nifti-reader-js":"^0.8.0",zarrita:"^0.5.0"},devDependencies:{"@playwright/test":"^1.45.2","@rollup/plugin-commonjs":"^26.0.1","@types/array-equal":"^1.0.2","@types/node":"^20.14.11","@types/ungap__structured-clone":"^1.2.0","@typescript-eslint/eslint-plugin":"^7.16.1","@typescript-eslint/parser":"^7.16.1","@vitest/coverage-v8":"^3.1.3",eslint:"^8.57.0","eslint-config-prettier":"^9.1.0","eslint-config-standard":"^17.1.0","eslint-plugin-prettier":"^5.2.1","eslint-plugin-tsdoc":"^0.3.0",express:"^4.19.2","happy-dom":"^15.11.6","http-server":"^14.1.1",prettier:"^3.3.3","regenerator-runtime":"^0.14.1",terser:"^5.31.3",tsup:"^8.1.2",typedoc:"^0.28.5","typedoc-docusaurus-theme":"^1.4.0","typedoc-plugin-markdown":"^4.7.0",typescript:"^5.5.3",vite:"^5.3.4",vitest:"^3.1.3"},optionalDependencies:{"@rollup/rollup-linux-x64-gnu":"^4.18.1"}},Xi=["ASC","BYU","DFS","FSM","PIAL","ORIG","INFLATED","SMOOTHWM","SPHERE","WHITE","G","GEO","GII","ICO","MZ3","NV","OBJ","OFF","PLY","SRF","STL","TCK","TRACT","TRI","TRK","TT","TRX","VTK","WRL","X3D","JCON","JSON"],Hi=33984,qi=33985,Zi=33986,ji=33989,Ji=33990,_i=33991,$i=33992,ts=33994,es={filename:"",isSaveDrawing:!1,volumeByIndex:0},is=class{constructor(t){void 0===t&&(t=Le),M(this,"loaders",{}),M(this,"dicomLoader",null),M(this,"canvas",null),M(this,"_gl",null),M(this,"isBusy",!1),M(this,"needsRefresh",!1),M(this,"colormapTexture",null),M(this,"colormapLists",[]),M(this,"volumeTexture",null),M(this,"gradientTexture",null),M(this,"gradientTextureAmount",0),M(this,"useCustomGradientTexture",!1),M(this,"renderGradientValues",!1),M(this,"drawTexture",null),M(this,"paqdTexture",null),M(this,"drawUndoBitmaps",[]),M(this,"drawLut",re.makeDrawLut("$itksnap")),M(this,"drawOpacity",.8),M(this,"drawRimOpacity",-1),M(this,"clickToSegmentIsGrowing",!1),M(this,"clickToSegmentGrowingBitmap",null),M(this,"clickToSegmentXY",[0,0]),M(this,"renderDrawAmbientOcclusion",.4),M(this,"colorbarHeight",0),M(this,"drawPenLocation",[NaN,NaN,NaN]),M(this,"drawPenAxCorSag",-1),M(this,"drawFillOverwrites",!0),M(this,"drawPenFillPts",[]),M(this,"drawShapeStartLocation",[NaN,NaN,NaN]),M(this,"drawShapePreviewBitmap",null),M(this,"overlayTexture",null),M(this,"overlayTextureID",null),M(this,"sliceMMShader"),M(this,"slice2DShader"),M(this,"sliceV1Shader"),M(this,"orientCubeShader"),M(this,"orientCubeShaderVAO",null),M(this,"rectShader"),M(this,"rectOutlineShader"),M(this,"renderShader"),M(this,"lineShader"),M(this,"line3DShader"),M(this,"passThroughShader"),M(this,"renderGradientShader"),M(this,"renderGradientValuesShader"),M(this,"renderSliceShader"),M(this,"renderVolumeShader"),M(this,"pickingMeshShader"),M(this,"pickingImageShader"),M(this,"colorbarShader"),M(this,"customSliceShader",null),M(this,"fontShader",null),M(this,"fiberShader"),M(this,"fontTexture",null),M(this,"circleShader"),M(this,"matCapTexture",null),M(this,"bmpShader",null),M(this,"bmpTexture",null),M(this,"thumbnailVisible",!1),M(this,"bmpTextureWH",1),M(this,"growCutShader"),M(this,"orientShaderAtlasU",null),M(this,"orientShaderAtlasI",null),M(this,"orientShaderU",null),M(this,"orientShaderI",null),M(this,"orientShaderF",null),M(this,"orientShaderRGBU",null),M(this,"orientShaderPAQD",null),M(this,"surfaceShader",null),M(this,"blurShader",null),M(this,"sobelBlurShader",null),M(this,"sobelFirstOrderShader",null),M(this,"sobelSecondOrderShader",null),M(this,"genericVAO",null),M(this,"unusedVAO",null),M(this,"crosshairs3D",null),M(this,"DEFAULT_FONT_GLYPH_SHEET",We),M(this,"DEFAULT_FONT_METRICS",Ke),M(this,"fontMetrics"),M(this,"fontMets",null),M(this,"fontPx",12),M(this,"legendFontScaling",1),M(this,"backgroundMasksOverlays",0),M(this,"overlayOutlineWidth",0),M(this,"overlayAlphaShader",1),M(this,"position"),M(this,"extentsMin"),M(this,"extentsMax"),M(this,"resizeObserver",null),M(this,"resizeEventListener",null),M(this,"canvasObserver",null),M(this,"syncOpts",{"3d":!1,"2d":!1,zoomPan:!1,cal_min:!1,cal_max:!1,clipPlane:!1,gamma:!1,sliceType:!1,crosshair:!1}),M(this,"readyForSync",!1),M(this,"uiData",{mousedown:!1,touchdown:!1,mouseButtonLeftDown:!1,mouseButtonCenterDown:!1,mouseButtonRightDown:!1,mouseDepthPicker:!1,clickedTile:-1,pan2DxyzmmAtMouseDown:[0,0,0,1],prevX:0,prevY:0,currX:0,currY:0,currentTouchTime:0,lastTouchTime:0,touchTimer:null,doubleTouch:!1,isDragging:!1,dragStart:[0,0],dragEnd:[0,0],dragClipPlaneStartDepthAziElev:[0,0,0],lastTwoTouchDistance:0,multiTouchGesture:!1,windowX:0,windowY:0,activeDragMode:null,activeDragButton:null,angleFirstLine:[0,0,0,0],angleState:"none"}),T(this,zi,null),M(this,"back",null),M(this,"overlays",[]),M(this,"deferredVolumes",[]),M(this,"deferredMeshes",[]),M(this,"furthestVertexFromOrigin",100),M(this,"volScale",[]),M(this,"vox",[]),M(this,"mousePos",[0,0]),M(this,"screenSlices",[]),M(this,"cuboidVertexBuffer"),M(this,"otherNV",null),M(this,"volumeObject3D",null),M(this,"pivot3D",[0,0,0]),M(this,"furthestFromPivot",10),M(this,"currentClipPlaneIndex",0),M(this,"lastCalled",(new Date).getTime()),M(this,"selectedObjectId",-1),M(this,"CLIP_PLANE_ID",1),M(this,"VOLUME_ID",254),M(this,"DISTANCE_FROM_CAMERA",-.54),M(this,"graph",{LTWH:[0,0,640,480],opacity:0,vols:[0],autoSizeMultiplanar:!1,normalizeValues:!1,isRangeCalMinMax:!1}),M(this,"customLayout",[]),M(this,"meshShaders",[{Name:"Phong",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.35;\n\tfloat diffuse = 0.5;\n\tfloat specular = 0.2;\n\tfloat shininess = 10.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor = vec4(a + d + s, opacity);\n}"},{Name:"Matte",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tfloat ambient = 0.35;\n\tfloat diffuse = 0.6;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tcolor = vec4(a + d, opacity);\n}"},{Name:"Harmonic",Frag:'#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\n//Spherical harmonics constants\nconst float C1 = 0.429043;\nconst float C2 = 0.511664;\nconst float C3 = 0.743125;\nconst float C4 = 0.886227;\nconst float C5 = 0.247708;\n//Spherical harmonics coefficients\n// Ramamoorthi, R., and P. Hanrahan. 2001b. "An Efficient Representation for Irradiance Environment Maps." In Proceedings of SIGGRAPH 2001, pp. 497\u2013500.\n// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl\n// https://github.com/eskimoblood/processingSketches/blob/master/data/shader/shinyvert.glsl\n// Constants for Eucalyptus Grove lighting\nconst vec3 L00  = vec3( 0.3783264,  0.4260425,  0.4504587);\nconst vec3 L1m1 = vec3( 0.2887813,  0.3586803,  0.4147053);\nconst vec3 L10  = vec3( 0.0379030,  0.0295216,  0.0098567);\nconst vec3 L11  = vec3(-0.1033028, -0.1031690, -0.0884924);\nconst vec3 L2m2 = vec3(-0.0621750, -0.0554432, -0.0396779);\nconst vec3 L2m1 = vec3( 0.0077820, -0.0148312, -0.0471301);\nconst vec3 L20  = vec3(-0.0935561, -0.1254260, -0.1525629);\nconst vec3 L21  = vec3(-0.0572703, -0.0502192, -0.0363410);\nconst vec3 L22  = vec3( 0.0203348, -0.0044201, -0.0452180);\nvec3 SH(vec3 vNormal) {\n\tvNormal = vec3(vNormal.x,vNormal.z,vNormal.y);\n\tvec3 diffuseColor = C1 * L22 * (vNormal.x * vNormal.x - vNormal.y * vNormal.y) +\n\tC3 * L20 * vNormal.z * vNormal.z +\n\tC4 * L00 -\n\tC5 * L20 +\n\t2.0 * C1 * L2m2 * vNormal.x * vNormal.y +\n\t2.0 * C1 * L21  * vNormal.x * vNormal.z +\n\t2.0 * C1 * L2m1 * vNormal.y * vNormal.z +\n\t2.0 * C2 * L11  * vNormal.x +\n\t2.0 * C2 * L1m1 * vNormal.y +\n\t2.0 * C2 * L10  * vNormal.z;\n\treturn diffuseColor;\n}\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.3;\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.1;\n\tfloat shininess = 10.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = vClr.rgb * diffuse * SH(-reflect(n, vec3(l.x, l.y, -l.z)) );\n\tcolor = vec4(a + d + s, opacity);\n}'},{Name:"Hemispheric",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.35;\n\tfloat diffuse = 0.5;\n\tfloat specular = 0.2;\n\tfloat shininess = 10.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tfloat ax = dot(n, up) * 0.5 + 0.5;  //Shreiner et al. (2013) OpenGL Programming Guide, 8th Ed., p 388. ISBN-10: 0321773039\n\tvec3 upClr = vec3(1.0, 1.0, 0.95);\n\tvec3 downClr = vec3(0.4, 0.4, 0.6);\n\tvec3 a = vClr.rgb * ambient;\n\ta *= mix(downClr, upClr, ax);\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor = vec4(a + d + s, opacity);\n}"},{Name:"Crevice",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nin vec4 vPc;\nout vec4 color;\nvoid main() {\n\tvec3 n = normalize(vN);\n\t// Compute curvature\n\tvec3 dx = dFdx(n);\n\tvec3 dy = dFdy(n);\n\tvec3 xneg = n - dx;\n\tvec3 xpos = n + dx;\n\tvec3 yneg = n - dy;\n\tvec3 ypos = n + dy;\n\tfloat depth = length(vPc.xyz);\n\tfloat curv = (cross(xneg, xpos).y - cross(yneg, ypos).x) / depth;\n\t//at this stage 0.5 for flat, with valleys dark and ridges bright\n\tcurv = 1.0 - (curv + 0.5);\n\t//clamp\n\tcurv =  min(max(curv, 0.0), 1.0);\n\t// easing function\n\tcurv = pow(curv, 0.5);\n\t//modulate ambient and diffuse with curvature\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.6;\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.2;\n\tfloat shininess = 10.0;\n\tvec3 lightPosition = vec3(0.0, 10.0, -2.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tvec3 a = vClr.rgb * ambient * curv;\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor = vec4(a + d + s, opacity);\n}"},{Name:"Edge",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat diffuse = 1.0;\n\tfloat specular = 0.2;\n\tfloat shininess = 10.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 0.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = max(dot(n, l), 0.0);\n\tvec3 d = lightNormDot * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor = vec4(d + s, opacity);\n}"},{Name:"Diffuse",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tfloat diffuse = 1.4;\n\tvec3 l = vec3(0.0, 0.0, -1.0);\n\tfloat lightNormDot = max(dot(normalize(vN), l), 0.0);\n\tcolor = vec4(lightNormDot * vClr.rgb * diffuse, opacity);\n}"},{Name:"Outline",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tfloat ambient = 0.3;\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.25;\n\tfloat shininess = 10.0;\n\tfloat PenWidth = 0.6;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat lightNormDot = dot(n, l);\n\tfloat view = abs(dot(n,r)); //with respect to viewer\n\tif (PenWidth < view) discard;\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = max(lightNormDot, 0.0) * vClr.rgb * diffuse;\n\tfloat s = specular * pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tcolor.rgb = a + d + s;\n\tcolor.a = opacity;\n}"},{Name:"Specular",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tfloat specularRGB = 0.7;\n\tfloat specularWhite = 0.3;\n\tfloat shininess = 10.0;\n\tfloat diffuse = 1.0;\n\tvec3 r = vec3(0.0, 0.0, 1.0); //rayDir: for orthographic projections moving in Z direction (no need for normal matrix)\n\tvec3 n = normalize(vN);\n\tvec3 l = vec3(0.0, 0.0, -1.0);\n\tfloat lightNormDot = max(dot(n, l), 0.0);\n\tvec3 d3 = lightNormDot * vClr.rgb * diffuse;\n\tfloat s = pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tvec3 s3 = specularRGB * s * vClr.rgb;\n\ts *= specularWhite;\n\tcolor = vec4(d3 + s3 + s, opacity);\n}"},{Name:"Toon",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nfloat stepmix(float edge0, float edge1, float E, float x){\n\tfloat T = clamp(0.5 * (x - edge0 + E) / E, 0.0, 1.0);\n\treturn mix(edge0, edge1, T);\n}\nvoid main() {\n\tvec3 r = vec3(0.0, 0.0, 1.0);\n\tfloat ambient = 0.3;\n\tfloat diffuse = 0.6;\n\tfloat specular = 0.5;\n\tfloat shininess = 50.0;\n\tvec3 n = normalize(vN);\n\tvec3 lightPosition = vec3(0.0, 10.0, -5.0);\n\tvec3 l = normalize(lightPosition);\n\tfloat df = max(0.0, dot(n, l));\n\tfloat sf = pow(max(dot(reflect(l, n), r), 0.0), shininess);\n\tconst float A = 0.1;\n\tconst float B = 0.3;\n\tconst float C = 0.6;\n\tconst float D = 1.0;\n\tfloat E = fwidth(df);\n\tif (df > A - E && df < A + E) df = stepmix(A, B, E, df);\n\telse if (df > B - E && df < B + E) df = stepmix(B, C, E, df);\n\telse if (df > C - E && df < C + E) df = stepmix(C, D, E, df);\n\telse if (df < A) df = 0.0;\n\telse if (df < B) df = B;\n\telse if (df < C) df = C;\n\telse df = D;\n\tE = fwidth(sf);\n\tif (sf > 0.5 - E && sf < 0.5 + E)\n\t\tsf = smoothstep(0.5 - E, 0.5 + E, sf);\n\telse\n\t\tsf = step(0.5, sf);\n\tvec3 a = vClr.rgb * ambient;\n\tvec3 d = max(df, 0.0) * vClr.rgb * diffuse;\n\tcolor.rgb = a + d + (specular * sf);\n\tcolor.a = opacity;\n}"},{Name:"Flat",Frag:Ti},{Name:"Matcap",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nuniform sampler2D matCap;\nout vec4 color;\nvoid main() {\n\tvec3 n = normalize(vN);\n\tvec2 uv = n.xy * 0.5 + 0.5;\n\tuv.y = 1.0 - uv.y;\n\tvec3 clr = texture(matCap,uv.xy).rgb * vClr.rgb;\n\tcolor = vec4(clr, opacity);\n}"},{Name:"Rim",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n\tconst float thresh = 0.4;\n\tconst vec3 viewDir = vec3(0.0, 0.0, -1.0);\n\tvec3 n = normalize(vN);\n\t// use abs() for two-sided lighting, max() for one sided\n\tfloat cosTheta = abs(dot(n, viewDir));\n\t// float cosTheta = max(dot(n, viewDir), 0.0);\n\t// optional fresnel equation - adjust exponent\n\t// cosTheta = 1.0 - pow(1.0 - cosTheta, 2.0);\n\t// use step for binary edges, smoothstep for feathered edges\n\t// vec3 d = step(thresh, cosTheta) * vClr.rgb;\n\tvec3 d = smoothstep(thresh - 0.05, thresh + 0.05, cosTheta) * vClr.rgb;\n\tcolor = vec4(d, opacity);\n}"},{Name:"Silhouette",Frag:"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nin vec4 vClr;\nin vec3 vN;\nout vec4 color;\nvoid main() {\n  const float edge0 = 0.1;\n  const float edge1 = 0.25;\n  const vec3 viewDir = vec3(0.0, 0.0, -1.0);\n  vec3 n = normalize(vN);\n  float cosTheta = abs(dot(n, viewDir));\n  float alpha = 1.0 - smoothstep(edge0, edge1, cosTheta);\n  if (alpha <= 0.0) {\n    discard;\n  }\n  color = vec4(0.0, 0.0, 0.0, opacity * alpha);\n}"}]),M(this,"dragModes",{contrast:1,measurement:2,angle:7,none:0,pan:3,slicer3D:4,callbackOnly:5}),M(this,"sliceTypeAxial",0),M(this,"sliceTypeCoronal",1),M(this,"sliceTypeSagittal",2),M(this,"sliceTypeMultiplanar",3),M(this,"sliceTypeRender",4),M(this,"onDragRelease",(()=>{})),M(this,"onMouseUp",(()=>{})),M(this,"onLocationChange",(()=>{})),M(this,"onIntensityChange",(()=>{})),M(this,"onClickToSegment",(()=>{})),M(this,"onImageLoaded",(()=>{})),M(this,"onMeshLoaded",(()=>{})),M(this,"onFrameChange",(()=>{})),M(this,"onError",(()=>{})),M(this,"onColormapChange",(()=>{})),M(this,"onInfo",(()=>{})),M(this,"onWarn",(()=>{})),M(this,"onDebug",(()=>{})),M(this,"onVolumeAddedFromUrl",(()=>{})),M(this,"onVolumeWithUrlRemoved",(()=>{})),M(this,"onVolumeUpdated",(()=>{})),M(this,"onMeshAddedFromUrl",(()=>{})),M(this,"onMeshAdded",(()=>{})),M(this,"onMeshWithUrlRemoved",(()=>{})),M(this,"onZoom3DChange",(()=>{})),M(this,"onAzimuthElevationChange",(()=>{})),M(this,"onClipPlaneChange",(()=>{})),M(this,"onCustomMeshShaderAdded",(()=>{})),M(this,"onMeshShaderChanged",(()=>{})),M(this,"onMeshPropertyChanged",(()=>{})),M(this,"onDicomLoaderFinishedWithImages",(()=>{})),M(this,"onDocumentLoaded",(()=>{})),M(this,"onOptsChange",(()=>{})),M(this,"document",new Oe),M(this,"mediaUrlMap",new Map),M(this,"initialized",!1),M(this,"currentDrawUndoBitmap");for(const e in t)"function"==typeof t[e]?this[e]=t[e]:this.opts[e]=void 0===Le[e]?Le[e]:t[e];0===this.opts.forceDevicePixelRatio?this.uiData.dpr=window.devicePixelRatio||1:this.opts.forceDevicePixelRatio<0?this.uiData.dpr=1:this.uiData.dpr=this.opts.forceDevicePixelRatio,this.currentDrawUndoBitmap=this.opts.maxDrawUndoBitmaps,this.opts.drawingEnabled&&this.createEmptyDrawing(),this.opts.thumbnail.length>0&&(this.thumbnailVisible=!0),U.setLogLevel(this.opts.logLevel),this.document.setOptsChangeCallback(((t,e,i)=>{this.onOptsChange(t,e,i)}))}get scene(){return this.document.scene}get opts(){return this.document.opts}get sliceMosaicString(){return this.document.opts.sliceMosaicString||""}set sliceMosaicString(t){this.document.opts.sliceMosaicString=t}get isAlphaClipDark(){return this.document.opts.isAlphaClipDark}set isAlphaClipDark(t){this.document.opts.isAlphaClipDark=t}cleanup(){this.resizeEventListener&&(window.removeEventListener("resize",this.resizeEventListener),this.resizeEventListener=null),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),this.canvasObserver&&(this.canvasObserver.disconnect(),this.canvasObserver=null),I(this,zi)&&(I(this,zi).abort(),S(this,zi,null)),this.document.removeOptsChangeCallback()}get volumes(){return this.document.volumes}set volumes(t){this.document.volumes=t}get meshes(){return this.document.meshes}set meshes(t){this.document.meshes=t}get drawBitmap(){return this.document.drawBitmap}set drawBitmap(t){this.document.drawBitmap=t}get volScaleMultiplier(){return this.scene.volScaleMultiplier}set volScaleMultiplier(t){this.setScale(t)}async saveScene(t){void 0===t&&(t="niivue.png");const e=this.canvas;if(!e)throw new Error("canvas not defined");this.drawScene(),e.toBlob((e=>{e&&(""===t&&(t=(t=`niivue-screenshot-${(new Date).toString()}.png`).replace(/\s/g,"_")),function(t,e){const i=document.createElement("a");document.body.appendChild(i),i.style.display="none";const s=window.URL.createObjectURL(t);i.href=s,i.download=e,i.click(),i.remove()}(e,t))}))}async attachTo(t,e){return void 0===e&&(e=null),await this.attachToCanvas(document.getElementById(t),e),U.debug("attached to element with id: ",t),this}async attachToCanvas(t,e){return void 0===e&&(e=null),this.canvas=t,null===e&&(e=navigator.hardwareConcurrency>6,U.debug("AntiAlias ",e," Threads ",navigator.hardwareConcurrency)),this.gl=this.canvas.getContext("webgl2",{alpha:!0,antialias:e}),this.uiData.max2D=this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE),this.uiData.max3D=this.gl.getParameter(this.gl.MAX_3D_TEXTURE_SIZE),U.info("NIIVUE VERSION ",Qi),U.debug(`Max texture size 2D: ${this.uiData.max2D} 3D: ${this.uiData.max3D}`),this.canvas.parentElement.style.backgroundColor="black",this.opts.isResizeCanvas&&(this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.display="block",this.canvas.width=this.canvas.offsetWidth,this.canvas.height=this.canvas.offsetHeight,this.resizeEventListener=()=>{requestAnimationFrame((()=>{this.resizeListener()}))},window.addEventListener("resize",this.resizeEventListener),this.resizeObserver=new ResizeObserver((()=>{requestAnimationFrame((()=>{this.resizeListener()}))})),this.resizeObserver.observe(this.canvas.parentElement),this.canvasObserver=new MutationObserver((t=>{for(const e of t)if("childList"===e.type&&e.removedNodes.length>0&&Array.from(e.removedNodes).includes(this.canvas)){this.cleanup();break}})),this.canvasObserver.observe(this.canvas.parentElement,{childList:!0})),this.opts.interactive&&this.registerInteractions(),await this.init(),this.drawScene(),this}syncWith(t,e){void 0===e&&(e={"2d":!0,"3d":!0}),t instanceof Array||(t=[t]),this.otherNV=t,this.syncOpts={...e}}broadcastTo(t,e){void 0===e&&(e={"2d":!0,"3d":!0}),t instanceof Array||(t=[t]),this.otherNV=t,this.syncOpts=e}doSync3d(t){t.scene.renderAzimuth=this.scene.renderAzimuth,t.scene.renderElevation=this.scene.renderElevation,t.scene.volScaleMultiplier=this.scene.volScaleMultiplier}doSync2d(t){const e=this.frac2mm(this.scene.crosshairPos);t.scene.crosshairPos=t.mm2frac(e),t.scene.pan2Dxyzmm=s.o8(this.scene.pan2Dxyzmm)}doSyncGamma(t){const e=this.scene.gamma;e!==t.scene.gamma&&t.setGamma(e)}doSyncZoomPan(t){t.scene.pan2Dxyzmm=s.o8(this.scene.pan2Dxyzmm)}doSyncCrosshair(t){const e=this.frac2mm(this.scene.crosshairPos);t.scene.crosshairPos=t.mm2frac(e)}doSyncCalMin(t){this.volumes[0].cal_min!==t.volumes[0].cal_min&&(t.volumes[0].cal_min=this.volumes[0].cal_min,t.updateGLVolume())}doSyncCalMax(t){this.volumes[0].cal_max!==t.volumes[0].cal_max&&(t.volumes[0].cal_max=this.volumes[0].cal_max,t.updateGLVolume())}doSyncSliceType(t){t.setSliceType(this.opts.sliceType)}doSyncClipPlane(t){t.setClipPlane(this.scene.clipPlaneDepthAziElev)}sync(){if(this.gl&&this.otherNV&&void 0!==this.otherNV&&this.gl.canvas.matches(":focus"))for(let t=0;t<this.otherNV.length;t++)this.otherNV[t]!==this&&(this.syncOpts.gamma&&this.doSyncGamma(this.otherNV[t]),this.syncOpts.crosshair&&this.doSyncCrosshair(this.otherNV[t]),this.syncOpts.zoomPan&&this.doSyncZoomPan(this.otherNV[t]),this.syncOpts.sliceType&&this.doSyncSliceType(this.otherNV[t]),this.syncOpts.cal_min&&this.doSyncCalMin(this.otherNV[t]),this.syncOpts.cal_max&&this.doSyncCalMax(this.otherNV[t]),this.syncOpts.clipPlane&&this.doSyncClipPlane(this.otherNV[t]),this.syncOpts["2d"]&&this.doSync2d(this.otherNV[t]),this.syncOpts["3d"]&&this.doSync3d(this.otherNV[t]),this.otherNV[t].canvas!==this.canvas&&this.otherNV[t].drawScene(),this.otherNV[t].createOnLocationChange())}arrayEquals(t,e){return Array.isArray(t)&&Array.isArray(e)&&t.length===e.length&&t.every(((t,i)=>t===e[i]))}textSizePoints(){this.opts.textHeight>=0&&(U.warn("textHeight is deprecated (use fontMinPx and fontSizeScaling)"),this.opts.fontMinPx=217*this.opts.textHeight,this.opts.fontSizeScaling=.4,this.opts.textHeight=-1);const t=this.uiData.dpr||1,e=this.opts.fontMinPx,i=this.gl.canvas.width/t,s=this.gl.canvas.height/t,r=i*s,n=Math.max(r/48e4,1),o=Math.pow(n,this.opts.fontSizeScaling),a=e*o*t;this.fontPx=a,U.debug(`${i.toFixed(0)}x${s.toFixed(0)} pts (dpi=${t}) => areaScale=${n.toFixed(2)}, scale=${o.toFixed(2)}, minPx=${this.opts.fontMinPx} fontScale=${this.opts.fontSizeScaling} fontPx=${a.toFixed(2)}`)}resizeListener(){if(this.canvas&&this.gl){if(!this.opts.isResizeCanvas)return this.opts.forceDevicePixelRatio>=0&&U.warn("this.opts.forceDevicePixelRatio requires isResizeCanvas"),void this.drawScene();this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.display="block",0===this.opts.forceDevicePixelRatio?this.uiData.dpr=window.devicePixelRatio||1:this.opts.forceDevicePixelRatio<0?this.uiData.dpr=1:this.uiData.dpr=this.opts.forceDevicePixelRatio,U.debug("devicePixelRatio: "+this.uiData.dpr),"width"in this.canvas.parentElement?(this.canvas.width=this.canvas.parentElement.width*this.uiData.dpr,this.canvas.height=this.canvas.parentElement.height*this.uiData.dpr):(this.canvas.width=this.canvas.offsetWidth*this.uiData.dpr,this.canvas.height=this.canvas.offsetHeight*this.uiData.dpr),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.textSizePoints(),this.drawScene()}}getRelativeMousePosition(t,e){if(!(e=e||t.target))return;const i=e.getBoundingClientRect();return{x:t.clientX-i.left,y:t.clientY-i.top}}getNoPaddingNoBorderCanvasRelativeMousePosition(t,e){e=e||t.target;return this.getRelativeMousePosition(t,e)}mouseContextMenuListener(t){t.preventDefault()}mouseDownListener(t){if(this.uiData.mousedown=!0,!this.eventInBounds(t))return this.opts.showBoundsBorder=!1,void this.drawScene();this.opts.bounds&&(this.opts.showBoundsBorder=!0),t.preventDefault(),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawShapeStartLocation=[NaN,NaN,NaN];const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(7===this.opts.dragMode&&"drawing_second_line"===this.uiData.angleState||(this.setDragStart(e.x,e.y),this.setDragEnd(e.x,e.y)),U.debug("mouse down"),U.debug(t),!e)return;const[i,s]=[e.x*this.uiData.dpr,e.y*this.uiData.dpr];this.opts.clickToSegment&&(this.clickToSegmentXY=[i,s]);const r=this.getLabelAtPoint([i,s]);if(r){if(r.onClick)return void r.onClick(r,t);for(const t of this.meshes)if("connectome"===t.type)for(const e of t.nodes)e.label===r&&(this.scene.crosshairPos=this.mm2frac([e.x,e.y,e.z]),this.updateGLVolume());else if(Array.isArray(r.points)&&3===r.points.length&&r.points.every(Number.isFinite)){const[t,e,i]=r.points;this.scene.crosshairPos=this.mm2frac([t,e,i]),this.updateGLVolume()}}this.uiData.clickedTile=this.tileIndex(i,s),0===t.button&&t.shiftKey?(this.uiData.mouseButtonCenterDown=!0,this.setActiveDragMode(0,!0,t.ctrlKey),this.handleMouseAction(this.uiData.activeDragMode,t,e)):0===t.button?(this.uiData.mouseButtonLeftDown=!0,this.setActiveDragMode(0,!1,t.ctrlKey),this.handleMouseAction(this.uiData.activeDragMode,t,e)):2===t.button?(this.uiData.mouseButtonRightDown=!0,this.setActiveDragMode(2,t.shiftKey,t.ctrlKey),this.handleMouseAction(this.uiData.activeDragMode,t,e)):1===t.button&&(this.uiData.mouseButtonCenterDown=!0,this.setActiveDragMode(1,t.shiftKey,t.ctrlKey),this.handleMouseAction(this.uiData.activeDragMode,t,e)),this.drawScene()}getMouseButtonDragMode(t,e,i){const s=this.opts.mouseEventConfig;return 0===t?s?.leftButton?e&&void 0!==s.leftButton.withShift?s.leftButton.withShift:i&&void 0!==s.leftButton.withCtrl?s.leftButton.withCtrl:s.leftButton.primary:i?8:this.opts.dragModePrimary:2===t?void 0!==s?.rightButton?s.rightButton:this.opts.dragMode:1===t&&void 0!==s?.centerButton?s.centerButton:this.opts.dragMode}getTouchDragMode(t){const e=this.opts.touchEventConfig;return t?e?.doubleTouch??this.opts.dragMode:e?.singleTouch??this.opts.dragModePrimary}setActiveDragMode(t,e,i){this.uiData.activeDragMode=this.getMouseButtonDragMode(t,e,i),this.uiData.activeDragButton=t}getCurrentDragMode(){return null!==this.uiData.activeDragMode?this.uiData.activeDragMode:this.opts.dragMode}clearActiveDragMode(){this.uiData.activeDragMode=null,this.uiData.activeDragButton=null}handleMouseAction(t,e,i){if(8===t)this.mouseDown(i.x,i.y),this.mouseClick(i.x,i.y);else if(9===t)this.uiData.windowX=e.x,this.uiData.windowY=e.y;else{if(this.mousePos=[i.x*this.uiData.dpr,i.y*this.uiData.dpr],0===t)return;if(7===t)if("none"===this.uiData.angleState)this.uiData.angleState="drawing_first_line";else{if("drawing_second_line"===this.uiData.angleState){const t=[i.x*this.uiData.dpr,i.y*this.uiData.dpr],e=this.tileIndex(t[0],t[1]);let s={sliceIndex:-1,sliceType:0,slicePosition:0};if(e>=0&&e<this.screenSlices.length){const t=this.screenSlices[e].axCorSag;let i=0;0===t?i=this.scene.crosshairPos[2]:1===t?i=this.scene.crosshairPos[1]:2===t&&(i=this.scene.crosshairPos[0]),s={sliceIndex:e,sliceType:t,slicePosition:i}}const n=[this.uiData.angleFirstLine[2],this.uiData.angleFirstLine[3],t[0],t[1]],o=this.canvasPos2frac([this.uiData.angleFirstLine[0],this.uiData.angleFirstLine[1]]),a=this.canvasPos2frac([this.uiData.angleFirstLine[2],this.uiData.angleFirstLine[3]]),l=this.canvasPos2frac([n[0],n[1]]),h=this.canvasPos2frac([n[2],n[3]]);if(o[0]>=0&&a[0]>=0&&l[0]>=0&&h[0]>=0){const t=this.frac2mm(o),e=this.frac2mm(a),i=this.frac2mm(l),c=this.frac2mm(h),d={firstLineMM:{start:r.fA(t[0],t[1],t[2]),end:r.fA(e[0],e[1],e[2])},secondLineMM:{start:r.fA(i[0],i[1],i[2]),end:r.fA(c[0],c[1],c[2])},sliceIndex:s.sliceIndex,sliceType:s.sliceType,slicePosition:s.slicePosition,angle:this.calculateAngleBetweenLines(this.uiData.angleFirstLine,n)};this.document.completedAngles.push(d)}return this.resetAngleMeasurement(),this.uiData.angleState="complete",void this.drawScene()}"complete"===this.uiData.angleState&&(this.resetAngleMeasurement(),this.uiData.angleState="drawing_first_line")}this.setDragStart(i.x,i.y),this.uiData.isDragging||(this.uiData.pan2DxyzmmAtMouseDown=s.o8(this.scene.pan2Dxyzmm)),this.uiData.isDragging=!0,this.uiData.dragClipPlaneStartDepthAziElev=this.scene.clipPlaneDepthAziElev}}calculateMinMaxVoxIdx(t){if(t.length>2)throw new Error("array must not contain more than two values");return[Math.floor(Math.min(t[0],t[1])),Math.floor(Math.max(t[0],t[1]))]}calculateNewRange(t){let{volIdx:e=0}=void 0===t?{}:t;if(4===this.opts.sliceType&&this.sliceMosaicString.length<1)return;if(this.uiData.dragStart[0]===this.uiData.dragEnd[0]&&this.uiData.dragStart[1]===this.uiData.dragEnd[1])return;let i=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]);if(i[0]<0)return;const s=this.frac2vox(i,e);if(i=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]),i[0]<0)return;const r=this.frac2vox(i,e);let n=-Number.MAX_VALUE,o=Number.MAX_VALUE;const a=this.calculateMinMaxVoxIdx([s[0],r[0]]),l=this.calculateMinMaxVoxIdx([s[1],r[1]]),h=this.calculateMinMaxVoxIdx([s[2],r[2]]);s[0]-r[0]==0?a[1]=s[0]+1:s[1]-r[1]==0?l[1]=s[1]+1:s[2]-r[2]==0&&(h[1]=s[2]+1);const c=this.volumes[e].hdr,d=this.volumes[e].img;if(!c||!d)return;const m=c.dims[1],u=c.dims[2];for(let A=h[0];A<h[1];A++){const t=A*m*u;for(let e=l[0];e<l[1];e++){const i=e*m;for(let e=a[0];e<a[1];e++){const s=t+i+e;o>d[s]&&(o=d[s]),n<d[s]&&(n=d[s])}}}if(o>=n)return;const f=Pi(c,o),g=Pi(c,n);this.volumes[e].cal_min=f,this.volumes[e].cal_max=g,this.onIntensityChange(this.volumes[e])}generateMouseUpCallback(t,e){const i=this.tileIndex(this.uiData.dragStart[0],this.uiData.dragStart[1]),s=this.tileIndex(this.uiData.dragEnd[0],this.uiData.dragEnd[1]);let n=-1;i===s&&(n=s);let o=-1;n>=0&&(o=this.screenSlices[n].axCorSag);const a=this.frac2mm(t),l=this.frac2mm(e),h=r.vt();r.jb(h,r.fA(a[0],a[1],a[2]),r.fA(l[0],l[1],l[2]));const c=r.Il(h),d=this.frac2vox(t),m=this.frac2vox(e);this.onDragRelease({fracStart:t,fracEnd:e,voxStart:d,voxEnd:m,mmStart:a,mmEnd:l,mmLength:c,tileIdx:n,axCorSag:o})}mouseUpListener(){this.uiData.mousedown=!1;const t={mouseButtonRightDown:this.uiData.mouseButtonRightDown,mouseButtonCenterDown:this.uiData.mouseButtonCenterDown,isDragging:this.uiData.isDragging,mousePos:this.mousePos,fracPos:this.canvasPos2frac(this.mousePos)};this.uiData.mouseButtonRightDown=!1;const e=this.uiData.mouseButtonCenterDown;this.uiData.mouseButtonCenterDown=!1,this.uiData.mouseButtonLeftDown=!1;const i=this.getCurrentDragMode();var s;if(this.drawPenFillPts.length>0?this.drawPenFilled():this.opts.drawingEnabled&&!isNaN(this.drawPenLocation[0])?this.drawAddUndoBitmap():!this.opts.drawingEnabled||isNaN(this.drawShapeStartLocation[0])||1!==this.opts.penType&&2!==this.opts.penType||(0===this.opts.penValue?this.drawAddUndoBitmap():this.drawAddUndoBitmap(this.drawFillOverwrites),this.drawShapePreviewBitmap=null),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawShapeStartLocation=[NaN,NaN,NaN],this.drawShapePreviewBitmap&&(this.drawBitmap=this.drawShapePreviewBitmap,this.drawShapePreviewBitmap=null,this.refreshDrawing(!0,!1)),s=this.onMouseUp,Object.prototype.toString.call(s).indexOf("Function")>-1&&this.onMouseUp(t),this.uiData.isDragging){if(this.uiData.isDragging=!1,7===i){if("drawing_first_line"===this.uiData.angleState)return this.uiData.angleFirstLine=[this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]],this.uiData.angleState="drawing_second_line",this.uiData.isDragging=!0,void this.drawScene();if("drawing_second_line"===this.uiData.angleState)return this.uiData.angleState="complete",this.clearActiveDragMode(),void this.drawScene()}5===i&&this.drawScene();const t=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]),s=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(this.generateMouseUpCallback(t,s),6===i)return void this.clearActiveDragMode();if(1===i){if(e)return void this.clearActiveDragMode();if(this.uiData.dragStart[0]===this.uiData.dragEnd[0]&&this.uiData.dragStart[1]===this.uiData.dragEnd[1])return void this.clearActiveDragMode();this.calculateNewRange({volIdx:0}),this.refreshLayers(this.volumes[0],0)}if(2===i){const t=this.getCurrentSliceInfo(),e=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]),i=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(e[0]>=0&&i[0]>=0){const s=this.frac2mm(e),n=this.frac2mm(i);this.document.completedMeasurements.push({startMM:r.fA(s[0],s[1],s[2]),endMM:r.fA(n[0],n[1],n[2]),sliceIndex:t.sliceIndex,sliceType:t.sliceType,slicePosition:t.slicePosition,distance:r.Io(r.fA(s[0],s[1],s[2]),r.fA(n[0],n[1],n[2]))})}return this.clearActiveDragMode(),void this.drawScene()}}this.clearActiveDragMode(),this.drawScene()}checkMultitouch(t){if(this.uiData.touchdown&&!this.uiData.multiTouchGesture){const e=this.canvas.getBoundingClientRect();this.mouseDown(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top),this.mouseClick(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top)}}touchStartListener(t){t.preventDefault(),this.uiData.touchTimer||(this.uiData.touchTimer=setTimeout((()=>{this.resetBriCon(t)}),this.opts.longTouchTimeout)),this.uiData.touchdown=!0,this.uiData.currentTouchTime=(new Date).getTime();const e=this.uiData.currentTouchTime-this.uiData.lastTouchTime;if(e<this.opts.doubleTouchTimeout&&e>0)return this.uiData.doubleTouch=!0,this.setDragStart(t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,t.targetTouches[0].clientY-t.target.getBoundingClientRect().top),this.resetBriCon(t),void(this.uiData.lastTouchTime=this.uiData.currentTouchTime);this.uiData.doubleTouch=!1,this.setDragStart(0,0),this.setDragEnd(0,0),this.uiData.lastTouchTime=this.uiData.currentTouchTime,this.uiData.touchdown&&t.touches.length<2?this.uiData.multiTouchGesture=!1:this.uiData.multiTouchGesture=!0,setTimeout(this.checkMultitouch.bind(this),1,t)}touchEndListener(t){if(t.preventDefault(),this.uiData.touchdown=!1,this.uiData.lastTwoTouchDistance=0,this.uiData.multiTouchGesture=!1,this.uiData.touchTimer&&(clearTimeout(this.uiData.touchTimer),this.uiData.touchTimer=null),this.uiData.isDragging){this.uiData.isDragging=!1,1===this.getCurrentDragMode()&&(this.calculateNewRange(),this.refreshLayers(this.volumes[0],0));const t=this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]]),e=this.canvasPos2frac([this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);this.generateMouseUpCallback(t,e)}this.mouseUpListener()}windowingHandler(t,e,i){void 0===i&&(i=0);const s=this.uiData.windowX,r=this.uiData.windowY;let n=this.volumes[0].cal_min,o=this.volumes[0].cal_max;const a=this.volumes[0].global_min,l=this.volumes[0].global_max;e<r?(n+=1,o+=1):e>r&&(n-=1,o-=1),t>s?(n-=1,o+=1):t<s&&(n+=1,o-=1),o-n<1&&(o=n+1),n<a&&(n=a),o>l&&(o=l),n>o&&(n=o-1),this.volumes[i].cal_min=n,this.volumes[i].cal_max=o,this.refreshLayers(this.volumes[i],0),this.uiData.windowX=t,this.uiData.windowY=e}mouseLeaveListener(){this.clickToSegmentIsGrowing&&(U.debug("Mouse left canvas, stopping clickToSegment preview."),this.clickToSegmentIsGrowing=!1,this.refreshDrawing(!0,!1)),this.opts.drawingEnabled&&!isNaN(this.drawPenLocation[0])&&(U.debug("Mouse left canvas during drawing, resetting pen state."),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawPenFillPts=[]),this.opts.drawingEnabled&&!isNaN(this.drawShapeStartLocation[0])&&(U.debug("Mouse left canvas during shape drawing, resetting shape state."),this.drawShapeStartLocation=[NaN,NaN,NaN],this.drawShapePreviewBitmap&&(this.drawBitmap=this.drawShapePreviewBitmap,this.drawShapePreviewBitmap=null,this.refreshDrawing(!0,!1))),(this.uiData.isDragging||this.uiData.mousedown)&&(U.debug("Mouse left canvas during drag, resetting drag state."),this.uiData.isDragging=!1,this.uiData.mouseButtonLeftDown=!1,this.uiData.mouseButtonCenterDown=!1,this.uiData.mouseButtonRightDown=!1,this.uiData.mousedown=!1,this.drawScene()),this.mousePos=[-1,-1]}mouseMoveListener(t){this.uiData.mousedown&&this.drawScene();const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(e)if(this.eventInBounds(t)){if(this.uiData.mousedown){const t=e.x*this.uiData.dpr,i=e.y*this.uiData.dpr;if(this.tileIndex(t,i)!==this.uiData.clickedTile)return;const s=this.getCurrentDragMode();if(8===s)return this.mouseMove(e.x,e.y),this.mouseClick(e.x,e.y),this.drawScene(),this.uiData.prevX=this.uiData.currX,void(this.uiData.prevY=this.uiData.currY);if(9===s)return this.windowingHandler(e.x,e.y),this.drawScene(),this.uiData.prevX=this.uiData.currX,void(this.uiData.prevY=this.uiData.currY);this.setDragEnd(e.x,e.y),this.drawScene(),this.uiData.prevX=this.uiData.currX,this.uiData.prevY=this.uiData.currY}else if(7===this.getCurrentDragMode()&&"drawing_second_line"===this.uiData.angleState){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(!e)return;this.setDragEnd(e.x,e.y),this.drawScene()}else if(!this.uiData.mousedown&&this.opts.clickToSegment){const e=this.getNoPaddingNoBorderCanvasRelativeMousePosition(t,this.gl.canvas);if(!e)return;const i=e.x*this.uiData.dpr,s=e.y*this.uiData.dpr;this.mousePos=[i,s];const r=this.tileIndex(i,s);if(r>=0&&this.opts.drawingEnabled){this.screenSlices[r].axCorSag<=2&&(this.clickToSegmentXY=[i,s],this.clickToSegmentIsGrowing=!0,this.doClickToSegment({x:i,y:s,tileIndex:r}))}}}else this.updateMousePos(e.x,e.y)}resetBriCon(t){if(void 0===t&&(t=null),this.uiData.isDragging)return;if(!this.eventInBounds(t))return void(this.opts.showBoundsBorder=!1);let e=!1;4===this.opts.sliceType&&(e=!0);let i=0,s=0;if(null!==t&&("targetTouches"in t?(i=t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,s=t.targetTouches[0].clientY-t.target.getBoundingClientRect().top):(i=t.offsetX,s=t.offsetY),i*=this.uiData.dpr,s*=this.uiData.dpr,this.inRenderTile(i,s)>=0&&(e=!0)),e)return this.uiData.mouseDepthPicker=!0,this.drawScene(),void this.drawScene();4!==this.getCurrentDragMode()&&(this.volumes.length<1||this.uiData.doubleTouch||(this.volumes[0].cal_min=this.volumes[0].robust_min,this.volumes[0].cal_max=this.volumes[0].robust_max,this.onIntensityChange(this.volumes[0]),this.refreshLayers(this.volumes[0],0),this.drawScene()))}setDragStart(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.uiData.dragStart[0]=t,this.uiData.dragStart[1]=e}setDragEnd(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.uiData.dragEnd[0]=t,this.uiData.dragEnd[1]=e}touchMoveListener(t){if(this.uiData.touchdown&&t.touches.length<2){const e=this.canvas.getBoundingClientRect();if(this.uiData.isDragging||(this.uiData.pan2DxyzmmAtMouseDown=s.o8(this.scene.pan2Dxyzmm)),this.uiData.isDragging=!0,this.uiData.doubleTouch&&this.uiData.isDragging)return this.setDragEnd(t.targetTouches[0].clientX-t.target.getBoundingClientRect().left,t.targetTouches[0].clientY-t.target.getBoundingClientRect().top),void this.drawScene();const i=this.getTouchDragMode(!1);8===i?(this.mouseClick(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top),this.mouseMove(t.touches[0].clientX-e.left,t.touches[0].clientY-e.top)):9===i&&(this.windowingHandler(t.touches[0].pageX,t.touches[0].pageY),this.drawScene())}else this.handlePinchZoom(t)}handlePinchZoom(t){if(2===t.targetTouches.length&&2===t.changedTouches.length){const e=Math.hypot(t.touches[0].pageX-t.touches[1].pageX,t.touches[0].pageY-t.touches[1].pageY),i=this.canvas.getBoundingClientRect();this.mousePos=[t.touches[0].clientX-i.left,t.touches[0].clientY-i.top],e<this.uiData.lastTwoTouchDistance?this.sliceScroll2D(-.01,t.touches[0].clientX-i.left,t.touches[0].clientY-i.top):this.sliceScroll2D(.01,t.touches[0].clientX-i.left,t.touches[0].clientY-i.top),this.uiData.lastTwoTouchDistance=e}}keyUpListener(t){if(!this.cursorInBounds())return this.opts.showBoundsBorder=!1,void this.drawScene();if(t.code===this.opts.clipPlaneHotKey){const t=(new Date).getTime();if(t-this.lastCalled>this.opts.keyDebounceTime){switch(this.currentClipPlaneIndex=(this.currentClipPlaneIndex+1)%7,this.currentClipPlaneIndex){case 0:this.scene.clipPlaneDepthAziElev=[2,0,0];break;case 1:this.scene.clipPlaneDepthAziElev=[0,270,0];break;case 2:this.scene.clipPlaneDepthAziElev=[0,90,0];break;case 3:this.scene.clipPlaneDepthAziElev=[0,0,0];break;case 4:this.scene.clipPlaneDepthAziElev=[0,180,0];break;case 5:this.scene.clipPlaneDepthAziElev=[0,0,-90];break;case 6:this.scene.clipPlaneDepthAziElev=[0,0,90]}this.setClipPlane(this.scene.clipPlaneDepthAziElev)}this.lastCalled=t}else if(t.code===this.opts.viewModeHotKey){const t=(new Date).getTime();t-this.lastCalled>this.opts.keyDebounceTime&&(this.setSliceType((this.opts.sliceType+1)%5),this.lastCalled=t)}this.drawScene()}keyDownListener(t){if(!this.cursorInBounds())return this.opts.showBoundsBorder=!1,void this.drawScene();"KeyH"===t.code&&4===this.opts.sliceType?this.setRenderAzimuthElevation(this.scene.renderAzimuth-1,this.scene.renderElevation):"KeyL"===t.code&&4===this.opts.sliceType?this.setRenderAzimuthElevation(this.scene.renderAzimuth+1,this.scene.renderElevation):"KeyJ"===t.code&&4===this.opts.sliceType?this.setRenderAzimuthElevation(this.scene.renderAzimuth,this.scene.renderElevation+1):"KeyK"===t.code&&4===this.opts.sliceType?this.setRenderAzimuthElevation(this.scene.renderAzimuth,this.scene.renderElevation-1):"KeyH"===t.code&&4!==this.opts.sliceType?this.moveCrosshairInVox(-1,0,0):"KeyL"===t.code&&4!==this.opts.sliceType?this.moveCrosshairInVox(1,0,0):"KeyU"===t.code&&4!==this.opts.sliceType&&t.ctrlKey?this.moveCrosshairInVox(0,0,1):"KeyD"===t.code&&4!==this.opts.sliceType&&t.ctrlKey?this.moveCrosshairInVox(0,0,-1):"KeyJ"===t.code&&4!==this.opts.sliceType?this.moveCrosshairInVox(0,-1,0):"KeyK"===t.code&&4!==this.opts.sliceType?this.moveCrosshairInVox(0,1,0):"KeyM"===t.code&&4!==this.opts.sliceType?(this.opts.dragMode++,this.opts.dragMode>=4&&(this.opts.dragMode=0),U.info("drag mode changed to ",Pe[this.opts.dragMode])):"ArrowLeft"===t.code?this.setFrame4D(this.volumes[0].id,this.volumes[0].frame4D-1):"ArrowRight"===t.code?this.setFrame4D(this.volumes[0].id,this.volumes[0].frame4D+1):"Slash"===t.code&&t.shiftKey&&alert(`NIIVUE VERSION: ${Qi}`),this.drawScene()}wheelListener(t){if(this.thumbnailVisible)return;if(this.opts.sliceMosaicString.length>0)return;if(!this.eventInBounds(t))return this.opts.showBoundsBorder=!1,void this.drawScene();this.opts.bounds&&(this.opts.showBoundsBorder=!0),t.preventDefault(),t.stopPropagation();const e=this.uiData.dragStart.reduce(((t,e)=>t+e),0),i=this.uiData.dragEnd.reduce(((t,e)=>t+e),0),s=e>0&&i>0;if(6===this.getCurrentDragMode()&&s){const e=t.deltaY>0?1:-1;this.uiData.dragStart[0]<this.uiData.dragEnd[0]?(this.uiData.dragStart[0]-=e,this.uiData.dragEnd[0]+=e):(this.uiData.dragStart[0]+=e,this.uiData.dragEnd[0]-=e),this.uiData.dragStart[1]<this.uiData.dragEnd[1]?(this.uiData.dragStart[1]-=e,this.uiData.dragEnd[1]+=e):(this.uiData.dragStart[1]+=e,this.uiData.dragEnd[1]-=e),this.uiData.isDragging=!0,this.drawScene(),this.uiData.isDragging=!1;const i=this.tileIndex(this.uiData.dragStart[0],this.uiData.dragStart[1]);return void(i>=0?this.generateMouseUpCallback(this.screenXY2TextureFrac(this.uiData.dragStart[0],this.uiData.dragStart[1],i),this.screenXY2TextureFrac(this.uiData.dragEnd[0],this.uiData.dragEnd[1],i)):U.warn("Could not generate drag release callback for ROI selection: Invalid tile index."))}let r=t.deltaY<0?-.01:.01;if(this.opts.invertScrollDirection&&(r=-r),this.opts.clickToSegment){r<0?(this.opts.clickToSegmentPercent-=.01,this.opts.clickToSegmentPercent=Math.max(this.opts.clickToSegmentPercent,0)):(this.opts.clickToSegmentPercent+=.01,this.opts.clickToSegmentPercent=Math.min(this.opts.clickToSegmentPercent,1));const t=this.clickToSegmentXY[0],e=this.clickToSegmentXY[1],i=this.tileIndex(t,e);return void(i>=0&&this.screenSlices[i].axCorSag<=2&&(U.debug(`Adjusting clickToSegment threshold: ${this.opts.clickToSegmentPercent.toFixed(3)}`),this.clickToSegmentIsGrowing=!0,this.doClickToSegment({x:t,y:e,tileIndex:i})))}const n=this.canvas.getBoundingClientRect(),o=t.clientX-n.left,a=t.clientY-n.top;if(3===this.getCurrentDragMode()&&-1===this.inRenderTile(this.uiData.dpr*o,this.uiData.dpr*a)){const t=r<0?1:-1;let e=this.scene.pan2Dxyzmm[3]*(1+.01*t*10);e=Math.round(10*e)/10;const i=this.scene.pan2Dxyzmm[3]-e;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=e),this.scene.pan2Dxyzmm[3]=e;const s=this.frac2mm(this.scene.crosshairPos);return this.scene.pan2Dxyzmm[0]+=i*s[0],this.scene.pan2Dxyzmm[1]+=i*s[1],this.scene.pan2Dxyzmm[2]+=i*s[2],this.drawScene(),this.canvas.focus(),void this.sync()}this.sliceScroll2D(r,o,a)}registerInteractions(){if(!this.canvas)throw new Error("canvas undefined");S(this,zi,new AbortController);const{signal:t}=I(this,zi);this.canvas.addEventListener("mousedown",this.mouseDownListener.bind(this),{signal:t}),this.canvas.addEventListener("mouseup",this.mouseUpListener.bind(this),{signal:t}),this.canvas.addEventListener("mousemove",this.mouseMoveListener.bind(this),{signal:t}),this.canvas.addEventListener("mouseleave",this.mouseLeaveListener.bind(this),{signal:t}),this.canvas.addEventListener("touchstart",this.touchStartListener.bind(this),{signal:t}),this.canvas.addEventListener("touchend",this.touchEndListener.bind(this),{signal:t}),this.canvas.addEventListener("touchmove",this.touchMoveListener.bind(this),{signal:t}),this.canvas.addEventListener("wheel",this.wheelListener.bind(this),{signal:t}),this.canvas.addEventListener("contextmenu",this.mouseContextMenuListener.bind(this),{signal:t}),this.canvas.addEventListener("dblclick",this.resetBriCon.bind(this),{signal:t}),this.canvas.addEventListener("dragenter",this.dragEnterListener.bind(this),{signal:t}),this.canvas.addEventListener("dragover",this.dragOverListener.bind(this),{signal:t}),this.canvas.addEventListener("drop",(t=>{this.dropListener(t).catch(console.error)}),{signal:t}),this.canvas.setAttribute("tabindex","0"),this.canvas.addEventListener("keyup",this.keyUpListener.bind(this),{signal:t}),this.canvas.addEventListener("keydown",this.keyDownListener.bind(this),{signal:t})}dragEnterListener(t){t.stopPropagation(),t.preventDefault()}dragOverListener(t){t.stopPropagation(),t.preventDefault()}getFileExt(t,e){void 0===e&&(e=!0),U.debug("fullname: ",t);const i=/(?:\.([^.]+))?$/;let s=i.exec(t)[1];if(s=s.toUpperCase(),"GZ"===s)s=i.exec(t.slice(0,-3))[1],s=s.toUpperCase();else if("CBOR"===s){const e=s;s=i.exec(t.slice(0,-5))[1],s=s.toUpperCase(),s=`${s}.${e}`}return e?s:s.toLowerCase()}async addVolumeFromUrl(t){const e=await Ve.loadFromUrl(t);return this.document.addImageOptions(e,t),e.onColormapChange=this.onColormapChange,this.mediaUrlMap.set(e,t.url),this.onVolumeAddedFromUrl&&this.onVolumeAddedFromUrl(t,e),this.addVolume(e),e}async addVolumesFromUrl(t){const e=t.map((async t=>{const e=this.getFileExt(t.name||t.url);if("DCM"===e)throw new Error("DICOM files must be loaded using useDicomLoader");if(this.loaders[e]){let i=t.url;const s=this.loaders[e].toExt;let n=t.name||t.url;if(n=n.split("/").pop(),"string"==typeof t.url){const e=t.url;try{const t=await fetch(e);if(!t.ok)throw new Error(`Failed to load file: ${t.statusText}`);i=await t.arrayBuffer()}catch(r){throw new Error(`Failed to load url ${e}: ${r}`)}}const o=await this.loaders[e].loader(i);t.url=o,t.name=`${n}.${s}`}const i={url:t.url,headers:t.headers,name:t.name,colormap:t.colormap?t.colormap:t.colorMap,colormapNegative:t.colormapNegative?t.colormapNegative:t.colorMapNegative,opacity:t.opacity,urlImgData:t.urlImgData,cal_min:t.cal_min,cal_max:t.cal_max,trustCalMinMax:this.opts.trustCalMinMax,isManifest:t.isManifest,frame4D:t.frame4D,limitFrames4D:t.limitFrames4D||this.opts.limitFrames4D,colorbarVisible:t.colorbarVisible},s=await Ve.loadFromUrl(i);return this.document.addImageOptions(s,i),s.onColormapChange=this.onColormapChange,this.mediaUrlMap.set(s,i.url),this.onVolumeAddedFromUrl&&this.onVolumeAddedFromUrl(i,s),s})),i=await Promise.all(e);for(let s=0;s<i.length;s++)this.addVolume(i[s]);return i}getMediaByUrl(t){return[...this.mediaUrlMap.entries()].filter((e=>e[1]===t)).map((t=>t[0])).pop()}removeVolumeByUrl(t){const e=this.getMediaByUrl(t);if(!e)throw new Error("No volume with URL present");this.removeVolume(e)}async traverseFileTree(t,e,i){return void 0===e&&(e=""),new Promise((s=>{if(t.isFile)t.file((t=>{t.fullPath=e+t.name,t._webkitRelativePath=e+t.name,i.push(t),s(i)}));else if(t.isDirectory){const r=t.createReader(),n=()=>{r.readEntries((r=>{if(r.length>0){const s=[];for(const n of r)s.push(this.traverseFileTree(n,e+t.name+"/",i));Promise.all(s).then(n).catch((t=>{throw t}))}else s(i)}))};n()}}))}readDirectory(t){const e=t.createReader();let i=[];const s=()=>{e.readEntries((t=>{t.length?(i=i.concat(t),s()):(async t=>{const e=[],i=async t=>new Promise(((e,i)=>t.file(e,i)));for(let s=0;s<t.length;s++)e.push(await i(t[s]));return e})(i).then((async()=>{})).catch((t=>{throw t}))}))};return s(),i}isMeshExt(t){const e=this.getFileExt(t);return U.debug("dropped ext"),U.debug(e),Xi.includes(e)}async loadFromArrayBuffer(t,e){const i=this.getFileExt(e);if(Xi.includes(i))return void await this.addMeshFromUrl({url:e,buffer:t});const s=fe(e);s.buffer=t,s.name=e,await this.addVolumeFromUrl(s)}async loadFromFile(t){const e=this.getFileExt(t.name);Xi.includes(e)?await Ge.loadFromFile({file:t,gl:this.gl,name:t.name}).then((t=>{this.addMesh(t)})):await Ve.loadFromFile({file:t,name:t.name}).then((t=>{this.addVolume(t)}))}useLoader(t,e,i){this.loaders={...this.loaders,[e.toUpperCase()]:{loader:t,toExt:i}}}useDicomLoader(t){this.dicomLoader=t}getDicomLoader(){return this.dicomLoader}async dropListener(t){if(!this.eventInBounds(t))return void(this.opts.showBoundsBorder=!1);if(this.opts.bounds&&(this.opts.showBoundsBorder=!0),t.stopPropagation(),t.preventDefault(),!this.opts.dragAndDropEnabled)return;const e=[],i=[],s=t.dataTransfer;if(!s)return;const r=s.getData("text/uri-list");if(r){e.push(r);const t=fe(r),i=this.getFileExt(r);U.debug("dropped ext"),U.debug(i),Xi.includes(i)?this.addMeshFromUrl({url:r}).catch((t=>{throw t})):"NVD"===i?this.loadDocumentFromUrl(r).catch((t=>{throw t})):this.addVolumeFromUrl(t).catch((t=>{throw t}))}else{const e=s.items;if(e.length>0){t.shiftKey||t.altKey||(this.volumes=[],this.overlays=[],this.meshes=[]),this.closeDrawing(),this.closePAQD();for(const s of Array.from(e)){const r=s.webkitGetAsEntry();if(U.debug(r),!r)throw new Error("could not get entry from file");if(r.isFile){const i=this.getFileExt(r.name);let s;if(-1!==r.name.lastIndexOf("HEAD"))for(const t of Array.from(e)){const e=t.webkitGetAsEntry();if(!e)throw new Error("could not get paired entry");r.name.substring(0,r.name.lastIndexOf("HEAD"))===e.name.substring(0,e.name.lastIndexOf("BRIK"))&&(s=e)}if(-1!==r.name.lastIndexOf("BRIK"))continue;if(this.loaders[i]){const t=await Ni(r);await this.loadImages([{url:t,name:`${r.name}`}]);continue}if(Xi.includes(i)){r.file((t=>{(async()=>{try{const e=await Ge.loadFromFile({file:t,gl:this.gl,name:t.name});this.addMesh(e)}catch(e){console.error("Error loading mesh:",e)}})().catch((t=>console.error(t)))}));continue}if("NVD"===i){r.file((t=>{(async()=>{try{const e=await Oe.loadFromFile(t);await this.loadDocument(e),U.debug("loaded document")}catch(e){console.error(e)}})().catch((t=>console.error(t)))}));break}r.file((e=>{(async()=>{try{if(s)s.file((t=>{(async()=>{try{const i=await Ve.loadFromFile({file:e,urlImgData:t,limitFrames4D:this.opts.limitFrames4D});this.addVolume(i)}catch(i){console.error(i)}})().catch(console.error)}));else{const i=await Ve.loadFromFile({file:e,urlImgData:s,limitFrames4D:this.opts.limitFrames4D});t.altKey?(U.debug("alt key detected: assuming this is a drawing overlay"),this.drawClearAllUndoBitmaps(),this.loadDrawing(i)):this.addVolume(i)}}catch(i){console.error(i)}})().catch(console.error)}))}else r.isDirectory&&this.traverseFileTree(r,"",i).then((t=>{const e=this.getDicomLoader().loader;if(!e)throw new Error("No loader for DICOM files");e(t).then((async t=>{const e=t.map((t=>Ve.loadFromUrl({url:t.data,name:t.name,limitFrames4D:this.opts.limitFrames4D})));Promise.all(e).then((async t=>{await this.onDicomLoaderFinishedWithImages(t)})).catch((t=>{throw t}))})).catch((t=>{console.error("Error loading DICOM files:",t)}))})).catch((t=>{throw t}))}}}this.drawScene()}setMultiplanarPadPixels(t){this.opts.multiplanarPadPixels=t,this.drawScene()}setMultiplanarLayout(t){"string"==typeof t&&(t=parseInt(t)),this.opts.multiplanarLayout=t,this.drawScene()}setCornerOrientationText(t){this.opts.isCornerOrientationText=t,this.updateGLVolume()}setIsOrientationTextVisible(t){this.opts.isOrientationTextVisible=t,this.drawScene()}setShowAllOrientationMarkers(t){this.opts.showAllOrientationMarkers=t,this.drawScene()}setHeroImage(t){this.opts.heroImageFraction=t,this.drawScene()}setCustomLayout(t){for(let e=0;e<t.length;e++){const[i,s,r,n]=t[e].position,o=i+r,a=s+n;for(let l=e+1;l<t.length;l++){const[r,n,h,c]=t[l].position;if(i<r+h&&o>r&&(s<n+c&&a>n))throw new Error(`Custom layout is invalid. Tile ${e} overlaps with tile ${l}.`)}}this.customLayout=t,this.drawScene()}clearCustomLayout(){this.customLayout=null,this.drawScene()}getCustomLayout(){return this.customLayout}setRadiologicalConvention(t){this.opts.isRadiologicalConvention=t,this.updateGLVolume()}setDefaults(t,e){void 0===t&&(t={}),void 0===e&&(e=!1),this.document.opts={...Le},this.scene.sceneData={...ke};for(const i in t)"function"==typeof t[i]?this[i]=t[i]:this.opts[i]=void 0===Le[i]?Le[i]:t[i];if(this.scene.pan2Dxyzmm=[0,0,0,1],e&&this.volumes&&this.volumes.length>0)for(let i=0;i<this.volumes.length;i++)this.volumes[i].cal_min=this.volumes[i].robust_min,this.volumes[i].cal_max=this.volumes[i].robust_max;this.updateGLVolume()}setMeshThicknessOn2D(t){this.opts.meshThicknessOn2D=t,this.updateGLVolume()}setSliceMosaicString(t){this.sliceMosaicString=t,this.updateGLVolume()}setSliceMM(t){this.opts.isSliceMM=t,this.updateGLVolume()}setAdditiveBlend(t){this.opts.isAdditiveBlend=t,this.updateGLVolume()}getRadiologicalConvention(){return this.opts.isRadiologicalConvention}setHighResolutionCapable(t){"boolean"==typeof t&&(t=t?0:-1),this.opts.forceDevicePixelRatio=t,this.resizeListener(),this.drawScene()}watchOptsChanges(t){this.onOptsChange=t}unwatchOptsChanges(){this.onOptsChange=()=>{}}addVolume(t){this.volumes.push(t);const e=1===this.volumes.length?0:this.volumes.length-1;this.setVolume(t,e),this.onImageLoaded(t),U.debug("loaded volume",t.name),U.debug(t)}addMesh(t){this.meshes.push(t);const e=1===this.meshes.length?0:this.meshes.length-1;this.setMesh(t,e),this.onMeshLoaded(t)}getVolumeIndexByID(t){const e=this.volumes.length;for(let i=0;i<e;i++){if(this.volumes[i].id===t)return i}return-1}drawAddUndoBitmap(t){if(void 0===t&&(t=!0),!this.drawBitmap||this.drawBitmap.length<1)U.debug("drawAddUndoBitmap error: No drawing open");else{if(!t&&this.drawUndoBitmaps.length>0){const t=this.drawBitmap.length,e=He(this.drawUndoBitmaps[this.currentDrawUndoBitmap],t);for(let i=0;i<t;i++)e[i]>0&&(this.drawBitmap[i]=e[i]);this.refreshDrawing(!1)}this.currentDrawUndoBitmap++,this.currentDrawUndoBitmap>=this.opts.maxDrawUndoBitmaps&&(this.currentDrawUndoBitmap=0),this.drawUndoBitmaps[this.currentDrawUndoBitmap]=function(t){const e=t.length;let i=0;const s=new Uint8Array(e+Math.ceil(.01*e)),r=new Int8Array(s.buffer);let n=0;for(;i<e;){let o=t[i];i++;let a=1;for(;a<129&&i<e&&t[i]===o;)i++,a++;if(a>1)r[n]=1-a,n++,s[n]=o,n++;else{for(;i<e&&!(a>127)&&!(i+2<e&&o!==t[i]&&t[i+2]===t[i]&&t[i+1]===t[i]);)o=t[i],i++,a++;s[n]=a-1,n++;for(let e=0;e<a;e++)s[n]=t[i-a+e],n++}}return U.debug("PackBits "+e+" -> "+n+" bytes (x"+e/n+")"),s.slice(0,n)}(this.drawBitmap)}}drawClearAllUndoBitmaps(){if(this.currentDrawUndoBitmap=this.opts.maxDrawUndoBitmaps,this.drawUndoBitmaps&&!(this.drawUndoBitmaps.length<1))for(let t=this.drawUndoBitmaps.length-1;t>=0;t--)this.drawUndoBitmaps[t]=new Uint8Array}drawUndo(){const{drawBitmap:t,currentDrawUndoBitmap:e}=(t=>{let{drawUndoBitmaps:e,currentDrawUndoBitmap:i,drawBitmap:s}=t;const r=e.length;if(r<1)U.debug("undo bitmaps not loaded");else{if(i--,i<0&&(i=r-1),i>=r&&(i=0),!(e[i].length<2))return s=He(e[i],s.length),{drawBitmap:s,currentDrawUndoBitmap:i};U.debug("drawUndo is misbehaving")}})({drawUndoBitmaps:this.drawUndoBitmaps,currentDrawUndoBitmap:this.currentDrawUndoBitmap,drawBitmap:this.drawBitmap});this.drawBitmap=t,this.currentDrawUndoBitmap=e,this.refreshDrawing(!0)}loadDrawing(t){if(this.drawBitmap&&U.debug("Overwriting open drawing!"),!this.back)throw new Error("back undefined");this.drawClearAllUndoBitmaps();const e=t.hdr.dims;if(e[1]!==this.back.hdr.dims[1]||e[2]!==this.back.hdr.dims[2]||e[3]!==this.back.hdr.dims[3])return U.debug("drawing dimensions do not match background image"),!1;t.img.constructor!==Uint8Array&&U.debug("Drawings should be UINT8");const i=t.permRAS,s=e[1]*e[2]*e[3];this.drawBitmap=new Uint8Array(s),this.opts.is2DSliceShader?this.drawTexture=this.r8Tex2D(this.drawTexture,_i,this.back.dims,!0):this.drawTexture=this.r8Tex(this.drawTexture,_i,this.back.dims,!0);const r=[0,0,0];for(let f=0;f<3;f++)for(let t=0;t<3;t++)Math.abs(i[f])-1===t&&(r[t]=f*Math.sign(i[f]));let n=1;const o=[1,1,1],a=[!1,!1,!1];for(let f=0;f<r.length;f++)for(let t=0;t<r.length;t++){Math.abs(r[t])===f&&(o[t]=n,(r[t]<0||Object.is(r[t],-0))&&(a[t]=!0),n*=e[t+1])}let l=ae.range(0,e[1]-1,1);a[0]&&(l=ae.range(e[1]-1,0,-1));for(let f=0;f<e[1];f++)l[f]*=o[0];let h=ae.range(0,e[2]-1,1);a[1]&&(h=ae.range(e[2]-1,0,-1));for(let f=0;f<e[2];f++)h[f]*=o[1];let c=ae.range(0,e[3]-1,1);a[2]&&(c=ae.range(e[3]-1,0,-1));for(let f=0;f<e[3];f++)c[f]*=o[2];const d=t.img,m=this.drawBitmap;let u=0;for(let f=0;f<e[3];f++)for(let t=0;t<e[2];t++)for(let i=0;i<e[1];i++)m[l[i]+h[t]+c[f]]=d[u],u++;return this.drawAddUndoBitmap(),this.refreshDrawing(!1),this.drawScene(),!0}binarize(t){const e=t.hdr.dims,i=e[1]*e[2]*e[3],s=new Uint8Array(i);for(let r=0;r<i;r++)0!==t.img[r]&&(s[r]=1);t.img=s,t.hdr.datatypeCode=2,t.hdr.cal_min=0,t.hdr.cal_max=1}async loadDrawingFromUrl(t,e){void 0===e&&(e=!1),this.drawBitmap&&U.debug("Overwriting open drawing!"),this.drawClearAllUndoBitmaps();let i=!1;try{const s=await Ve.loadFromUrl(fe(t));e&&await this.binarize(s),i=this.loadDrawing(s)}catch(s){U.error("loadDrawingFromUrl() failed to load "+t),this.drawClearAllUndoBitmaps()}return i}findOtsu(t){if(void 0===t&&(t=2),this.volumes.length<1)return[];const e=this.volumes[0].img,i=e.length;if(i<1)return[];const s=256,r=new Array(s).fill(0),n=this.volumes[0].cal_min,o=this.volumes[0].cal_max;if(o<=n)return[];const a=(o-n)/s;function l(t){return t*a+n}const h=255/Math.abs(o-n),c=this.volumes[0].hdr.scl_inter,d=this.volumes[0].hdr.scl_slope;for(let A=0;A<i;A++){let t=e[A]*d+c;t=Math.min(Math.max(t,n),o),t=Math.round((t-n)*h),r[t]++}const m=Array(s).fill(0).map((()=>Array(s).fill(0))),u=Array(s).fill(0).map((()=>Array(s).fill(0)));for(let A=1;A<s;++A)m[A][A]=r[A],u[A][A]=A*r[A];for(let A=1;A<255;++A)m[1][A+1]=m[1][A]+r[A+1],u[1][A+1]=u[1][A]+(A+1)*r[A+1];for(let A=2;A<s;A++)for(let t=A+1;t<s;t++)m[A][t]=m[1][t]-m[1][A-1],u[A][t]=u[1][t]-u[1][A-1];for(let A=1;A<s;++A)for(let t=A+1;t<s;t++)0!==m[A][t]&&(m[A][t]=u[A][t]*u[A][t]/m[A][t]);let f=0;const g=[1/0,1/0,1/0];if(t>3)for(let A=0;A<253;A++)for(let t=A+1;t<254;t++)for(let e=t+1;e<255;e++){const i=m[0][A]+m[A+1][t]+m[t+1][e]+m[e+1][255];i>f&&(g[0]=A,g[1]=t,g[2]=e,f=i)}else if(3===t)for(let A=0;A<254;A++)for(let t=A+1;t<255;t++){const e=m[0][A]+m[A+1][t]+m[t+1][255];e>f&&(g[0]=A,g[1]=t,f=e)}else for(let A=0;A<255;A++){const t=m[0][A]+m[A+1][255];t>f&&(g[0]=A,f=t)}return[l(g[0]),l(g[1]),l(g[2])]}drawOtsu(t){if(void 0===t&&(t=2),0===this.volumes.length)return;const e=this.volumes[0].img.length,i=this.findOtsu(t);if(i.length<3)return;this.drawBitmap||this.createEmptyDrawing();const s=this.drawBitmap,r=this.volumes[0].img;for(let n=0;n<e;n++){if(0!==s[n])continue;const t=r[n];t>i[0]&&(s[n]=1),t>i[1]&&(s[n]=2),t>i[2]&&(s[n]=3)}this.drawAddUndoBitmap(),this.refreshDrawing(!0)}removeHaze(t,e){void 0===t&&(t=5),void 0===e&&(e=0);const i=this.volumes[e].img,s=this.volumes[e].hdr,r=i.length;let n=2;5!==t&&1!==t||(n=4),4!==t&&2!==t||(n=3);const o=this.findOtsu(n);if(o.length<3)return;let a=o[0];1===t&&(a=o[2]),2===t&&(a=o[1]);const l=s.scl_inter,h=s.scl_slope,c=this.volumes[e].global_min;for(let d=0;d<r;d++){i[d]*h+l<a&&(i[d]=c)}this.refreshLayers(this.volumes[e],0),this.drawScene()}async saveImage(t){void 0===t&&(t=es);const e={...es,...t},{filename:i,isSaveDrawing:s,volumeByIndex:r}=e;if(U.debug("saveImage",i,s,r),void 0===this.back?.dims)return U.debug("No voxelwise image open"),!1;if(s){if(!this.drawBitmap)return U.debug("No drawing open"),!1;const t=this.volumes[0].permRAS;if(1===t[0]&&2===t[1]&&3===t[2]){U.debug("saving drawing");return await this.volumes[0].saveToDisk(i,this.drawBitmap)}{U.debug("saving drawing");const e=this.volumes[0].hdr.dims,s=[0,0,0];for(let i=0;i<3;i++)for(let e=0;e<3;e++)Math.abs(t[i])-1===e&&(s[e]=i*Math.sign(t[i]));let r=1;const n=[1,1,1],o=[!1,!1,!1];for(let t=0;t<s.length;t++)for(let i=0;i<s.length;i++){Math.abs(s[i])===t&&(n[i]=r,(s[i]<0||Object.is(s[i],-0))&&(o[i]=!0),r*=e[i+1])}let a=ae.range(0,e[1]-1,1);o[0]&&(a=ae.range(e[1]-1,0,-1));for(let t=0;t<e[1];t++)a[t]*=n[0];let l=ae.range(0,e[2]-1,1);o[1]&&(l=ae.range(e[2]-1,0,-1));for(let t=0;t<e[2];t++)l[t]*=n[1];let h=ae.range(0,e[3]-1,1);o[2]&&(h=ae.range(e[3]-1,0,-1));for(let t=0;t<e[3];t++)h[t]*=n[2];const c=new Uint8Array(this.drawBitmap),d=new Uint8Array(e[1]*e[2]*e[3]);let m=0;for(let t=0;t<e[3];t++)for(let i=0;i<e[2];i++)for(let s=0;s<e[1];s++)d[m]=c[a[s]+l[i]+h[t]],m++;U.debug("saving drawing");return this.volumes[0].saveToDisk(i,d)}}U.debug("saving image");return this.volumes[r].saveToDisk(i)}getMeshIndexByID(t){if("number"==typeof t)return t>=this.meshes.length?-1:t;const e=this.meshes.length;for(let i=0;i<e;i++){if(this.meshes[i].id===t)return i}return-1}setMeshProperty(t,e,i){const s=this.getMeshIndexByID(t);s<0?U.warn("setMeshProperty() id not loaded",t):(this.meshes[s].setProperty(e,i,this.gl),this.updateGLVolume(),this.onMeshPropertyChanged(s,e,i))}indexNearestXYZmm(t,e,i,s){const r=this.getMeshIndexByID(t);return r<0?(U.warn("indexNearestXYZmm() id not loaded",t),[NaN,NaN]):this.meshes[r].indexNearestXYZmm(e,i,s)}decimateHierarchicalMesh(t,e){void 0===e&&(e=3);const i=this.getMeshIndexByID(t);if(i<0)return void U.warn("reverseFaces() id not loaded",t);const s=this.meshes[i].decimateHierarchicalMesh(this.gl,e);return this.updateGLVolume(),s}reverseFaces(t){const e=this.getMeshIndexByID(t);e<0?U.warn("reverseFaces() id not loaded",t):(this.meshes[e].reverseFaces(this.gl),this.updateGLVolume())}async setMeshLayerProperty(t,e,i,s){const r=this.getMeshIndexByID(t);r<0?U.warn("setMeshLayerProperty() id not loaded",t):(await this.meshes[r].setLayerProperty(e,i,s,this.gl),this.updateGLVolume())}setPan2Dxyzmm(t){this.scene.pan2Dxyzmm=t,this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=t[3]),this.drawScene()}setRenderAzimuthElevation(t,e){this.scene.renderAzimuth=t,this.scene.renderElevation=e,this.onAzimuthElevationChange(t,e),this.drawScene()}getOverlayIndexByID(t){const e=this.overlays.length;for(let i=0;i<e;i++){if(this.overlays[i].id===t)return i}return-1}setVolume(t,e){void 0===e&&(e=0);if(e>this.volumes.length)return;const i=this.getVolumeIndexByID(t.id);0===e?(this.volumes.splice(i,1),this.volumes.unshift(t),this.back=this.volumes[0],this.overlays=this.volumes.slice(1)):e<0?(this.volumes.splice(this.getVolumeIndexByID(t.id),1),this.back=this.volumes[0],this.volumes.length>1?this.overlays=this.volumes.slice(1):this.overlays=[]):(this.volumes.splice(i,1),this.volumes.splice(e,0,t),this.overlays=this.volumes.slice(1),this.back=this.volumes[0]),this.updateGLVolume()}setMesh(t,e){void 0===e&&(e=0),this.meshes.forEach((t=>{U.debug("MESH: ",t.name)}));if(e>this.meshes.length)return;const i=this.getMeshIndexByID(t.id);0===e?(this.meshes.splice(i,1),this.meshes.unshift(t)):e<0?this.meshes.splice(this.getMeshIndexByID(t.id),1):(this.meshes.splice(i,1),this.meshes.splice(e,0,t)),this.updateGLVolume(),this.meshes.forEach((t=>{U.debug(t.name)}))}removeVolume(t){if(this.setVolume(t,-1),this.mediaUrlMap.has(t)){const e=this.mediaUrlMap.get(t);this.onVolumeWithUrlRemoved(e),this.mediaUrlMap.delete(t)}this.drawScene()}removeVolumeByIndex(t){if(t>=this.volumes.length)throw new Error("Index of volume out of bounds");this.removeVolume(this.volumes[t])}removeMesh(t){if(t.unloadMesh(this.gl),this.setMesh(t,-1),this.mediaUrlMap.has(t)){const e=this.mediaUrlMap.get(t);this.onMeshWithUrlRemoved(e),this.mediaUrlMap.delete(t)}}removeMeshByUrl(t){const e=this.getMediaByUrl(t);e&&(this.removeMesh(e),this.mediaUrlMap.delete(e),this.onMeshWithUrlRemoved(t))}moveVolumeToBottom(t){this.setVolume(t,0)}moveVolumeUp(t){const e=this.getVolumeIndexByID(t.id);this.setVolume(t,e+1)}moveVolumeDown(t){const e=this.getVolumeIndexByID(t.id);this.setVolume(t,e-1)}moveVolumeToTop(t){this.setVolume(t,this.volumes.length-1)}mouseDown(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr,this.mousePos=[t,e]}updateMousePos(t,e){return t*=this.uiData.dpr,e*=this.uiData.dpr,this.mousePos=[t,e],[t,e]}mouseMove(t,e){t*=this.uiData.dpr,e*=this.uiData.dpr;const i=(t-this.mousePos[0])/this.uiData.dpr,s=(e-this.mousePos[1])/this.uiData.dpr;this.mousePos=[t,e],this.inRenderTile(t,e)<0||Math.abs(i)<1&&Math.abs(s)<1||(this.scene.renderAzimuth+=i,this.scene.renderElevation+=s,this.drawScene())}sph2cartDeg(t,e){const i=-e*(Math.PI/180),s=(t-90)%360*(Math.PI/180),r=[Math.cos(i)*Math.cos(s),Math.cos(i)*Math.sin(s),Math.sin(i)],n=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);return n<=0||(r[0]/=n,r[1]/=n,r[2]/=n),r}setClipPlane(t){const e=this.sph2cartDeg(t[1]+180,t[2]);this.scene.clipPlane=[e[0],e[1],e[2],t[0]],this.scene.clipPlaneDepthAziElev=t,this.onClipPlaneChange(this.scene.clipPlane),this.drawScene()}setCrosshairColor(t){this.opts.crosshairColor=t,this.drawScene()}setCrosshairWidth(t){this.opts.crosshairWidth=t,this.crosshairs3D&&(this.crosshairs3D.mm[0]=NaN),this.drawScene()}setDrawColormap(t){this.drawLut=re.makeDrawLut(t),this.updateGLVolume()}setDrawingEnabled(t){this.opts.drawingEnabled=t,this.opts.drawingEnabled?this.drawBitmap||this.createEmptyDrawing():(this.clickToSegmentIsGrowing&&(this.clickToSegmentIsGrowing=!1,this.refreshDrawing(!0,!1)),this.drawPenLocation=[NaN,NaN,NaN],this.drawPenAxCorSag=-1,this.drawPenFillPts=[],this.drawShapeStartLocation=[NaN,NaN,NaN],this.drawShapePreviewBitmap&&(this.drawBitmap=this.drawShapePreviewBitmap,this.drawShapePreviewBitmap=null)),this.drawScene()}setPenValue(t,e){void 0===e&&(e=!1),this.opts.penValue=t,this.opts.isFilledPen=e,this.drawScene()}setDrawOpacity(t){this.drawOpacity=t,this.drawScene()}setSelectionBoxColor(t){this.opts.selectionBoxColor=t}setBounds(t){if(!Array.isArray(t)||4!==t.length)throw new Error("setBounds: expected [x1,y1,x2,y2] array");this.opts.bounds=[[t[0],t[1]],[t[2],t[3]]],this.gl&&this.drawScene()}sliceScroll2D(t,e,i,s){if(void 0===s&&(s=!0),this.opts.scrollRequiresFocus&&this.canvas!==document.activeElement)U.warn("Canvas element does not have focus. Scroll events will not be processed.");else{if(this.inGraphTile(e,i)){let e=this.volumes[0].frame4D;return t>0&&e++,t<0&&e--,void this.setFrame4D(this.volumes[0].id,e)}if(0!==t&&3===this.opts.dragMode&&-1===this.inRenderTile(this.uiData.dpr*e,this.uiData.dpr*i)){let e=this.scene.pan2Dxyzmm[3]*(1+10*t);e=Math.round(10*e)/10;const i=this.scene.pan2Dxyzmm[3]-e;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=e),this.scene.pan2Dxyzmm[3]=e;const s=this.frac2mm(this.scene.crosshairPos);return this.scene.pan2Dxyzmm[0]+=i*s[0],this.scene.pan2Dxyzmm[1]+=i*s[1],this.scene.pan2Dxyzmm[2]+=i*s[2],this.drawScene(),this.canvas.focus(),void this.sync()}this.mouseClick(e,i,t,s)}}setSliceType(t){return this.opts.sliceType=t,this.drawScene(),this}setOpacity(t,e){this.volumes[t].opacity=e,this.updateGLVolume()}setScale(t){this.scene.volScaleMultiplier=t,this.drawScene()}setClipPlaneColor(t){this.opts.clipPlaneColor=t,this.renderShader.use(this.gl),this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor,this.opts.clipPlaneColor),this.drawScene()}setClipPlaneThick(t){this.opts.clipThick=t,this.renderShader.use(this.gl),this.gl.uniform1f(this.renderShader.uniforms.clipThick,this.opts.clipThick),this.drawScene()}setClipVolume(t,e){this.opts.clipVolumeLow=[Math.min(t[0],e[0]),Math.min(t[1],e[1]),Math.min(t[2],e[2])],this.opts.clipVolumeHigh=[Math.max(t[0],e[0]),Math.max(t[1],e[1]),Math.max(t[2],e[2])],this.renderShader.use(this.gl),this.gl.uniform3fv(this.renderShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.renderShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.pickingImageShader.use(this.gl),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.drawScene()}async setVolumeRenderIllumination(t){void 0===t&&(t=0),this.renderGradientValues=Number.isNaN(t),this.renderShader=this.renderVolumeShader,this.renderGradientValues?this.renderShader=this.renderGradientValuesShader:(this.opts.gradientAmount=t,t>0||this.opts.gradientOpacity>0?this.renderShader=this.renderGradientShader:t<0&&(this.renderShader=this.renderSliceShader)),await this.refreshLayers(this.volumes[0],0),this.initRenderShader(this.renderShader,t),this.renderShader.use(this.gl),this.setClipPlaneColor(this.opts.clipPlaneColor),Number.isNaN(t)?this.gradientTextureAmount=1:this.gradientTextureAmount=t,this.volumes.length<1||this.drawScene()}async setGradientOpacity(t,e){void 0===t&&(t=0),void 0===e&&(e=0),this.opts.gradientOpacity=t,this.opts.renderSilhouette=e,this.renderGradientValues?this.renderShader=this.renderGradientValuesShader:this.gradientTextureAmount>0||t>0?this.renderShader=this.renderGradientShader:this.gradientTextureAmount<0&&(this.renderShader=this.renderSliceShader),this.initRenderShader(this.renderShader,this.gradientTextureAmount),this.renderShader.use(this.gl),this.gradientTextureAmount>0&&this.refreshLayers(this.volumes[0],0),this.drawScene()}overlayRGBA(t){const e=t.hdr,i=e.dims[1]*e.dims[2]*e.dims[3],s=new Uint8ClampedArray(4*i),r=.2*Math.min(Math.min(e.dims[1],e.dims[2]),e.dims[3]),n=.5*e.dims[1],o=.5*e.dims[2],a=.5*e.dims[3];let l=0;for(let h=0;h<e.dims[3];h++)for(let t=0;t<e.dims[2];t++)for(let i=0;i<e.dims[1];i++){const e=Math.abs(i-n),c=Math.abs(t-o),d=Math.abs(h-a);let m=0;Math.sqrt(e*e+c*c+d*d)<r&&(m=255),s[l++]=0,s[l++]=m,s[l++]=0,s[l++]=.5*m}return s}vox2mm(t,e){return ae.vox2mm(t,e)}cloneVolume(t){return this.volumes[t].clone()}async loadDocumentFromUrl(t){const e=await Oe.loadFromUrl(t);await this.loadDocument(e)}async loadDocument(t){this.volumes=[],this.meshes=[],this.document=t,this.document.labels=this.document.labels?this.document.labels:[];const e={...Le,...t.opts};this.scene.pan2Dxyzmm=t.scene.pan2Dxyzmm?t.scene.pan2Dxyzmm:[0,0,0,1],this.document.opts=e,this.setClipPlane(this.scene.clipPlaneDepthAziElev),U.debug("load document",t),this.mediaUrlMap.clear(),this.createEmptyDrawing();const i=t.encodedImageBlobs;for(let r=0;r<t.imageOptionsArray.length;r++){const e=t.imageOptionsArray[r],s=i[r];if(s){"colorMap"in e&&(e.colormap=e.colorMap);const t=await Ve.loadFromBase64({base64:s,...e});if(t){if(t.colormapLabel){const e=Object.keys(t.colormapLabel.lut).length,i=new Uint8ClampedArray(e);for(const s in t.colormapLabel.lut)i[s]=t.colormapLabel.lut[s];t.colormapLabel.lut=i}this.addVolume(t)}}}this.volumes.length>0&&(this.back=this.volumes[0]);for(const r of t.meshDataObjects??[]){const t={gl:this.gl,...r};r.offsetPt0&&(t.rgba255[3]=0,t.tris=new Uint32Array(r.offsetPt0)),U.debug(t);const e=new Ge(t.pts,t.tris,t.name,t.rgba255,t.opacity,t.visible,this.gl,t.connectome,t.dpg,t.dps,t.dpv);r.offsetPt0&&(e.fiberGroupColormap=r.fiberGroupColormap,e.fiberColor=r.fiberColor,e.fiberDither=r.fiberDither,e.fiberRadius=r.fiberRadius,e.colormap=r.colormap),e.meshShaderIndex=t.meshShaderIndex,e.layers=t.layers,e.updateMesh(this.gl),U.debug(e),this.addMesh(e)}if(t.data.connectomes)for(const r of t.data.connectomes){const t=JSON.parse(r),e=this.loadConnectomeAsMesh(t);e.updateMesh(this.gl),this.addMesh(e)}this.createEmptyDrawing();const s=t.encodedDrawingBlob;if(s){const t=await ae.b64toUint8(s);if(t){const e=this.back.dims;let i=e[1]*e[2]*e[3];if(t.length-352===i&&(i+=352),t.length!==i)throw new Error(`drawBitmap size does not match the texture dimensions (${e[1]}\xd7${e[2]}\xd7${e[3]}) ${i} != ${e[1]*e[2]*e[3]}.`);this.drawBitmap=t,this.refreshDrawing()}}return await this.setGradientOpacity(this.opts.gradientOpacity),await this.setVolumeRenderIllumination(this.opts.gradientAmount),this.updateGLVolume(),this.drawScene(),this.onDocumentLoaded(t),this}async generateLoadDocumentJavaScript(t,e){const i=this.json();return`\n        ${e}\n\n        async function saveNiivueAsHtml(pageName) {\n          //get new docstring\n          const docString = nv1.json();\n          const html =\n          document.getElementsByTagName("html")[0]\n              .innerHTML.replace(base64, await NVUtilities.compressToBase64String(JSON.stringify(docString)));\n          NVUtilities.download(html, pageName, "application/html");\n        }\n\n        var nv1 = new Niivue();\n        await nv1.attachTo("${t}");\n        var base64 = "${await ae.compressToBase64String(JSON.stringify(i))}";\n        NVUtilities.decompressBase64String(base64).then((jsonText) => {\n          var json = JSON.parse(jsonText); // string -> JSON\n          var doc = NVDocument.loadFromJSON(json);\n          nv1.loadDocument(doc);\n          nv1.updateGLVolume();\n        });\n\n      `}async generateHTML(t,e){void 0===t&&(t="gl1");return`<!DOCTYPE html>\n        <html lang="en">\n          <head>\n            <meta charset="utf-8" />\n            <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n            <meta name="viewport" content="width=device-width,initial-scale=1.0" />\n            <title>Save as HTML</title>\n            <style>\n            html {\n              height: auto;\n              min-height: 100%;\n              margin: 0;\n            }\n            body {\n              display: flex;\n              flex-direction: column;\n              margin: 0;\n              min-height: 100%;\n              width: 100%;\n              position: absolute;\n              font-family: system-ui, Arial, Helvetica, sans-serif;\n              background: #ffffff;\n              color: black;\n              user-select: none; /* Standard syntax */\n            }\n            header {\n              margin: 10px;\n            }\n            main {\n              flex: 1;\n              background: #000000;\n              position: relative;\n            }\n            footer {\n              margin: 10px;\n            }\n            canvas {\n              position: absolute;\n              cursor: crosshair;\n            }\n            canvas:focus {\n              outline: 0px;\n            }\n            div {\n              display: table-row;\n              background-color: blue;\n            }\n            </style>\n          </head>\n          <body>\n            <noscript>niivue requires JavaScript.</noscript>\n            <header>\n            Save the current scene as HTML\n            <button id="save">Save as HTML</button>\n            </header>\n            <main>\n              <canvas id="gl1"></canvas>\n            </main>\n            <script type="module" async>\n              ${await this.generateLoadDocumentJavaScript(t,e)}\n              function saveAsHtml() {\n                saveNiivueAsHtml("page.html");\n              }\n              // assign our event handler\n              var button = document.getElementById("save");\n              button.onclick = saveAsHtml;\n            <\/script>\n          </body>\n        </html>`}async saveHTML(t,e,i){void 0===t&&(t="untitled.html"),void 0===e&&(e="gl1");const s=await this.generateHTML(e,i);return ae.download(s,t,"application/html")}json(){this.document.opts=this.opts,this.document.scene=this.scene,this.document.volumes=this.volumes,this.document.meshes=this.meshes,this.drawScene(),this.document.previewImageDataURL=this.canvas.toDataURL();return this.document.json()}async saveDocument(t,e,i){void 0===t&&(t="untitled.nvd"),void 0===e&&(e=!0),void 0===i&&(i={});const{embedImages:s=!0,embedPreview:r=!0}=i;this.document.title=t,this.document.volumes=this.volumes,this.document.meshes=this.meshes,r?(this.drawScene(),this.document.previewImageDataURL=this.canvas.toDataURL()):this.document.previewImageDataURL="",await this.document.download(t,e,{embedImages:s})}async loadImages(t){const e=[],i=[];for(const s of t)if("url"in s){const t=this.getFileExt(s.name?s.name:s.url);if(this.loaders[t]){const r=this.loaders[t].toExt.toUpperCase();Xi.includes(r)?i.push(s):e.push(s);continue}Xi.includes(t.toUpperCase())?i.push(s):e.push(s)}return e.length>0&&await this.loadVolumes(e),i.length>0&&await this.loadMeshes(i),this}async loadDicoms(t){if(!this.getDicomLoader())throw new Error("No dicom loader set. Please set a dicom loader before loading dicoms");this.drawScene(),this.volumes=[];const e=t.map((async t=>{let e=null;if(t.isManifest)e=await Ve.fetchDicomData(t.url);else{const i=await fetch(t.url);if(!i.ok)throw new Error(`Failed to load file: ${i.statusText}`);const s=await i.arrayBuffer();e=[{name:t.url.split("/").pop(),data:s}]}const i=this.getDicomLoader().loader,s=await i(e),r=s[0].name,n=s[0].data;return await Ve.loadFromUrl({url:n,name:r})})),i=await Promise.all(e);return 1===i.length?this.addVolume(i[0]):this.onDicomLoaderFinishedWithImages(i),this}async loadVolumes(t){return this.drawScene(),this.thumbnailVisible?(this.deferredVolumes=t,this):(this.volumes=[],this.closePAQD(),await this.addVolumesFromUrl(t),this)}async addMeshFromUrl(t){const e=this.getFileExt(t.url);if("JCON"===e||"JSON"===e){const e=await fetch(t.url,{}),i=await e.json(),s=this.loadConnectomeAsMesh(i);return this.mediaUrlMap.set(s,t.url),this.onMeshAddedFromUrl(t,s),this.addMesh(s),s}const i=await Ge.loadFromUrl({...t,gl:this.gl});return this.mediaUrlMap.set(i,t.url),this.onMeshAddedFromUrl(t,i),this.addMesh(i),i}async addMeshesFromUrl(t){const e=t.map((async t=>{const e=this.getFileExt(t.name||t.url);if(this.loaders[e]){let i=t.url;const r=this.loaders[e].toExt;let n=t.name||t.url;if(n=n.split("/").pop(),"string"==typeof t.url){const e=t.url;try{const t=await fetch(e);if(!t.ok)throw new Error(`Failed to load file: ${t.statusText}`);i=await t.arrayBuffer()}catch(s){throw new Error(`Failed to load url ${e}: ${s}`)}}const{positions:o,indices:a,colors:l=null}=await this.loaders[e].loader(i);t.name=`${n}.${r}`;const h=await ne.createMZ3Async(o,a,!1,l);t.buffer=h}if("JCON"===e||"JSON"===e){const e=await fetch(t.url,{}),i=await e.json(),s=this.loadConnectomeAsMesh(i);return this.mediaUrlMap.set(s,t.url),this.onMeshAddedFromUrl(t,s),s}const i=await Ge.loadFromUrl({...t,gl:this.gl});return this.mediaUrlMap.set(i,t.url),this.onMeshAddedFromUrl(t,i),i})),i=await Promise.all(e);for(let s=0;s<i.length;s++)this.addMesh(i[s]);return i}async loadMeshes(t){return this.drawScene(),this.thumbnailVisible?(this.deferredMeshes=t,this):(this.initialized,this.meshes=[],await this.addMeshesFromUrl(t),this.updateGLVolume(),this.drawScene(),this)}async loadConnectomeFromUrl(t,e){void 0===e&&(e={});const i=await fetch(t,{headers:e}),s=await i.json();return this.loadConnectome(s)}async loadFreeSurferConnectomeFromUrl(t,e){void 0===e&&(e={});const i=await fetch(t,{headers:e}),s=await i.json();return this.loadFreeSurferConnectome(s)}async loadFreeSurferConnectome(t){const e=Qe.convertFreeSurferConnectome(t);return this.loadConnectome(e)}handleNodeAdded(t){const e=t.detail.node,i=[1,1,1,1];this.addLabel(e.name,{textColor:i,bulletScale:1,bulletColor:i,lineWidth:0,lineColor:i,lineTerminator:"none",textScale:1},[e.x,e.y,e.z]),this.drawScene()}loadConnectomeAsMesh(t){let e=t;if("data_type"in t&&"fs_pointset"===t.data_type)e=Qe.convertFreeSurferConnectome(t),U.warn("converted FreeSurfer connectome",e);else{if(!("nodes"in t))throw new Error("not a known connectome format");{const i=t.nodes;"names"in i&&"X"in i&&"Y"in i&&"Z"in i&&"Color"in i&&"Size"in i&&(e=Qe.convertLegacyConnectome(t))}}return new Qe(this.gl,e)}loadConnectome(t){this.drawScene(),this.meshes=[];const e=this.loadConnectomeAsMesh(t);return this.addMesh(e),this.drawScene(),this}createEmptyDrawing(){if(null===this.back||!this.back.dims)return;if(Math.min(Math.min(this.back.dims[1],this.back.dims[2]),this.back.dims[3])<1)return;const t=this.back.dims[1]*this.back.dims[2]*this.back.dims[3];this.drawBitmap=new Uint8Array(t),this.clickToSegmentGrowingBitmap=new Uint8Array(t),this.drawClearAllUndoBitmaps(),this.drawAddUndoBitmap(),this.opts.is2DSliceShader?this.drawTexture=this.r8Tex2D(this.drawTexture,_i,this.back.dims):this.drawTexture=this.r8Tex(this.drawTexture,_i,this.back.dims,!0),this.refreshDrawing(!1)}r16Tex(t,e,i,s){t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16I,i[1],i[2],i[3]);const r=i[1]*i[2]*i[3];return s.length!==r&&(s=new Int16Array(r)),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RED_INTEGER,this.gl.SHORT,s),t}drawGrowCut(){if(!this.back||!this.back.dims)throw new Error("back not defined");const t=this.back.hdr,e=this.gl,i=t.dims[1]*t.dims[2]*t.dims[3];if(!this.drawBitmap||this.drawBitmap.length!==i)return void U.debug("bitmap dims are wrong");const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.disable(e.CULL_FACE),e.viewport(0,0,this.back.dims[1],this.back.dims[2]),e.disable(e.BLEND);let r=function(t){const e=t.hdr.dims,i=t.permRAS,s=e[1]*e[2]*e[3],r=new Int16Array(s),n=[0,0,0];for(let u=0;u<3;u++)for(let t=0;t<3;t++)Math.abs(i[u])-1===t&&(n[t]=u*Math.sign(i[u]));let o=1;const a=[1,1,1],l=[!1,!1,!1];for(let u=0;u<n.length;u++)for(let t=0;t<n.length;t++)Math.abs(n[t])===u&&(a[t]=o,(n[t]<0||Object.is(n[t],-0))&&(l[t]=!0),o*=e[t+1]);let h=ae.range(0,e[1]-1,1);l[0]&&(h=ae.range(e[1]-1,0,-1));for(let u=0;u<e[1];u++)h[u]*=a[0];let c=ae.range(0,e[2]-1,1);l[1]&&(c=ae.range(e[2]-1,0,-1));for(let u=0;u<e[2];u++)c[u]*=a[1];let d=ae.range(0,e[3]-1,1);l[2]&&(d=ae.range(e[3]-1,0,-1));for(let u=0;u<e[3];u++)d[u]*=a[2];let m=0;for(let u=0;u<e[3];u++)for(let i=0;i<e[2];i++)for(let s=0;s<e[1];s++)r[h[s]+c[i]+d[u]]=t.img[m],m++;return r}(this.back);const n=this.r16Tex(null,33995,this.back.dims,r);for(let v=1;v<i;v++)r[v]=this.drawBitmap[v];const o=this.r16Tex(null,33998,this.back.dims,r),a=this.r16Tex(null,33999,this.back.dims,r);for(let v=1;v<i;v++)r[v]>0&&(r[v]=1e4);const l=this.r16Tex(null,33996,this.back.dims,r),h=this.r16Tex(null,33997,this.back.dims,r);e.bindVertexArray(this.genericVAO);const c=this.growCutShader;c.use(e);e.uniform1i(c.uniforms.finalPass,0),e.uniform1i(c.uniforms.backTex,11);for(let v=0;v<128;v++){e.uniform1i(c.uniforms.labelTex,14),e.uniform1i(c.uniforms.strengthTex,12);for(let t=0;t<this.back.dims[3];t++){const i=1/this.back.dims[3]*(t+.5);e.uniform1f(c.uniforms.coordZ,i),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,a,0,t),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT1,h,0,t),e.drawBuffers([e.COLOR_ATTACHMENT0,e.COLOR_ATTACHMENT1]);e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&U.error("Incomplete framebuffer"),e.drawArrays(e.TRIANGLE_STRIP,0,4)}127===v&&e.uniform1i(c.uniforms.finalPass,1),e.uniform1i(c.uniforms.labelTex,15),e.uniform1i(c.uniforms.strengthTex,13);for(let t=0;t<this.back.dims[3];t++){const i=1/this.back.dims[3]*(t+.5);e.uniform1f(c.uniforms.coordZ,i),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,o,0,t),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT1,l,0,t),e.drawBuffers([e.COLOR_ATTACHMENT0,e.COLOR_ATTACHMENT1]);e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&U.error("Incomplete framebuffer"),e.drawArrays(e.TRIANGLE_STRIP,0,4)}}e.drawBuffers([e.COLOR_ATTACHMENT0]);const d=e.COLOR_ATTACHMENT1,m=o;e.readBuffer(d);const u=e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT),f=e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE);u===e.RED_INTEGER&&f===e.SHORT||U.debug("readPixels will fail."),r=new Int16Array;const g=this.back.dims[1]*this.back.dims[2],A=new Int16Array(g);for(let v=0;v<this.back.dims[3];v++)e.framebufferTextureLayer(e.FRAMEBUFFER,d,m,0,v),e.readPixels(0,0,this.back.dims[1],this.back.dims[2],u,f,A),r=Int16Array.from([...r,...A]);let p=r[0];for(let v=0;v<r.length;v++)p=Math.max(p,r[v]);for(let v=1;v<i;v++)this.drawBitmap[v]=r[v];e.deleteTexture(n),e.deleteTexture(l),e.deleteTexture(h),e.deleteTexture(o),e.deleteTexture(a),e.bindVertexArray(this.unusedVAO),e.viewport(0,0,e.canvas.width,e.canvas.height),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(s),this.drawAddUndoBitmap(),this.refreshDrawing(!0)}drawPt(t,e,i,s,r){if(void 0===r&&(r=null),null===r&&(r=this.drawBitmap),!this.back?.dims)throw new Error("back.dims not set");const n=this.back.dims[1],o=this.back.dims[2],a=this.back.dims[3];r[(t=Math.min(Math.max(t,0),n-1))+(e=Math.min(Math.max(e,0),o-1))*n+(i=Math.min(Math.max(i,0),a-1))*n*o]=s;const l=0===this.drawPenAxCorSag,h=1===this.drawPenAxCorSag,c=2===this.drawPenAxCorSag;if(this.opts.penSize>1){const a=Math.floor(this.opts.penSize/2);for(let d=-a;d<=a;d++)for(let m=-a;m<=a;m++)l?r[t+d+(e+m)*n+i*n*o]=s:h?r[t+d+e*n+(i+m)*n*o]=s:c&&(r[t+(e+m)*n+(i+d)*n*o]=s)}}drawPenLine(t,e,i){const s=Math.abs(t[0]-e[0]),r=Math.abs(t[1]-e[1]),n=Math.abs(t[2]-e[2]);let o=-1,a=-1,l=-1;e[0]>t[0]&&(o=1),e[1]>t[1]&&(a=1),e[2]>t[2]&&(l=1);let h=t[0],c=t[1],d=t[2];const m=e[0],u=e[1],f=e[2];if(s>=r&&s>=n){let t=2*r-s,e=2*n-s;for(;h!==m;)h+=o,t>=0&&(c+=a,t-=2*s),e>=0&&(d+=l,e-=2*s),t+=2*r,e+=2*n,this.drawPt(h,c,d,i)}else if(r>=s&&r>=n){let t=2*s-r,e=2*n-r;for(;c!==u;)c+=a,t>=0&&(h+=o,t-=2*r),e>=0&&(d+=l,e-=2*r),t+=2*s,e+=2*n,this.drawPt(h,c,d,i)}else{let t=2*r-n,e=2*s-n;for(;d!==f;)d+=l,t>=0&&(c+=a,t-=2*n),e>=0&&(h+=o,e-=2*n),t+=2*r,e+=2*s,this.drawPt(h,c,d,i)}}drawRectangleMask(t,e,i){if(!this.back?.dims)throw new Error("back.dims not set");const s=this.back.dims[1],r=this.back.dims[2],n=this.back.dims[3],o=Math.min(Math.max(Math.min(t[0],e[0]),0),s-1),a=Math.min(Math.max(Math.min(t[1],e[1]),0),r-1),l=Math.min(Math.max(Math.min(t[2],e[2]),0),n-1),h=Math.min(Math.max(Math.max(t[0],e[0]),0),s-1),c=Math.min(Math.max(Math.max(t[1],e[1]),0),r-1),d=Math.min(Math.max(Math.max(t[2],e[2]),0),n-1);for(let m=l;m<=d;m++)for(let t=a;t<=c;t++)for(let e=o;e<=h;e++)this.drawPt(e,t,m,i)}drawEllipseMask(t,e,i){if(!this.back?.dims)throw new Error("back.dims not set");const s=this.back.dims[1],r=this.back.dims[2],n=this.back.dims[3],o=Math.min(Math.max(Math.min(t[0],e[0]),0),s-1),a=Math.min(Math.max(Math.min(t[1],e[1]),0),r-1),l=Math.min(Math.max(Math.min(t[2],e[2]),0),n-1),h=Math.min(Math.max(Math.max(t[0],e[0]),0),s-1),c=Math.min(Math.max(Math.max(t[1],e[1]),0),r-1),d=Math.min(Math.max(Math.max(t[2],e[2]),0),n-1),m=(o+h)/2,u=(a+c)/2,f=(l+d)/2,g=Math.abs(h-o)/2,A=Math.abs(c-a)/2,p=Math.abs(d-l)/2;for(let v=l;v<=d;v++)for(let t=a;t<=c;t++)for(let e=o;e<=h;e++){const s=(e-m)/(g+.5),r=(t-u)/(A+.5),n=(v-f)/(p+.5);s*s+r*r+n*n<=1&&this.drawPt(e,t,v,i)}}drawingBinaryDilationWithSeed(t,e){void 0===e&&(e=6);try{let i=function(t){return t[0]+t[1]*a+t[2]*l};const s=this.drawBitmap,r=this.back.dims[1],n=this.back.dims[2],o=this.back.dims[3],a=r,l=r*n,h=l*o,c=i(t);if(c<0||c>=h)throw new Error("Seed index is out of bounds.");const d=s[c];if(0===d)throw new Error("Seed voxel is not part of a filled cluster.");const m=s.slice();for(let t=0;t<h;t++)m[t]=m[t]===d?1:0;this.drawFloodFillCore(m,c,e);const u=s.slice(),f=[],g=[-l,l,-r,r,-1,1];f.push(...g),e>6&&f.push(-r-1,1-r,r-1,r+1,-l-r,-l+r,-l-1,1-l,l-r,l+r,l-1,l+1),e>18&&f.push(-l-r-1,-l-r+1,-l+r-1,-l+r+1,l-r-1,l-r+1,l+r-1,l+r+1);for(let t=0;t<h;t++)if(2===m[t]){const e=t%r,i=Math.floor(t%l/r),n=Math.floor(t/l);for(const o of f){const a=t+o;if(a<0||a>=h)continue;const c=a%r,m=Math.floor(a%l/r),f=Math.floor(a/l);Math.abs(c-e)>1||Math.abs(m-i)>1||Math.abs(f-n)>1||0===s[a]&&(u[a]=d)}}this.drawBitmap=u,this.drawAddUndoBitmap(),this.refreshDrawing(!0)}catch(i){U.error("Error in drawingBinaryDilationWithSeed:",i)}}drawFloodFillCore(t,e,i){if(void 0===i&&(i=6),!this.back?.dims)throw new Error("back.dims undefined");const s=[this.back.dims[1],this.back.dims[2],this.back.dims[3]],r=s[0],n=r*s[1];function o(t){const e=Math.floor(t/n),i=Math.floor((t-e*n)/r);return[Math.floor(t%r),i,e]}const a=[];for(a.push(e),t[e]=2;a.length>0;){let e=function(e){const i=h.slice();if(i[0]+=e[0],i[1]+=e[1],i[2]+=e[2],i[0]<0||i[1]<0||i[2]<0)return;if(i[0]>=s[0]||i[1]>=s[1]||i[2]>=s[2])return;const o=(l=i)[0]+l[1]*r+l[2]*n;var l;1===t[o]&&(t[o]=2,a.push(o))};const l=a[0];a.shift();const h=o(l);e([0,0,-1]),e([0,0,1]),e([0,-1,0]),e([0,1,0]),e([-1,0,0]),e([1,0,0]),i<=6||(e([-1,-1,0]),e([1,1,0]),e([-1,1,0]),e([1,1,0]),e([0,-1,-1]),e([0,1,-1]),e([-1,0,-1]),e([1,0,-1]),e([0,-1,1]),e([0,1,1]),e([-1,0,1]),e([1,0,1]),i<=18||(e([-1,-1,-1]),e([1,-1,-1]),e([-1,1,-1]),e([1,1,-1]),e([-1,-1,1]),e([1,-1,1]),e([-1,1,1]),e([1,1,1])))}}drawFloodFill(t,e,i,s,r,n,o,a,l,h){if(void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=NaN),void 0===r&&(r=NaN),void 0===n&&(n=6),void 0===o&&(o=Number.POSITIVE_INFINITY),void 0===a&&(a=!1),void 0===l&&(l=null),void 0===h&&(h=!1),!this.drawBitmap&&(U.warn("drawFloodFill called without an initialized drawBitmap."),this.createEmptyDrawing(),!this.drawBitmap))return void U.error("Failed to create drawing bitmap.");if(this.clickToSegmentIsGrowing&&!this.clickToSegmentGrowingBitmap){if(U.warn("drawFloodFill called in preview mode without initialized clickToSegmentGrowingBitmap."),!this.drawBitmap)return void U.error("Cannot initialize growing bitmap as drawBitmap is null.");if(this.clickToSegmentGrowingBitmap=this.drawBitmap.slice(),!this.clickToSegmentGrowingBitmap)return void U.error("Failed to create growing bitmap.")}if(null===l&&(l=this.drawBitmap),!l)return void U.error("drawFloodFill targetBitmap is null.");if(!this.back?.dims)throw new Error("back.dims undefined");e=Math.abs(e);const c=[this.back.dims[1],this.back.dims[2],this.back.dims[3]];if(t[0]<0||t[1]<0||t[2]<0)return;if(t[0]>=c[0]||t[1]>=c[1]||t[2]>=c[2])return;const d=c[0],m=d*c[1],u=m*c[2],f=this.clickToSegmentIsGrowing?this.drawBitmap:l;if(!f)return void U.error("Could not determine original bitmap state.");const g=new Uint8Array(u).fill(0);let A=-1;a&&0===this.drawPenAxCorSag?A=2:a&&1===this.drawPenAxCorSag?A=1:a&&2===this.drawPenAxCorSag&&(A=0);const p=t=>this.vox2mm(t,this.back.matRAS),v=p(t),x=o**2;function w(e){const i=function(t){const e=Math.floor(t/m),i=Math.floor((t-e*m)/d);return[Math.floor(t%d),i,e]}(e);if(A>=0&&i[A]!==t[A])return!1;const s=p(i);return(s[0]-v[0])**2+(s[1]-v[1])**2+(s[2]-v[2])**2<=x}const b=(y=t)[0]+y[1]*d+y[2]*m;var y;const C=f[b];if(h&&0===C)return U.debug("Grow/Erase Cluster tool requires starting on a masked voxel."),void(this.clickToSegmentIsGrowing&&this.clickToSegmentGrowingBitmap&&this.drawBitmap&&(this.clickToSegmentGrowingBitmap.set(this.drawBitmap),this.refreshDrawing(!0,!0)));if(0===i&&C===e&&!h&&0!==e&&(U.debug("drawFloodFill selected voxel is already desired color"),!this.clickToSegmentIsGrowing))return;let M=NaN;if(!h||i!==Number.POSITIVE_INFINITY&&i!==Number.NEGATIVE_INFINITY)if(0===i)if(h&&0===e){U.debug(`Erase Cluster: Identifying cluster with color ${C}`);for(let t=0;t<u;t++)g[t]=f[t]===C&&w(t)?1:0}else for(let D=0;D<u;D++)f[D]===C&&w(D)&&0!==C&&(g[D]=1);else{const t=this.volumes[0].img2RAS();M=t[b];let n=-1/0,o=1/0;isFinite(s)&&isFinite(r)?(n=s,o=r):i===Number.POSITIVE_INFINITY?n=M:i===Number.NEGATIVE_INFINITY&&(o=M);for(let e=0;e<u;e++){const i=t[e];i>=n&&i<=o&&w(e)&&(g[e]=1)}0===(e=f[b])&&((e=this.opts.penValue)<1||!isFinite(e))&&(e=1)}else{const t=f.slice();for(let e=0;e<u;e++)t[e]=t[e]===C&&w(e)?1:0;if(1!==t[b])return void U.error("Seed voxel could not be marked for cluster ID.");this.drawFloodFillCore(t,b,n);const s=this.volumes[0].img2RAS();let r=0,o=0;for(let e=0;e<u;e++)2===t[e]&&(r+=s[e],o++);M=o>0?r/o:s[b],U.debug(`Grow Cluster using mean intensity: ${M.toFixed(2)} from ${o} voxels.`);let a=-1/0,l=1/0;i===Number.POSITIVE_INFINITY&&(a=M),i===Number.NEGATIVE_INFINITY&&(l=M);for(let e=0;e<u;e++)if(2===t[e])g[e]=1;else if(0===f[e]){const t=s[e];t>=a&&t<=l&&w(e)&&(g[e]=1)}e=C}if(1!==g[b]){let t=!1;if(h&&0!==i?0!==C&&(t=!0):0===C&&0!==e||(t=!0),!t||!w(b))return U.debug("Seed voxel not marked as candidate '1' and not valid originally."),void(this.clickToSegmentIsGrowing&&this.clickToSegmentGrowingBitmap&&this.drawBitmap&&this.clickToSegmentGrowingBitmap.set(this.drawBitmap));g[b]=1,U.debug("Forcing seed voxel to 1 in working buffer.")}this.drawFloodFillCore(g,b,n);for(let D=0;D<u;D++)2===g[D]?l[D]=e:this.clickToSegmentIsGrowing&&l===this.clickToSegmentGrowingBitmap&&(l[D]=f[D]);this.clickToSegmentIsGrowing?this.refreshDrawing(!0,!0):(this.drawAddUndoBitmap(),this.refreshDrawing(!0,!1))}floodFillSectionFIFO(t,e,i,s){const r=e[0],[n,o]=i,[a,l]=s,h=new Int32Array(2*(4*(a-n+l-o+2)));let c,d=0,m=0;function u(e,i){if(e<n||e>a||i<o||i>l)return;const s=e+i*r;0===t[s]&&(t[s]=2,h[m]=e,h[m+1]=i,m=(m+2)%h.length)}function f(){if(d===m)return null;const t=h[d],e=h[d+1];return d=(d+2)%h.length,[t,e]}for(let g=n;g<=a;g++)u(g,o),u(g,l);for(let g=o+1;g<=l-1;g++)u(n,g),u(a,g);for(;null!==(c=f());){const[t,e]=c;u(t-1,e),u(t+1,e),u(t,e-1),u(t,e+1)}}drawPenFilled(){const t=this.drawPenFillPts.length;if(t<2)return void(this.drawPenFillPts=[]);const e=this.drawPenAxCorSag;let i=0,s=1;if(1===e&&(s=2),2===e&&(i=1,s=2),!this.back?.dims)throw new Error("back.dims undefined");const r=[this.back.dims[i+1],this.back.dims[s+1]],n=new Uint8Array(r[0]*r[1]);let o=1;function a(t,e){const i=Math.abs(t[0]-e[0]),s=Math.abs(t[1]-e[1]);n[t[0]+t[1]*r[0]]=o,n[e[0]+e[1]*r[0]]=o;let a=-1,l=-1;e[0]>t[0]&&(a=1),e[1]>t[1]&&(l=1);let h=t[0],c=t[1];const d=e[0],m=e[1];if(i>=s){let t=2*s-i;for(;h!==d;)h+=a,t>=0&&(c+=l,t-=2*i),t+=2*s,n[h+c*r[0]]=o}else{let t=2*i-s;for(;c!==m;)c+=l,t>=0&&(h+=a,t-=2*s),t+=2*i,n[h+c*r[0]]=o}}function l(t){return[Math.min(Math.max(t[0],0),r[0]-1),Math.min(Math.max(t[1],0),r[1]-1)]}const h=l([this.drawPenFillPts[0][i],this.drawPenFillPts[0][s]]);let c=[...h],d=[...h],m=h;for(let g=1;g<t;g++){let t=[this.drawPenFillPts[g][i],this.drawPenFillPts[g][s]];t=l(t),c=[Math.min(t[0],c[0]),Math.min(t[1],c[1])],d=[Math.max(t[0],d[0]),Math.max(t[1],d[1])],a(m,t),m=t}a(h,m);c[0]=Math.max(0,c[0]-1),c[1]=Math.max(0,c[1]-1),d[0]=Math.min(r[0]-1,d[0]+1),d[1]=Math.min(r[1]-1,d[1]+1);for(let g=0;g<r[1];g++)for(let t=0;t<r[0];t++){if(t>=c[0]&&t<d[0]&&g>=c[1]&&g<=d[1])continue;const e=t+g*r[0];0===n[e]&&(n[e]=2)}const u=Date.now();this.floodFillSectionFIFO(n,r,c,d),U.debug("FloodFill "+(Date.now()-u)),o=this.opts.penValue;const f=this.drawPenFillPts[0][3-(i+s)];if(!this.drawBitmap)throw new Error("drawBitmap undefined");if(0===e){const t=f*r[0]*r[1];for(let e=0;e<r[0]*r[1];e++)2!==n[e]&&(this.drawBitmap[e+t]=o)}else{let t=1;const i=this.back.dims[1]*this.back.dims[2];let s=f*this.back.dims[1];2===e&&(t=this.back.dims[1],s=f);let a=0;for(let e=0;e<r[1];e++)for(let l=0;l<r[0];l++)2!==n[a]&&(this.drawBitmap[l*t+e*i+s]=o),a++}if(!this.drawFillOverwrites&&this.drawUndoBitmaps[this.currentDrawUndoBitmap].length>0){const t=this.drawBitmap.length,e=He(this.drawUndoBitmaps[this.currentDrawUndoBitmap],t);for(let i=0;i<t;i++)0!==e[i]&&(this.drawBitmap[i]=e[i])}this.drawPenFillPts=[],this.drawAddUndoBitmap(),this.refreshDrawing(!1)}closeDrawing(){this.drawClearAllUndoBitmaps(),this.drawTexture=this.rgbaTex(this.drawTexture,_i,[2,2,2,2],!0),this.drawBitmap=null,this.clickToSegmentGrowingBitmap=null,this.drawScene()}refreshDrawing(t,e){void 0===t&&(t=!0),void 0===e&&(e=!1),!e||this.opts.drawingEnabled&&this.opts.clickToSegment||(U.debug("refreshDrawing: Conditions not met for clickToSegment bitmap, using drawBitmap."),e=!1);const i=e?this.clickToSegmentGrowingBitmap:this.drawBitmap;i||e||!this.clickToSegmentGrowingBitmap?!i&&e&&this.drawBitmap?(U.warn("refreshDrawing: clickToSegmentGrowingBitmap is null, falling back to drawBitmap."),e=!1):i||U.warn("refreshDrawing: Both bitmaps are null. Uploading empty data."):U.warn("refreshDrawing: drawBitmap is null, but clickToSegmentGrowingBitmap exists. Check state.");const s=e?this.clickToSegmentGrowingBitmap:this.drawBitmap;if(!this.back?.dims)return void U.warn("refreshDrawing: back.dims undefined, cannot refresh drawing texture yet.");const r=this.back.dims.slice(),n=this.back.dims[1]*this.back.dims[2]*this.back.dims[3];if(!s)return U.warn(`refreshDrawing: Bitmap data source (${e?"growing":"main"}) is null. Cannot update texture.`),void(t&&this.drawScene());if(8===s.length?(r[1]=2,r[2]=2,r[3]=2):n!==s.length&&U.warn(`Drawing bitmap length (${s.length}) must match the background image (${n})`),this.gl.activeTexture(_i),this.opts.is2DSliceShader){const t=this.frac2vox(this.scene.crosshairPos),e=Math.min(Math.max(t[2],0),r[3]-1),i=r[1]*r[2],n=e*i;U.debug(`refresh huge 2D drawing x\xd7y\xd7z ${r[1]}\xd7${r[2]}\xd7${r[3]} slice ${n}`);const o=s.subarray(n,n+i);this.gl.bindTexture(this.gl.TEXTURE_2D,this.drawTexture),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,r[1],r[2],this.gl.RED,this.gl.UNSIGNED_BYTE,o)}else this.gl.bindTexture(this.gl.TEXTURE_3D,this.drawTexture),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,r[1],r[2],r[3],this.gl.RED,this.gl.UNSIGNED_BYTE,s);this.drawTexture?t&&this.drawScene():U.error("refreshDrawing: drawTexture (GPU texture) is null.")}closePAQD(){this._gl&&this.paqdTexture&&(this.paqdTexture=this.rgbaTex(this.paqdTexture,$i,[2,2,2,2],!0))}r8Tex2D(t,e,i,s){if(void 0===s&&(s=!1),t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.R8,i[1],i[2]),s){const t=new Uint8Array(i[1]*i[2]);this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,i[1],i[2],this.gl.RED,this.gl.UNSIGNED_BYTE,t)}return t}r8Tex(t,e,i,s){if(void 0===s&&(s=!1),t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R8,i[1],i[2],i[3]),s){const t=new Uint8Array(i[1]*i[2]*i[3]);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RED,this.gl.UNSIGNED_BYTE,t)}return t}rgbaTex2D(t,e,i,s,r){if(void 0===s&&(s=null),void 0===r&&(r=!0),t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.RGBA8,i[1],i[2]),s){let t=s;const e=i[1],n=i[2];if(r){t=new Uint8Array(s.length);const i=4*e;for(let e=0;e<n;e++){const r=e*i,o=(n-1-e)*i;t.set(s.subarray(r,r+i),o)}}this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,e,n,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t)}return t}rgbaTex(t,e,i,s){if(void 0===s&&(s=!1),t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA8,i[1],i[2],i[3]),s){const t=new Uint8Array(i[1]*i[2]*i[3]*4);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RGBA,this.gl.UNSIGNED_BYTE,t)}return t}rgba16Tex(t,e,i,s){if(void 0===s&&(s=!1),t&&this.gl.deleteTexture(t),t=this.gl.createTexture(),this.gl.activeTexture(e),this.gl.bindTexture(this.gl.TEXTURE_3D,t),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,2),this.gl.pixelStorei(this.gl.PACK_ALIGNMENT,2),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA16UI,i[1],i[2],i[3]),s){const t=new Uint16Array(i[1]*i[2]*i[3]*4);this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i[1],i[2],i[3],this.gl.RGBA_INTEGER,this.gl.UNSIGNED_SHORT,t)}return t}requestCORSIfNotSameOrigin(t,e){new URL(e,window.location.href).origin!==window.location.origin&&(t.crossOrigin="")}async loadPngAsTexture(t,e){return new Promise(((i,s)=>{const r=new Image;r.onload=()=>{if(!this.bmpShader)return;let t;4===e?(null!==this.bmpTexture&&this.gl.deleteTexture(this.bmpTexture),this.bmpTexture=this.gl.createTexture(),t=this.bmpTexture,this.bmpTextureWH=r.width/r.height,this.gl.activeTexture(33988),this.bmpShader.use(this.gl),this.gl.uniform1i(this.bmpShader.uniforms.bmpTexture,4)):5===e?(this.gl.activeTexture(ji),null!==this.matCapTexture&&this.gl.deleteTexture(this.matCapTexture),this.matCapTexture=this.gl.createTexture(),t=this.matCapTexture):(this.fontShader.use(this.gl),this.gl.activeTexture(33987),this.gl.uniform1i(this.fontShader.uniforms.fontTexture,3),null!==this.fontTexture&&this.gl.deleteTexture(this.fontTexture),this.fontTexture=this.gl.createTexture(),t=this.fontTexture),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),i(t),4!==e&&this.drawScene()},r.onerror=s,this.requestCORSIfNotSameOrigin(r,t),r.src=t}))}async loadFontTexture(t){return this.loadPngAsTexture(t,3)}async loadBmpTexture(t){return this.loadPngAsTexture(t,4)}async loadMatCapTexture(t){return this.loadPngAsTexture(t,5)}initFontMets(){if(!this.fontMetrics)throw new Error("fontMetrics undefined");this.fontMets={distanceRange:this.fontMetrics.atlas.distanceRange,size:this.fontMetrics.atlas.size,mets:{}};for(let i=0;i<256;i++)this.fontMets.mets[i]={xadv:0,uv_lbwh:[0,0,0,0],lbwh:[0,0,0,0]};const t=this.fontMetrics.atlas.width,e=this.fontMetrics.atlas.height;for(let i=0;i<this.fontMetrics.glyphs.length;i++){const s=this.fontMetrics.glyphs[i],r=s.unicode;if(this.fontMets.mets[r].xadv=s.advance,void 0===s.planeBounds)continue;let n=s.atlasBounds.left/t,o=(e-s.atlasBounds.top)/e,a=(s.atlasBounds.right-s.atlasBounds.left)/t,l=(s.atlasBounds.top-s.atlasBounds.bottom)/e;this.fontMets.mets[r].uv_lbwh=[n,o,a,l],n=s.planeBounds.left,o=s.planeBounds.bottom,a=s.planeBounds.right-s.planeBounds.left,l=s.planeBounds.top-s.planeBounds.bottom,this.fontMets.mets[r].lbwh=[n,o,a,l]}}async loadFont(t,e){void 0===t&&(t=We),void 0===e&&(e=Ke),await this.loadFontTexture(t);const i=await fetch(e);if(!i.ok)throw Error(i.statusText);const s=await i.text();this.fontMetrics=JSON.parse(s),this.initFontMets(),this.fontShader.use(this.gl),this.drawScene()}async loadDefaultMatCap(){return this.loadMatCapTexture("data:image/jpeg;base64,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ZwAAAAAAAAALY3JvcFJlY3RUb3Bsb25nAAAAAAA4QklNA+0AAAAAABAASAAAAAEAAQBIAAAAAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAABOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0EAAAAAAAAAgAAOEJJTQQCAAAAAAACAAA4QklNBDAAAAAAAAEBADhCSU0ELQAAAAAABgABAAAAMjhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAACAAAAAgAAAAAEAG0AYwA2ADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAIAAAAAAFJnaHRsb25nAAACAAAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAA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bnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTgtMDctMTJUMjA6MDc6NDcrMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE4LTA3LTEzVDE3OjU0OjI3KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0OGNjMGI3YS1iYTJkLWZmNDAtYmNkNC1jNGQzMzIyZjBiNzQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYzFjM2NhNS1hYTg4LWI5NGMtOGE4MS05YmU4MjA3ZGZiODciPiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YThjMGNhZTYtODNjYy1hYzQ4LWI2YzAtN2FiODNlOWJkMGM3PC9yZGY6bGk+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWMxYzNjYTUtYWE4OC1iOTRjLThhODEtOWJlODIwN2RmYjg3IiBzdEV2dDp3aGVuPSIyMDE4LTA3LTEyVDIwOjA3OjQ3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjYmI3MzZlZC0zOTRhLTM2NDgtYThiOC02Mzk1MmY0NDcxMjIiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTY6MTM6NTgrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RFdnQ6d2hlbj0iMjAxOC0wNy0xM1QxNzo1NDoyNyswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iZGVyaXZlZCIgc3RFdnQ6cGFyYW1ldGVycz0iY29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9qcGVnIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MmVhYjVmZS02NDZkLWVhNDMtODQyNC0xNWQzZTgwOWExNDQiIHN0RXZ0OndoZW49IjIwMTgtMDctMTNUMTc6NTQ6MjcrMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQ2YjNkYTI3LWI4YjEtYmU0Yi1hYTQ4LTExZGM5NmZkNTIyZiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg3NjM1NDk5LWZiMTItYWU0MC04NWEzLThkMWFiN2NkZGVhOSIgc3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFjMWMzY2E1LWFhODgtYjk0Yy04YTgxLTliZTgyMDdkZmI4NyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAEAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1Q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")}async loadDefaultFont(){await this.loadFontTexture(this.DEFAULT_FONT_GLYPH_SHEET),this.fontMetrics=this.DEFAULT_FONT_METRICS,this.initFontMets()}async initText(){this.fontShader=new Ui(this.gl,"#version 300 es\n#line 576\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform vec4 leftTopWidthHeight;\nuniform vec4 uvLeftTopWidthHeight;\nout vec2 vUV;\nvoid main(void) {\n\t//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1\n\tvec2 frac;\n\tfrac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1\n\tfrac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0\n\tfrac = (frac * 2.0) - 1.0;\n\tgl_Position = vec4(frac, 0.0, 1.0);\n\tvUV = vec2(uvLeftTopWidthHeight.x + (pos.x * uvLeftTopWidthHeight.z), uvLeftTopWidthHeight.y  + ((1.0 - pos.y) * uvLeftTopWidthHeight.w) );\n}","#version 300 es\n#line 593\nprecision highp int;\nprecision highp float;\nuniform highp sampler2D fontTexture;\nuniform vec4 fontColor;\nuniform float screenPxRange;\nin vec2 vUV;\nout vec4 color;\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nvoid main() {\n\tvec3 msd = texture(fontTexture, vUV).rgb;\n\tfloat sd = median(msd.r, msd.g, msd.b);\n\tfloat screenPxDistance = screenPxRange*(sd - 0.5);\n\tfloat opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\tcolor = vec4(fontColor.rgb , fontColor.a * opacity);\n}"),this.fontShader.use(this.gl),await this.loadDefaultFont(),await this.loadDefaultMatCap(),this.drawLoadingText(this.opts.loadingText)}meshShaderNameToNumber(t){void 0===t&&(t="Phong");const e=t.toLowerCase();for(let i=0;i<this.meshShaders.length;i++)if(this.meshShaders[i].Name.toLowerCase()===e)return i}setMeshShader(t,e){void 0===e&&(e=2);let i=0;if(i="number"==typeof e?e:this.meshShaderNameToNumber(e),void 0===i)throw new Error("shaderIndex undefined");i=Math.min(i,this.meshShaders.length-1),i=Math.max(i,0);const s=this.getMeshIndexByID(t);s>=this.meshes.length?U.debug("Unable to change shader until mesh is loaded (maybe you need async)"):(this.meshes[s].meshShaderIndex=i,this.updateGLVolume(),this.onMeshShaderChanged(s,i))}createCustomMeshShader(t,e){if(void 0===e&&(e="Custom"),!t)throw new Error("Need fragment shader");const i=this.meshShaderNameToNumber(e);i>=0&&(this.gl.deleteProgram(this.meshShaders[i].shader.program),this.meshShaders.splice(i,1));const s=new Ui(this.gl,Ii,t);return s.use(this.gl),{Name:e,Frag:t,shader:s}}setCustomSliceShader(t){void 0===t&&(t="");const e=this.gl;if(this.customSliceShader&&(e.deleteProgram(this.customSliceShader.program),this.customSliceShader=null),!t)return void this.updateGLVolume();const i=new Ui(e,mi,t);i.use(e),e.uniform1i(i.uniforms.volume,0),e.uniform1i(i.uniforms.colormap,1),e.uniform1i(i.uniforms.overlay,2),e.uniform1i(i.uniforms.drawing,7),e.uniform1i(i.uniforms.paqd,8),e.uniform1f(i.uniforms.drawOpacity,this.drawOpacity),this.customSliceShader=i,this.updateGLVolume()}setCustomMeshShader(t,e){void 0===t&&(t=""),void 0===e&&(e="Custom");const i=this.createCustomMeshShader(t,e);return this.meshShaders.push(i),this.onCustomMeshShaderAdded(t,e),this.meshShaders.length-1}meshShaderNames(t){void 0===t&&(t=!0);const e=[];for(let i=0;i<this.meshShaders.length;i++)e.push(this.meshShaders[i].Name);return!0===t?e.sort():e}initRenderShader(t,e){void 0===e&&(e=0),t.use(this.gl),this.gl.uniform1i(t.uniforms.volume,0),this.gl.uniform1i(t.uniforms.colormap,1),this.gl.uniform1i(t.uniforms.overlay,2),this.gl.uniform1i(t.uniforms.drawing,7),this.gl.uniform1i(t.uniforms.paqd,8),this.gl.uniform1fv(t.uniforms.renderDrawAmbientOcclusion,[this.renderDrawAmbientOcclusion,1]),this.gl.uniform1f(t.uniforms.gradientAmount,e),this.gl.uniform1f(t.uniforms.silhouettePower,this.opts.renderSilhouette);const i=new Float32Array(li);for(let s=0;s<li;s++)0===this.opts.gradientOpacity?i[s]=1:i[s]=Math.pow(s/191,8*this.opts.gradientOpacity);this.gl.uniform1fv(this.gl.getUniformLocation(t.program,"gradientOpacity"),i)}async init(){const t=this.gl.getExtension("WEBGL_debug_renderer_info");if(t){const e=this.gl.getParameter(t.UNMASKED_VENDOR_WEBGL),i=this.gl.getParameter(t.UNMASKED_RENDERER_WEBGL);U.info("renderer vendor: ",e),U.info("renderer: ",i)}else U.info("debug_renderer_info unavailable");const e=this.gl.getParameter(this.gl.RENDERER);U.info("firefox renderer: ",e),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.FRONT),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.volumeTexture=this.rgbaTex(this.volumeTexture,Hi,[2,2,2,2],!0),this.overlayTexture=this.rgbaTex(this.overlayTexture,Zi,[2,2,2,2],!0),this.drawTexture=this.r8Tex(this.drawTexture,_i,[2,2,2,2],!0),this.paqdTexture=this.rgbaTex(this.paqdTexture,$i,[2,2,2,2],!0);const i=this.gl;this.cuboidVertexBuffer=i.createBuffer(),i.bindBuffer(i.ARRAY_BUFFER,this.cuboidVertexBuffer),i.bufferData(i.ARRAY_BUFFER,new Float32Array([1,1,0,1,0,0,0,1,0,0,0,0]),i.STATIC_DRAW),this.genericVAO=i.createVertexArray(),i.bindVertexArray(this.genericVAO),i.bindBuffer(i.ARRAY_BUFFER,this.cuboidVertexBuffer),i.enableVertexAttribArray(0),i.vertexAttribPointer(0,3,i.FLOAT,!1,0,0),i.bindVertexArray(this.unusedVAO),this.pickingMeshShader=new Ui(i,Ii,"#version 300 es\nprecision highp int;\nprecision highp float;\nuniform float opacity;\nout vec4 color;\nvec4 packFloatToVec4i(const float value) {\n\tconst vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n\tconst vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n\tvec4 res = fract(value * bitSh);\n\tres -= res.xxyz * bitMsk;\n\treturn res;\n}\nvoid main() {\n\tcolor = packFloatToVec4i(gl_FragCoord.z);\n}"),this.pickingMeshShader.use(i),this.pickingImageShader=new Ui(i,ei,Si),this.pickingImageShader.use(i),i.uniform1i(this.pickingImageShader.uniforms.volume,0),i.uniform1i(this.pickingImageShader.uniforms.colormap,1),i.uniform1i(this.pickingImageShader.uniforms.overlay,2),i.uniform1i(this.pickingImageShader.uniforms.drawing,7),this.slice2DShader=new Ui(i,mi,fi),this.slice2DShader.use(i),i.uniform1i(this.slice2DShader.uniforms.volume,0),i.uniform1i(this.slice2DShader.uniforms.colormap,1),i.uniform1i(this.slice2DShader.uniforms.overlay,2),i.uniform1i(this.slice2DShader.uniforms.drawing,7),i.uniform1f(this.slice2DShader.uniforms.drawOpacity,this.drawOpacity),this.sliceMMShader=new Ui(i,mi,Ai),this.sliceMMShader.use(i),i.uniform1i(this.sliceMMShader.uniforms.volume,0),i.uniform1i(this.sliceMMShader.uniforms.colormap,1),i.uniform1i(this.sliceMMShader.uniforms.overlay,2),i.uniform1i(this.sliceMMShader.uniforms.drawing,7),i.uniform1f(this.sliceMMShader.uniforms.drawOpacity,this.drawOpacity),this.sliceV1Shader=new Ui(i,mi,pi),this.sliceV1Shader.use(i),i.uniform1i(this.sliceV1Shader.uniforms.volume,0),i.uniform1i(this.sliceV1Shader.uniforms.colormap,1),i.uniform1i(this.sliceV1Shader.uniforms.overlay,2),i.uniform1i(this.sliceV1Shader.uniforms.drawing,7),i.uniform1f(this.sliceV1Shader.uniforms.drawOpacity,this.drawOpacity),this.orientCubeShader=new Ui(i,"#version 300 es\n// an attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer\nlayout(location=0)  in vec3 a_position;\nlayout(location=1)  in vec3 a_color;\n// A matrix to transform the positions by\nuniform mat4 u_matrix;\nout vec3 vColor;\n// all shaders have a main function\nvoid main() {\n\t// Multiply the position by the matrix.\n\tvec4 pos = vec4(a_position, 1.0);\n\tgl_Position = u_matrix * vec4(pos);\n\tvColor = a_color;\n}\n","#version 300 es\nprecision highp float;\nuniform vec4 u_color;\nin vec3 vColor;\nout vec4 outColor;\nvoid main() {\n\toutColor = vec4(vColor, 1.0);\n}"),this.orientCubeShaderVAO=i.createVertexArray(),i.bindVertexArray(this.orientCubeShaderVAO);const s=i.createBuffer();i.enableVertexAttribArray(0),i.enableVertexAttribArray(1),i.bindBuffer(i.ARRAY_BUFFER,s),i.bufferData(i.ARRAY_BUFFER,F,i.STATIC_DRAW),i.vertexAttribPointer(0,3,i.FLOAT,!1,24,0),i.enableVertexAttribArray(1),i.vertexAttribPointer(1,3,i.FLOAT,!1,24,12),i.bindVertexArray(this.unusedVAO),this.rectShader=new Ui(i,xi,vi),this.rectShader.use(i),this.rectOutlineShader=new Ui(i,xi,"#version 300 es\n#line 723\nprecision highp int;\nprecision highp float;\n\nuniform vec4 lineColor;\nuniform vec4 leftTopWidthHeight;\nuniform float thickness; // line thickness in pixels\nuniform vec2 canvasWidthHeight;\n\nout vec4 color;\n\nvoid main() {\n    // fragment position in screen coordinates\n    vec2 fragCoord = gl_FragCoord.xy;\n\n    // canvas height\n    float canvasHeight = canvasWidthHeight.y;\n\n    // 'top' and 'bottom' to match gl_FragCoord.y coordinate system\n    float top = canvasHeight - leftTopWidthHeight.y;\n    float bottom = top - leftTopWidthHeight.w;\n\n    // left and right edges\n    float left = leftTopWidthHeight.x;\n    float right = left + leftTopWidthHeight.z;\n\n    bool withinLeft = fragCoord.x >= left && fragCoord.x <= left + thickness;\n    bool withinRight = fragCoord.x <= right && fragCoord.x >= right - thickness;\n    bool withinTop = fragCoord.y <= top && fragCoord.y >= top - thickness;\n    bool withinBottom = fragCoord.y >= bottom && fragCoord.y <= bottom + thickness;\n\n    bool isOutline = withinLeft || withinRight || withinTop || withinBottom;\n\n    if (isOutline) {\n        color = lineColor;\n    } else {\n        discard; \n    }\n}"),this.rectOutlineShader.use(i),this.lineShader=new Ui(i,"#version 300 es\n#line 534\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform float thickness;\nuniform vec4 startXYendXY;\nvoid main(void) {\n\tvec2 posXY = mix(startXYendXY.xy, startXYendXY.zw, pos.x);\n\tvec2 dir = normalize(startXYendXY.xy - startXYendXY.zw);\n\tposXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);\n\tposXY.x = (posXY.x) / canvasWidthHeight.x; //0..1\n\tposXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0\n\tgl_Position = vec4((posXY * 2.0) - 1.0, 0.0, 1.0);\n}",vi),this.lineShader.use(i),this.line3DShader=new Ui(i,"#version 300 es\n#line 534\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform float thickness;\nuniform vec2 startXY;\nuniform vec3 endXYZ; // transformed XYZ point\nvoid main(void) {\t\n\tvec2 posXY = mix(startXY.xy, endXYZ.xy, pos.x);\n\tvec2 startDiff = endXYZ.xy - startXY.xy;\n\tfloat startDistance = length(startDiff);\n\tvec2 diff = endXYZ.xy - posXY;\n\tfloat currentDistance = length(diff);\n\tvec2 dir = normalize(startXY.xy - endXYZ.xy);\n\tposXY += vec2(-dir.y, dir.x) * thickness * (pos.y - 0.5);\n\tposXY.x = (posXY.x) / canvasWidthHeight.x; //0..1\n\tposXY.y = 1.0 - (posXY.y / canvasWidthHeight.y); //1..0\t\n\tfloat z = endXYZ.z * ( 1.0 - abs(currentDistance/startDistance)); \n\tgl_Position = vec4((posXY * 2.0) - 1.0, z, 1.0);\n}",vi),this.line3DShader.use(i),this.circleShader=new Ui(i,"#version 300 es\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform vec4 leftTopWidthHeight;\nuniform vec4 uvLeftTopWidthHeight;\nout vec2 vUV;\nvoid main(void) {\n\t//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1\n\tvec2 frac;\n\tfrac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1\n\tfrac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0\n\tfrac = (frac * 2.0) - 1.0;\n\tgl_Position = vec4(frac, 0.0, 1.0);\n\tvUV = pos.xy;\n}","#version 300 es\nprecision highp int;\nprecision highp float;\nuniform vec4 circleColor;\nuniform float fillPercent;\nin vec2 vUV;\nout vec4 color;\nvoid main() {\n\t/* Check if the pixel is inside the circle\n\t\t and color it with a gradient. Otherwise, color it \n\t\t transparent   */\n\tfloat distance = length(vUV-vec2(0.5,0.5));\n\tif ( distance < 0.5 && distance >= (1.0 - fillPercent) / 2.0){\n\t\t\tcolor = vec4(circleColor.r,circleColor.g,circleColor.b,circleColor.a) ;\t\t\t\n\t}else{\n\t\t\tcolor = vec4(0.0,0.0,0.0,0.0);\n\t}\n}\n"),this.circleShader.use(i),this.renderVolumeShader=new Ui(i,ei,ai),this.initRenderShader(this.renderVolumeShader),this.renderSliceShader=new Ui(i,ei,oi),this.initRenderShader(this.renderSliceShader),this.renderGradientShader=new Ui(i,ei,ci),this.initRenderShader(this.renderGradientShader,.3),i.uniform1i(this.renderGradientShader.uniforms.matCap,5),i.uniform1i(this.renderGradientShader.uniforms.gradient,6),this.renderGradientValuesShader=new Ui(i,ei,di),this.initRenderShader(this.renderGradientValuesShader),i.uniform1i(this.renderGradientValuesShader.uniforms.matCap,5),i.uniform1i(this.renderGradientValuesShader.uniforms.gradient,6),this.renderShader=this.renderVolumeShader,this.colorbarShader=new Ui(i,"#version 300 es\n#line 490\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform vec4 leftTopWidthHeight;\nout vec2 vColor;\nvoid main(void) {\n\t//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1\n\tvec2 frac;\n\tfrac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1\n\tfrac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0\n\tfrac = (frac * 2.0) - 1.0;\n\tgl_Position = vec4(frac, 0.0, 1.0);\n\tvColor = pos.xy;\n}","#version 300 es\n#line 506\nprecision highp int;\nprecision highp float;\nuniform highp sampler2D colormap;\nuniform float layer;\nin vec2 vColor;\nout vec4 color;\nvoid main() {\n\tfloat nlayer = float(textureSize(colormap, 0).y);\n\tfloat fmap = (0.5 + layer) / nlayer;\n\tcolor = vec4(texture(colormap, vec2(vColor.x, fmap)).rgb, 1.0);\n}"),this.colorbarShader.use(i),i.uniform1i(this.colorbarShader.uniforms.colormap,1),this.blurShader=new Ui(i,Fi,"#version 300 es\n#line 298\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float dX;\nuniform float dY;\nuniform float dZ;\nuniform highp sampler3D intensityVol;\nvoid main(void) {\n vec3 vx = vec3(TexCoord.xy, coordZ);\n vec4 samp = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));\n samp += texture(intensityVol,vx+vec3(+dX,+dY,-dZ));\n samp += texture(intensityVol,vx+vec3(+dX,-dY,+dZ));\n samp += texture(intensityVol,vx+vec3(+dX,-dY,-dZ));\n samp += texture(intensityVol,vx+vec3(-dX,+dY,+dZ));\n samp += texture(intensityVol,vx+vec3(-dX,+dY,-dZ));\n samp += texture(intensityVol,vx+vec3(-dX,-dY,+dZ));\n samp += texture(intensityVol,vx+vec3(-dX,-dY,-dZ));\n FragColor = samp*0.125;\n}"),this.sobelBlurShader=new Ui(i,Fi,"#version 300 es\n#line 298\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float dX;\nuniform float dY;\nuniform float dZ;\nuniform highp sampler3D intensityVol;\nvoid main(void) {\n vec3 vx = vec3(TexCoord.xy, coordZ);\n vec4 XYZ = texture(intensityVol,vx+vec3(+dX,+dY,+dZ));\n vec4 OYZ = texture(intensityVol,vx+vec3(0.0,+dY,+dZ));\n vec4 xYZ = texture(intensityVol,vx+vec3(-dX,+dY,+dZ));\n vec4 XOZ = texture(intensityVol,vx+vec3(+dX,0.0,+dZ));\n vec4 OOZ = texture(intensityVol,vx+vec3(0.0,0.0,+dZ));\n vec4 xOZ = texture(intensityVol,vx+vec3(-dX,0.0,+dZ));\n vec4 XyZ = texture(intensityVol,vx+vec3(+dX,-dY,+dZ));\n vec4 OyZ = texture(intensityVol,vx+vec3(0.0,-dY,+dZ));\n vec4 xyZ = texture(intensityVol,vx+vec3(-dX,-dY,+dZ));\n\n vec4 XYO = texture(intensityVol,vx+vec3(+dX,+dY,0.0));\n vec4 OYO = texture(intensityVol,vx+vec3(0.0,+dY,0.0));\n vec4 xYO = texture(intensityVol,vx+vec3(-dX,+dY,0.0));\n vec4 XOO = texture(intensityVol,vx+vec3(+dX,0.0,0.0));\n vec4 OOO = texture(intensityVol,vx+vec3(0.0,0.0,0.0));\n vec4 xOO = texture(intensityVol,vx+vec3(-dX,0.0,0.0));\n vec4 XyO = texture(intensityVol,vx+vec3(+dX,-dY,0.0));\n vec4 OyO = texture(intensityVol,vx+vec3(0.0,-dY,0.0));\n vec4 xyO = texture(intensityVol,vx+vec3(-dX,-dY,0.0));\n\n vec4 XYz = texture(intensityVol,vx+vec3(+dX,+dY,-dZ));\n vec4 OYz = texture(intensityVol,vx+vec3(0.0,+dY,-dZ));\n vec4 xYz = texture(intensityVol,vx+vec3(-dX,+dY,-dZ));\n vec4 XOz = texture(intensityVol,vx+vec3(+dX,0.0,-dZ));\n vec4 OOz = texture(intensityVol,vx+vec3(0.0,0.0,-dZ));\n vec4 xOz = texture(intensityVol,vx+vec3(-dX,0.0,-dZ));\n vec4 Xyz = texture(intensityVol,vx+vec3(+dX,-dY,-dZ));\n vec4 Oyz = texture(intensityVol,vx+vec3(0.0,-dY,-dZ));\n vec4 xyz = texture(intensityVol,vx+vec3(-dX,-dY,-dZ));\n\n vec4 blurred = vec4 (0.0, 0.0, 0.0, 0.0);\n blurred.r = 2.0*(xOz.r +xOZ.r +xyO.r +xYO.r +xOO.r +XOz.r +XOZ.r +XyO.r +XYO.r +XOO.r) +xyz.r +xyZ.r +xYz.r +xYZ.r +Xyz.r +XyZ.r +XYz.r +XYZ.r;\n blurred.g = 2.0*(Oyz.r +OyZ.r +xyO.r +XyO.r +OyO.r +OYz.r +OYZ.r +xYO.r +XYO.r +OYO.r) +xyz.r +Xyz.r +xyZ.r +XyZ.r +xYz.r +XYz.r +xYZ.r +XYZ.r;\n blurred.b = 2.0*(Oyz.r +OYz.r +xOz.r +XOz.r +OOz.r +OyZ.r +OYZ.r +xOZ.r +XOZ.r +OOZ.r) +xyz.r +Xyz.r +xYz.r +XYz.r +xyZ.r +XyZ.r +XyZ.r +XYZ.r;\n blurred.a = 0.32*(abs(blurred.r)+abs(blurred.g)+abs(blurred.b));\n // 0.0357 = 1/28 to account for weights, rescale to 2**16,\n FragColor = 0.0357*blurred;\n}"),this.sobelFirstOrderShader=new Ui(i,Fi,Bi),this.sobelSecondOrderShader=new Ui(i,Fi,Vi),this.growCutShader=new Ui(i,"#version 300 es\n#line 808\nprecision highp int;\nprecision highp float;\nin vec3 vPos;\nout vec2 TexCoord;\nvoid main() {\n\tTexCoord = vPos.xy;\n\tgl_Position = vec4((vPos.x - 0.5) * 2.0, (vPos.y - 0.5) * 2.0, 0.0, 1.0);\n}","#version 300 es\n#line 829\n\tprecision highp float;\n\tprecision highp int;\n\tprecision highp isampler3D;\n\tlayout(location = 0) out int label;\n\tlayout(location = 1) out int strength;\n\tin vec2 TexCoord;\n\tuniform int finalPass;\n\tuniform float coordZ;\n\tuniform lowp sampler3D in3D;\n\tuniform highp isampler3D backTex; // background\n\tuniform highp isampler3D labelTex; // label\n\tuniform highp isampler3D strengthTex; // strength\nvoid main(void) {\n\tvec3 interpolatedTextureCoordinate = vec3(TexCoord.xy, coordZ);\n\tivec3 size = textureSize(backTex, 0);\n\tivec3 texelIndex = ivec3(floor(interpolatedTextureCoordinate * vec3(size)));\n\tint background = texelFetch(backTex, texelIndex, 0).r;\n\tlabel = texelFetch(labelTex, texelIndex, 0).r;\n\tstrength = texelFetch(strengthTex, texelIndex, 0).r;\n\tfor (int k = -1; k <= 1; k++) {\n\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tif (i != 0 && j != 0 && k != 0) {\n\t\t\t\t\tivec3 neighborIndex = texelIndex + ivec3(i,j,k);\n\t\t\t\t\tint neighborBackground = texelFetch(backTex, neighborIndex, 0).r;\n\t\t\t\t\tint neighborStrength = texelFetch(strengthTex, neighborIndex, 0).r;\n\t\t\t\t\tint strengthCost = abs(neighborBackground - background);\n\t\t\t\t\tint takeoverStrength = neighborStrength - strengthCost;\n\t\t\t\t\tif (takeoverStrength > strength) {\n\t\t\t\t\t\tstrength = takeoverStrength;\n\t\t\t\t\t\tlabel = texelFetch(labelTex, neighborIndex, 0).r;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (finalPass < 1)\n\t\treturn;\n\tint ok = 1;\n\tivec4 labelCount = ivec4(0,0,0,0);\n\tfor (int k = -1; k <= 1; k++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tivec3 neighborIndex = texelIndex + ivec3(i,j,k);\n\t\t\t\tint ilabel = texelFetch(labelTex, neighborIndex, 0).r;\n\t\t\t\tif ((ilabel < 0) || (ilabel > 3))\n\t\t\t\t\tok = 0;\n\t\t\t\telse\n\t\t\t\t\tlabelCount[ilabel]++;\n\t\t\t}\n\tif (ok != 1) {\n\t\treturn;\n\t}\n\tint maxIdx = 0;\n\tfor (int i = 1; i < 4; i++) {\n\t\tif (labelCount[i] > labelCount[maxIdx])\n\t\t\tmaxIdx = i;\n\t}\n\tlabel = maxIdx;\n}"),this.passThroughShader=new Ui(i,"#version 300 es\n#line 1359\nprecision highp int;\nprecision highp float;\nin vec3 vPos;\nout vec2 TexCoord;\nvoid main() {\n\tTexCoord = vPos.xy;\n\tvec2 viewCoord = (vPos.xy - 0.5) * 2.0;\n\tgl_Position = vec4((vPos.xy - 0.5) * 2.0, 0.0, 1.0);\n}","#version 300 es\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform lowp sampler3D in3D;\nvoid main(void) {\n FragColor = texture(in3D, vec3(TexCoord.xy, coordZ));\n}"),this.orientShaderAtlasU=new Ui(i,wi,bi.concat(Mi)),this.orientShaderAtlasI=new Ui(i,wi,yi.concat(Mi)),this.orientShaderU=new Ui(i,wi,bi.concat(Di)),this.orientShaderI=new Ui(i,wi,yi.concat(Di)),this.orientShaderF=new Ui(i,wi,Ci.concat(Di)),this.orientShaderRGBU=new Ui(i,wi,bi.concat("#line 773\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float layer;\nuniform float scl_slope;\nuniform float scl_inter;\nuniform float cal_max;\nuniform float cal_min;\nuniform highp sampler2D colormap;\nuniform lowp sampler3D blend3D;\nuniform float opacity;\nuniform mat4 mtx;\nuniform bool hasAlpha;\nuniform int modulation;\nuniform highp sampler3D modulationVol;\nvoid main(void) {\n\tvec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;\n\tuvec4 aColor = texture(intensityVol, vx.xyz);\n\tFragColor = vec4(float(aColor.r) / 255.0, float(aColor.g) / 255.0, float(aColor.b) / 255.0, float(aColor.a) / 255.0);\n\tif (modulation == 1)\n\t\tFragColor.rgb *= texture(modulationVol, vx.xyz).r;\n\tif (!hasAlpha) {\n\t\tFragColor.a = (FragColor.r * 0.21 + FragColor.g * 0.72 + FragColor.b * 0.07);\n\t\t//next line: we could binarize alpha, but see rendering of visible human\n\t\t//FragColor.a = step(0.01, FragColor.a);\n\t}\n\tif (modulation == 2)\n\t\tFragColor.a = texture(modulationVol, vx.xyz).r;\n\tFragColor.a *= opacity;\n\tif (layer < 1.0) return;\n\tvec4 prevColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n\t// https://en.wikipedia.org/wiki/Alpha_compositing\n\tfloat aout = FragColor.a + (1.0 - FragColor.a) * prevColor.a;\n\tif (aout <= 0.0) return;\n\tFragColor.rgb = ((FragColor.rgb * FragColor.a) + (prevColor.rgb * prevColor.a * (1.0 - FragColor.a))) / aout;\n\tFragColor.a = aout;\n}")),this.orientShaderPAQD=new Ui(i,wi,bi.concat("#line 773\nprecision highp int;\nprecision highp float;\nin vec2 TexCoord;\nout vec4 FragColor;\nuniform float coordZ;\nuniform float layer;\nuniform float scl_slope;\nuniform float scl_inter;\nuniform float cal_max;\nuniform float cal_min;\nuniform highp sampler2D colormap;\nuniform lowp sampler3D blend3D;\nuniform float opacity;\nuniform mat4 mtx;\nuniform bool hasAlpha;\nuniform int modulation;\nuniform highp sampler3D modulationVol;\nfloat textureWidth;\nfloat nlayer;\nfloat layerY;\n\nvec4 scalar2color(uint idx) {\n\tfloat fx = (float(idx) + 0.5) / textureWidth;\n\tvec4 clr = texture(colormap, vec2(fx, layerY)).rgba;\n\tif (clr.a > 0.0)\n\t\tclr.a = 1.0;\n\tclr.a *= opacity;\n\treturn clr;\n}\n\nvec4 paqd2color(uvec4 rgba) {\n  // paqd r: max prob index, g: 2nd index, b: max prob a: 2nd prob\n  float prob1 = float(rgba.b)/255.0;\n  float prob2 = float(rgba.a)/255.0;\n  vec4 clr1 = scalar2color(rgba.r);\n  vec4 clr2 = scalar2color(rgba.g);\n  float total = prob1 + prob2;\n  vec4 clr = vec4(clr1.rgb, total);\n  // vec4 clr = vec4(clr1.rgb, prob1);\n  if (total > 0.0) {\n    clr.rgb = mix(clr2.rgb, clr1.rgb, prob1 / total);\n  }\n  return clr;\n}\nvoid main(void) {\n\tvec4 vx = vec4(TexCoord.xy, coordZ, 1.0) * mtx;\n\tivec3 voxelCoord = ivec3(vx.xyz * vec3(textureSize(intensityVol, 0)));\n\tuvec4 rgba = texelFetch(intensityVol, voxelCoord, 0);\n\tFragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\tif (rgba.r > uint(0)) {\n\t\ttextureWidth = float(textureSize(colormap, 0).x);\n\t\tnlayer = float(textureSize(colormap, 0).y);\n\t\tlayerY = ((2.0 * layer) + 1.5) / nlayer;\n\t\tFragColor = paqd2color(rgba);\n\t\treturn;\n\t}\n\t// if (layer > 2.0) return;\n\t// FragColor = texture(blend3D, vec3(TexCoord.xy, coordZ));\n}")),this.surfaceShader=new Ui(i,"#version 300 es\nlayout(location=0) in vec3 pos;\nuniform mat4 mvpMtx;\nvoid main(void) {\n\tgl_Position = mvpMtx * vec4(pos, 1.0);\n}","#version 300 es\nprecision highp int;\nprecision highp float;\nuniform vec4 surfaceColor;\nout vec4 color;\nvoid main() {\n\tcolor = surfaceColor;\n}"),this.surfaceShader.use(i),this.fiberShader=new Ui(i,"#version 300 es\nlayout(location=0) in vec3 pos;\nlayout(location=1) in vec4 clr;\nout vec4 vClr;\nuniform mat4 mvpMtx;\nvoid main(void) {\n\tgl_Position = mvpMtx * vec4(pos, 1.0);\n\tvClr = clr;\n}","#version 300 es\nprecision highp int;\nprecision highp float;\nin vec4 vClr;\nout vec4 color;\nuniform float opacity;\nvoid main() {\n\tcolor = vec4(vClr.rgb, opacity);\n}"),this.pickingImageShader.use(i);for(let r=0;r<this.meshShaders.length;r++){const t=this.meshShaders[r];"Flat"===t.Name?t.shader=new Ui(i,"#version 300 es\nlayout(location=0) in vec3 pos;\nlayout(location=1) in vec4 norm;\nlayout(location=2) in vec4 clr;\nuniform mat4 mvpMtx;\n//uniform mat4 modelMtx;\nuniform mat4 normMtx;\nout vec4 vClr;\nflat out vec3 vN;\nvoid main(void) {\n\tgl_Position = mvpMtx * vec4(pos, 1.0);\n\tvN = normalize((normMtx * vec4(norm.xyz,1.0)).xyz);\n\t//vV = -vec3(modelMtx*vec4(pos,1.0));\n\tvClr = clr;\n}",Ti):t.shader=new Ui(i,Ii,t.Frag),t.shader.use(i),t.shader.isMatcap="Matcap"===t.Name,t.shader.isMatcap&&i.uniform1i(t.shader.uniforms.matCap,5)}return this.bmpShader=new Ui(i,"#version 300 es\n#line 549\nlayout(location=0) in vec3 pos;\nuniform vec2 canvasWidthHeight;\nuniform vec4 leftTopWidthHeight;\nout vec2 vUV;\nvoid main(void) {\n\t//convert pixel x,y space 1..canvasWidth,1..canvasHeight to WebGL 1..-1,-1..1\n\tvec2 frac;\n\tfrac.x = (leftTopWidthHeight.x + (pos.x * leftTopWidthHeight.z)) / canvasWidthHeight.x; //0..1\n\tfrac.y = 1.0 - ((leftTopWidthHeight.y + ((1.0 - pos.y) * leftTopWidthHeight.w)) / canvasWidthHeight.y); //1..0\n\tfrac = (frac * 2.0) - 1.0;\n\tgl_Position = vec4(frac, 0.0, 1.0);\n\tvUV = vec2(pos.x, 1.0 - pos.y);\n}","#version 300 es\n#line 565\nprecision highp int;\nprecision highp float;\nuniform highp sampler2D bmpTexture;\nin vec2 vUV;\nout vec4 color;\nvoid main() {\n\tcolor = texture(bmpTexture, vUV);\n}"),await this.initText(),this.opts.thumbnail.length>0&&(await this.loadBmpTexture(this.opts.thumbnail),this.thumbnailVisible=!0),this.updateGLVolume(),this.initialized=!0,this.resizeListener(),this.drawScene(),this}gradientGL(t){const e=this.gl;e.bindVertexArray(this.genericVAO);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.viewport(0,0,t.dims[1],t.dims[2]),e.disable(e.BLEND);const s=this.rgbaTex(null,33992,t.dims,!0),r=2===this.opts.gradientOrder?this.sobelBlurShader:this.blurShader;r.use(e),e.activeTexture(Hi),e.bindTexture(e.TEXTURE_3D,this.volumeTexture),e.texParameteri(e.TEXTURE_3D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_3D,e.TEXTURE_MAG_FILTER,e.LINEAR);e.uniform1i(r.uniforms.intensityVol,0),e.uniform1f(r.uniforms.dX,.7/t.dims[1]),e.uniform1f(r.uniforms.dY,.7/t.dims[2]),e.uniform1f(r.uniforms.dZ,.7/t.dims[3]);for(let a=0;a<t.dims[3]-1;a++){const i=1/t.dims[3]*(a+.5);e.uniform1f(r.uniforms.coordZ,i),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,s,0,a);const n=e.checkFramebufferStatus(e.FRAMEBUFFER);n!==e.FRAMEBUFFER_COMPLETE&&U.error("blur shader: ",n),e.drawArrays(e.TRIANGLE_STRIP,0,4)}const n=2===this.opts.gradientOrder?this.sobelSecondOrderShader:this.sobelFirstOrderShader;n.use(e),e.activeTexture(33992),e.bindTexture(e.TEXTURE_3D,s),e.texParameteri(e.TEXTURE_3D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_3D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.uniform1i(n.uniforms.intensityVol,8);const o=.7;e.uniform1f(n.uniforms.dX,o/t.dims[1]),e.uniform1f(n.uniforms.dY,o/t.dims[2]),e.uniform1f(n.uniforms.dZ,o/t.dims[3]),2===this.opts.gradientOrder&&(e.uniform1f(n.uniforms.dX2,1.4/t.dims[1]),e.uniform1f(n.uniforms.dY2,1.4/t.dims[2]),e.uniform1f(n.uniforms.dZ2,1.4/t.dims[3])),e.uniform1f(n.uniforms.coordZ,.5),null!==this.gradientTexture&&e.deleteTexture(this.gradientTexture),this.gradientTexture=this.rgbaTex(this.gradientTexture,Ji,t.dims);for(let a=0;a<t.dims[3]-1;a++){const i=1/t.dims[3]*(a+.5);e.uniform1f(n.uniforms.coordZ,i),e.framebufferTextureLayer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,this.gradientTexture,0,a);const s=e.checkFramebufferStatus(e.FRAMEBUFFER);s!==e.FRAMEBUFFER_COMPLETE&&U.error("sobel shader: ",s),e.drawArrays(e.TRIANGLE_STRIP,0,4)}e.deleteFramebuffer(i),e.deleteTexture(s),e.bindFramebuffer(e.FRAMEBUFFER,null),e.activeTexture($i),e.bindTexture(e.TEXTURE_3D,this.paqdTexture),this.gl.bindVertexArray(this.unusedVAO)}getGradientTextureData(){if(!this.gradientTexture||!this.back)return null;const t=this.gl,e=this.back.dims,i=e[1],s=e[2],r=e[3],n=i*s*r,o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o);const a=new Float32Array(4*n);try{for(let e=0;e<r;e++){t.framebufferTextureLayer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,this.gradientTexture,0,e);const r=t.checkFramebufferStatus(t.FRAMEBUFFER);if(r===t.FRAMEBUFFER_COMPLETE)try{const r=new Uint8Array(i*s*4);t.readPixels(0,0,i,s,t.RGBA,t.UNSIGNED_BYTE,r);const n=new Float32Array(i*s*4);for(let t=0;t<r.length;t++)n[t]=r[t]/127.5-1;const o=e*i*s*4;a.set(n,o)}catch(l){console.warn("Failed to read pixels for slice",e,":",l);const t=e*i*s*4,r=new Float32Array(i*s*4);a.set(r,t)}else console.warn("Framebuffer not complete for gradient texture reading, slice",e,"status:",r.toString(16))}}catch(h){return console.error("Error reading gradient texture:",h),null}finally{t.deleteFramebuffer(o),t.bindFramebuffer(t.FRAMEBUFFER,null)}return a}setCustomGradientTexture(t,e){const i=this.gl;if(null===t)return this.useCustomGradientTexture=!1,void(this.back&&this.gradientTextureAmount>0&&this.gradientGL(this.back.hdr));if(!e&&!this.back)return void console.warn("No dimensions provided and no background volume loaded");const s=e||this.back.dims,r=s[1],n=s[2],o=s[3],a=r*n*o*4;if(t.length!==a)return void console.warn(`Custom gradient data size mismatch. Expected ${a}, got ${t.length}`);let l;if(this.useCustomGradientTexture=!0,null!==this.gradientTexture&&i.deleteTexture(this.gradientTexture),this.gradientTexture=i.createTexture(),i.activeTexture(Ji),i.bindTexture(i.TEXTURE_3D,this.gradientTexture),i.texParameteri(i.TEXTURE_3D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_3D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_3D,i.TEXTURE_WRAP_R,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_3D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_3D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.pixelStorei(i.UNPACK_ALIGNMENT,1),t instanceof Float32Array){l=new Uint8Array(t.length);for(let e=0;e<t.length;e++){const i=Math.max(-1,Math.min(1,t[e]));l[e]=Math.round(127.5*(i+1))}}else l=t;i.texStorage3D(i.TEXTURE_3D,1,i.RGBA8,r,n,o),i.texSubImage3D(i.TEXTURE_3D,0,0,0,0,r,n,o,i.RGBA,i.UNSIGNED_BYTE,l),this.drawScene()}updateGLVolume(){let t=0;const e=this.volumes.length;this.refreshColormaps(),this.closePAQD();for(let i=0;i<e;i++)this.volumes[i].toRAS&&(this.refreshLayers(this.volumes[i],t),t++);if(this.furthestVertexFromOrigin=0,e>0&&(this.furthestVertexFromOrigin=this.volumeObject3D?.furthestVertexFromOrigin??0),this.meshes)for(let i=0;i<this.meshes.length;i++)this.furthestVertexFromOrigin=Math.max(this.furthestVertexFromOrigin,this.meshes[i].furthestVertexFromOrigin);this.onVolumeUpdated&&this.onVolumeUpdated(),this.drawScene()}getDescriptives(t){const{layer:e=0,masks:i=[],drawingIsMask:s=!1,roiIsMask:r=!1,startVox:n=[0,0,0],endVox:o=[0,0,0]}=t;let a=null;const l=this.volumes[e].hdr,h=this.volumes[e].pixDimsRAS;let c=l.scl_slope;isNaN(c)&&(c=1);let d=l.scl_inter;isNaN(d)&&(d=1);const m=this.volumes[e].img,u=m.length,f=new Float32Array(u);for(let S=0;S<u;S++)f[S]=m[S]*c+d;const g=new Uint8Array(u);for(let S=0;S<u;S++)g[S]=1;if(i.length>0)for(let S=0;S<i.length;S++){const t=this.volumes[i[S]].img;if(t.length===u)for(let e=0;e<u;e++)(0===t[e]||isNaN(t[e]))&&(g[e]=0);else U.debug("Mask resolution does not match image. Skipping masking layer "+i[S])}else if(i.length<1&&s)for(let S=0;S<u;S++)(0===this.drawBitmap[S]||isNaN(this.drawBitmap[S]))&&(g[S]=0);else if(i.length<1&&r){g.fill(0);let t=-1;if(n[0]===o[0])t=0;else if(n[1]===o[1])t=1;else{if(n[2]!==o[2])return void console.error("Error: No constant dimension found.");t=2}const e=[0,1,2].filter((e=>e!==t)),i=[];i[t]=n[t],i[e[0]]=(n[e[0]]+o[e[0]])/2,i[e[1]]=(n[e[1]]+o[e[1]])/2;const s=Math.abs(o[e[0]]-n[e[0]])/2,r=Math.abs(o[e[1]]-n[e[1]])/2,c=l.dims[1],d=l.dims[2],m=Math.max(0,Math.floor(i[e[0]]-s)),u=Math.min(l.dims[e[0]+1]-1,Math.ceil(i[e[0]]+s)),f=Math.max(0,Math.floor(i[e[1]]-r)),A=Math.min(l.dims[e[1]+1]-1,Math.ceil(i[e[1]]+r)),p=i[t];if(p<0||p>=l.dims[t+1])return void console.error("Error: Constant dimension value is out of bounds.");for(let n=m;n<=u;n++)for(let o=f;o<=A;o++){const a=[];a[t]=p,a[e[0]]=n,a[e[1]]=o;const l=(a[e[0]]-i[e[0]])/s,h=(a[e[1]]-i[e[1]])/r;if(l*l+h*h<=1){const t=a[0],e=a[1];g[a[2]*c*d+e*c+t]=1}}const v=s*h[e[0]+1],x=r*h[e[1]+1];a=Math.PI*v*x}let A=0,p=0,v=0,x=Number.NEGATIVE_INFINITY,w=Number.POSITIVE_INFINITY,b=0,y=0,C=0;for(let S=0;S<u;S++){if(g[S]<1)continue;const t=f[S];A++;let e=p+(t-p)/A;v+=(t-p)*(t-e),p=e,0!==t&&(b++,e=y+(t-y)/b,C+=(t-y)*(t-e),y=e,w=Math.min(t,w),x=Math.max(t,x))}const M=Math.sqrt(v/(A-1)),D=Math.sqrt(C/(b-1)),I=w,T=x;return A!==b&&(w=Math.min(0,w),x=Math.max(0,x)),{mean:p,stdev:M,nvox:A,volumeMM3:A*l.pixDims[1]*l.pixDims[2]*l.pixDims[3],volumeML:A*l.pixDims[1]*l.pixDims[2]*l.pixDims[3]*.001,min:w,max:x,meanNot0:y,stdevNot0:D,nvoxNot0:b,minNot0:I,maxNot0:T,cal_min:this.volumes[e].cal_min,cal_max:this.volumes[e].cal_max,robust_min:this.volumes[e].robust_min,robust_max:this.volumes[e].robust_max,area:a}}refreshLayers(t,e){if(this.volumes.length<1)return;this.refreshColormaps();const i=t.hdr;let s=t.img;t.frame4D>0&&t.frame4D<t.nFrame4D&&(s=t.img.slice(t.frame4D*t.nVox3D,(t.frame4D+1)*t.nVox3D));const o=t.opacity;if(e>1&&0===o)return;let a=null;if(!this.back)throw new Error("back undefined");this.gl.bindVertexArray(this.unusedVAO),this.crosshairs3D&&(this.crosshairs3D.mm[0]=NaN);let l=n.o8(t.toRAS);if(0===e){this.volumeObject3D=Xe(t,this.VOLUME_ID,this.gl),n.B8(l,l),this.back.matRAS=t.matRAS,this.back.dims=t.dimsRAS,this.back.pixDims=t.pixDimsRAS;const{volScale:e,vox:r}=this.sliceScale(!0);this.volScale=e,this.vox=r,this.volumeObject3D.scale=e;(i.dims[1]>this.uiData.max2D||i.dims[2]>this.uiData.max2D)&&U.error("Image dimensions exceed maximum texture size of hardware.");const o=i.dims[1]>this.uiData.max3D||i.dims[2]>this.uiData.max3D||i.dims[3]>this.uiData.max3D;if(o&&2304===i.datatypeCode&&i.dims[3]<2)return U.info(`Large RGBA image (>${this.uiData.max3D}) requires Texture2D`),this.opts.is2DSliceShader=!0,void(a=this.rgbaTex2D(this.volumeTexture,Hi,t.dimsRAS,s));if(o){U.info(`Large scalar image (>${this.uiData.max3D}) requires Texture2D (${i.dims[1]}\xd7${i.dims[2]}\xd7${i.dims[3]})`);const e=i.dims[1]*i.dims[2],r=this.frac2vox(this.scene.crosshairPos),n=Math.min(Math.max(r[2],0),i.dims[3]-1)*e,o=new Uint8Array(4*e),l=new Uint32Array(o.buffer),h=Math.floor(255*t.opacity),c=255*i.scl_slope/(t.cal_max-t.cal_min),d=255*(i.scl_inter-t.cal_min)/(t.cal_max-t.cal_min),m=new Uint8Array(this.colormap(t.colormap)),u=new Uint32Array(m.buffer);let f=-1;for(let t=0;t<e;t++){const e=s[t+n]*c+d,i=Math.round(Math.min(255,Math.max(0,e)));l[t]=u[i],o[f+=4]=h}return this.opts.is2DSliceShader=!0,void(a=this.rgbaTex2D(this.volumeTexture,Hi,t.dimsRAS,o,!1))}if(o&&U.warn(`dimensions exceed 3D limits ${i.dims}`),this.opts.is2DSliceShader=!1,a=this.rgbaTex(this.volumeTexture,Hi,t.dimsRAS),!this.renderShader)throw new Error("renderShader undefined");this.renderShader.use(this.gl),this.gl.uniform3fv(this.renderShader.uniforms.texVox,r),this.gl.uniform3fv(this.renderShader.uniforms.volScale,e);const h=this.pickingImageShader;h.use(this.gl),this.gl.uniform1i(h.uniforms.volume,0),this.gl.uniform1i(h.uniforms.colormap,1),this.gl.uniform1i(h.uniforms.overlay,2),this.gl.uniform3fv(h.uniforms.volScale,e),U.debug(this.volumeObject3D)}else{void 0===this.back?.dims&&U.error("Fatal error: Unable to render overlay: background dimensions not defined!");const i=this.mm2frac(t.mm000,0,!0);let s=this.mm2frac(t.mm100,0,!0),o=this.mm2frac(t.mm010,0,!0),h=this.mm2frac(t.mm001,0,!0);s=r.Re(s,s,i),o=r.Re(o,o,i),h=r.Re(h,h,i),l=n.fA(s[0],o[0],h[0],i[0],s[1],o[1],h[1],i[1],s[2],o[2],h[2],i[2],0,0,0,1),n.B8(l,l),1===e?(a=this.rgbaTex(this.overlayTexture,Zi,this.back.dims),this.overlayTexture=a,this.overlayTextureID=a):a=this.overlayTextureID}const h=this.gl.createFramebuffer();this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,h),this.gl.disable(this.gl.CULL_FACE),this.gl.viewport(0,0,this.back.dims[1],this.back.dims[2]),this.gl.disable(this.gl.BLEND);const c=this.gl.createTexture();this.gl.activeTexture(33993),this.gl.bindTexture(this.gl.TEXTURE_3D,c),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1);let d=this.orientShaderU;if(!i)throw new Error("hdr undefined");if(!s)throw new Error("img undefined");if(2===i.datatypeCode)1002===i.intent_code&&(d=this.orientShaderAtlasU),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.UNSIGNED_BYTE,s);else if(4===i.datatypeCode)d=this.orientShaderI,1002===i.intent_code&&(d=this.orientShaderAtlasI),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16I,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.SHORT,s);else if(16===i.datatypeCode)this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R32F,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.FLOAT,s),d=this.orientShaderF;else if(64===i.datatypeCode){let t=new Float32Array;t=Float32Array.from(s),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R32F,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.FLOAT,t),d=this.orientShaderF}else if(128===i.datatypeCode)d=this.orientShaderRGBU,d.use(this.gl),this.gl.uniform1i(d.uniforms.hasAlpha,0),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGB8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RGB_INTEGER,this.gl.UNSIGNED_BYTE,s);else if(512===i.datatypeCode)1002===i.intent_code&&(d=this.orientShaderAtlasU),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.R16UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED_INTEGER,this.gl.UNSIGNED_SHORT,s);else if(2304===i.datatypeCode){if(d=this.orientShaderRGBU,t.colormapLabel){d=this.orientShaderPAQD;let t=!0;for(let i=0;i<e;i++){const e=2304===this.volumes[i].hdr.datatypeCode,s=!!this.volumes[i].colormapLabel;e&&s&&(t=!1)}t?this.paqdTexture=this.rgbaTex(this.paqdTexture,$i,this.back.dims):U.warn("Current version only one probabilistic atlas (PAQD) at a time"),a=this.paqdTexture,this.gl.activeTexture(33993)}d.use(this.gl),this.gl.uniform1i(d.uniforms.hasAlpha,1),this.gl.texStorage3D(this.gl.TEXTURE_3D,1,this.gl.RGBA8UI,i.dims[1],i.dims[2],i.dims[3]),this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RGBA_INTEGER,this.gl.UNSIGNED_BYTE,s)}void 0===t.global_min&&t.calMinMax();let m=null;this.gl.bindVertexArray(this.genericVAO);if(e>1){if(!this.back.dims)throw new Error("back.dims undefined");m=this.rgbaTex(m,ts,this.back.dims),this.gl.bindTexture(this.gl.TEXTURE_3D,m);const t=this.passThroughShader;t.use(this.gl),this.gl.uniform1i(t.uniforms.in3D,2);for(let e=0;e<this.back.dims[3];e++){const i=1/this.back.dims[3]*(e+.5);this.gl.uniform1f(t.uniforms.coordZ,i),this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,m,0,e),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}}else m=this.rgbaTex(m,ts,[2,2,2,2]);d.use(this.gl),this.gl.activeTexture(qi);let u=null;if(null!==t.colormapLabel&&t.colormapLabel.lut.length>7){const e=t.colormapLabel.max-t.colormapLabel.min+1;u=this.createColormapTexture(u,1,e),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,e,1,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t.colormapLabel.lut),this.gl.uniform1f(d.uniforms.cal_min,t.colormapLabel.min-.5),this.gl.uniform1f(d.uniforms.cal_max,t.colormapLabel.max+.5),this.gl.bindTexture(this.gl.TEXTURE_2D,u)}else this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture),this.gl.uniform1f(d.uniforms.cal_min,t.cal_min),this.gl.uniform1f(d.uniforms.cal_max,t.cal_max);"alphaThreshold"in t&&(U.warn("alphaThreshold is deprecated: use colormapType"),!0===t.alphaThreshold&&(t.colormapType=2),!1===t.alphaThreshold&&(t.colormapType=1),delete t.alphaThreshold);const f=0!==t.colormapType?1:0,g=2===t.colormapType?1:0;this.gl.uniform1i(d.uniforms.isAlphaThreshold,g),this.gl.uniform1i(d.uniforms.isColorbarFromZero,f),this.gl.uniform1i(d.uniforms.isAdditiveBlend,this.opts.isAdditiveBlend?1:0);let A=Number.POSITIVE_INFINITY,p=Number.NEGATIVE_INFINITY;if(t.colormapNegative.length>0&&(A=Math.min(-t.cal_min,-t.cal_max),p=Math.max(-t.cal_min,-t.cal_max),isFinite(t.cal_minNeg)&&isFinite(t.cal_maxNeg)&&(A=Math.min(t.cal_minNeg,t.cal_maxNeg),p=Math.max(t.cal_minNeg,t.cal_maxNeg))),e>0&&this.overlayOutlineWidth>0){const e=t.cal_min,i=t.cal_max;let s=Math.min(e,i)<=0&&Math.max(e,i)>=0;!s&&A<p&&(s=A<=0&&p>=0),s&&U.error("issue1139: do not use overlayOutlineWidth when thresholds cross or touch zero")}if(!d)throw new Error("orientShader undefined");this.gl.uniform1f(d.uniforms.layer??null,e),this.gl.uniform1f(d.uniforms.cal_minNeg??null,A),this.gl.uniform1f(d.uniforms.cal_maxNeg??null,p),this.gl.bindTexture(this.gl.TEXTURE_3D,c),this.gl.uniform1i(d.uniforms.intensityVol??null,9),this.gl.uniform1i(d.uniforms.blend3D??null,10),this.gl.uniform1i(d.uniforms.colormap??null,1),this.gl.uniform1f(d.uniforms.scl_inter??null,i.scl_inter),this.gl.uniform1f(d.uniforms.scl_slope??null,i.scl_slope),this.gl.uniform1f(d.uniforms.opacity??null,o),this.gl.uniform1i(d.uniforms.modulationVol??null,7);let v=null;if(null!==t.modulationImage&&t.modulationImage>=0&&t.modulationImage<this.volumes.length){U.debug("modulating",this.volumes);const e=this.volumes[t.modulationImage].hdr;if(e.dims[1]===i.dims[1]&&e.dims[2]===i.dims[2]&&e.dims[3]===i.dims[3]){t.modulateAlpha?(this.gl.uniform1i(d.uniforms.modulation,2),this.gl.uniform1f(d.uniforms.opacity,1)):this.gl.uniform1i(d.uniforms.modulation,1),v=this.r8Tex(v,this.gl.TEXTURE7,i.dims,!0),this.gl.activeTexture(this.gl.TEXTURE7),this.gl.bindTexture(this.gl.TEXTURE_3D,v);const s=i.dims[1]*i.dims[2]*i.dims[3],r=new Uint8Array(s),n=this.volumes[t.modulationImage].cal_min,o=1/(this.volumes[t.modulationImage].cal_max-n),a=this.volumes[t.modulationImage].img.buffer;let l=new Uint8Array(a);switch(e.datatypeCode){case 4:l=new Int16Array(a);break;case 16:l=new Float32Array(a);break;case 64:l=new Float64Array(a);break;case 128:l=new Uint8Array(a);break;case 512:l=new Uint16Array(a)}U.debug(this.volumes[t.modulationImage]);const h=this.volumes[t.modulationImage].colormapNegative.length>0;let c=this.volumes[t.modulationImage].cal_min,m=this.volumes[t.modulationImage].cal_max;isFinite(this.volumes[t.modulationImage].cal_minNeg)&&isFinite(this.volumes[t.modulationImage].cal_maxNeg)&&(c=this.volumes[t.modulationImage].cal_minNeg,m=this.volumes[t.modulationImage].cal_minNeg),c=Math.abs(c),m=Math.abs(m),c>m&&([c,m]=[m,c]);const u=1/(m-c);let f=Math.abs(t.modulateAlpha);f=Math.max(f,1);const g=this.volumes[t.modulationImage].frame4D*s;for(let t=0;t<s;t++){const i=l[t+g]*e.scl_slope+e.scl_inter;let s=(i-n)*o;h&&i<0&&(s=(Math.abs(i)-c)*u),s=Math.min(Math.max(s,0),1),s=255*Math.pow(s,f),r[t]=s}this.gl.texSubImage3D(this.gl.TEXTURE_3D,0,0,0,0,i.dims[1],i.dims[2],i.dims[3],this.gl.RED,this.gl.UNSIGNED_BYTE,r)}else U.debug("Modulation image dimensions do not match target")}else this.gl.uniform1i(d.uniforms.modulation,0);if(this.gl.uniformMatrix4fv(d.uniforms.mtx,!1,l),!this.back.dims)throw new Error("back.dims undefined");let x=0;1002===i.intent_code&&(x=this.opts.atlasOutline,this.gl.uniform1ui(d.uniforms.activeIndex,0|this.opts.atlasActiveIndex)),this.gl.uniform4fv(d.uniforms.xyzaFrac,[1/this.back.dims[1],1/this.back.dims[2],1/this.back.dims[3],x]),U.debug("back dims: ",this.back.dims);for(let r=0;r<this.back.dims[3];r++){const t=1/this.back.dims[3]*(r+.5);this.gl.uniform1f(d.uniforms.coordZ,t),this.gl.framebufferTextureLayer(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,a,0,r),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}if(this.gl.bindVertexArray(this.unusedVAO),this.gl.deleteTexture(c),this.gl.deleteTexture(v),this.gl.deleteTexture(m),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.deleteFramebuffer(h),0===e&&(this.volumeTexture=a,this.gradientTextureAmount>0&&!this.useCustomGradientTexture?(this.gradientGL(i),this.gl.bindVertexArray(this.genericVAO)):this.gradientTextureAmount<=0&&(null!==this.gradientTexture&&this.gl.deleteTexture(this.gradientTexture),this.gradientTexture=null)),!this.renderShader)throw new Error("renderShader undefined");this.renderShader.use(this.gl);const w=this.sliceScale(!0),b=w.vox,y=w.volScale;if(this.gl.uniform1f(this.renderShader.uniforms.overlays,this.overlays.length),this.gl.uniform4fv(this.renderShader.uniforms.clipPlaneColor,this.opts.clipPlaneColor),this.gl.uniform1f(this.renderShader.uniforms.clipThick,this.opts.clipThick),this.gl.uniform3fv(this.renderShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.renderShader.uniforms.clipHi,this.opts.clipVolumeHigh),this.gl.uniform1f(this.renderShader.uniforms.backOpacity,this.volumes[0].opacity),this.gl.uniform1f(this.renderShader.uniforms.renderOverlayBlend,this.opts.renderOverlayBlend),this.gl.uniform4fv(this.renderShader.uniforms.clipPlane,this.scene.clipPlane),this.gl.uniform3fv(this.renderShader.uniforms.texVox,b),this.gl.uniform3fv(this.renderShader.uniforms.volScale,y),!this.pickingImageShader)throw new Error("pickingImageShader undefined");this.pickingImageShader.use(this.gl),this.gl.uniform1f(this.pickingImageShader.uniforms.overlays,this.overlays.length),this.gl.uniform3fv(this.pickingImageShader.uniforms.texVox,b),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipLo,this.opts.clipVolumeLow),this.gl.uniform3fv(this.pickingImageShader.uniforms.clipHi,this.opts.clipVolumeHigh);let C=this.sliceMMShader;if(this.opts.is2DSliceShader&&(C=this.slice2DShader),this.opts.isV1SliceShader&&(C=this.sliceV1Shader),this.customSliceShader&&(C=this.customSliceShader),!C)throw new Error("slice shader undefined");C.use(this.gl),this.gl.uniform1f(C.uniforms.overlays,this.overlays.length),this.gl.uniform1f(C.uniforms.drawOpacity,this.drawOpacity),null!==u&&(this.gl.deleteTexture(u),this.gl.activeTexture(qi),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture)),this.gl.uniform1i(C.uniforms.drawing,7),this.gl.activeTexture(_i),this.opts.is2DSliceShader?this.gl.bindTexture(this.gl.TEXTURE_2D,this.drawTexture):this.gl.bindTexture(this.gl.TEXTURE_3D,this.drawTexture),this.gl.uniform4fv(C.uniforms.paqdUniforms,this.opts.paqdUniforms),this.gl.uniform1i(C.uniforms.paqd,8),this.gl.activeTexture($i),this.gl.bindTexture(this.gl.TEXTURE_3D,this.paqdTexture),this.updateInterpolation(e)}colormaps(){return re.colormaps()}addColormap(t,e){re.addColormap(t,e)}setColormap(t,e){const i=this.getVolumeIndexByID(t);this.volumes[i].colormap=e,this.updateGLVolume()}idx(t,e,i,s){return i*s[0]*s[1]+e*s[0]+t}check_previous_slice(t,e,i,s,r,n,o,a){const l=new Uint32Array(27);let h=0;if(!r)return 0;const c=t[this.idx(i,s,r,n)];if(o>=6){const o=this.idx(i,s,r-1,n);c===t[o]&&(l[h++]=e[o])}if(o>=18){if(i){const o=this.idx(i-1,s,r-1,n);c===t[o]&&(l[h++]=e[o])}if(s){const o=this.idx(i,s-1,r-1,n);c===t[o]&&(l[h++]=e[o])}if(i<n[0]-1){const o=this.idx(i+1,s,r-1,n);c===t[o]&&(l[h++]=e[o])}if(s<n[1]-1){const o=this.idx(i,s+1,r-1,n);c===t[o]&&(l[h++]=e[o])}}if(26===o){if(i&&s){const o=this.idx(i-1,s-1,r-1,n);c===t[o]&&(l[h++]=e[o])}if(i<n[0]-1&&s){const o=this.idx(i+1,s-1,r-1,n);c===t[o]&&(l[h++]=e[o])}if(i&&s<n[1]-1){const o=this.idx(i-1,s+1,r-1,n);c===t[o]&&(l[h++]=e[o])}if(i<n[0]-1&&s<n[1]-1){const o=this.idx(i+1,s+1,r-1,n);c===t[o]&&(l[h++]=e[o])}}return h?(this.fill_tratab(a,l,h),l[0]):0}do_initial_labelling(t,e,i){let s=1;let r=8192,n=new Uint32Array(r).fill(0);const o=new Uint32Array(e[0]*e[1]*e[2]).fill(0),a=new Uint32Array(27);for(let l=0;l<e[2];l++)for(let h=0;h<e[1];h++)for(let c=0;c<e[0];c++){let d=0;const m=t[this.idx(c,h,l,e)];if(0!==m){if(a[0]=this.check_previous_slice(t,o,c,h,l,e,i,n),a[0]&&(d+=1),i>=6){if(c){const i=this.idx(c-1,h,l,e);m===t[i]&&(a[d++]=o[i])}if(h){const i=this.idx(c,h-1,l,e);m===t[i]&&(a[d++]=o[i])}}if(i>=18){if(h&&c){const i=this.idx(c-1,h-1,l,e);m===t[i]&&(a[d++]=o[i])}if(h&&c<e[0]-1){const i=this.idx(c+1,h-1,l,e);m===t[i]&&(a[d++]=o[i])}}if(d)o[this.idx(c,h,l,e)]=a[0],this.fill_tratab(n,a,d);else{if(o[this.idx(c,h,l,e)]=s,s>=r){r+=8192;const t=new Uint32Array(r);t.set(n),n=t}n[s-1]=s,s++}}}for(let l=0;l<s-1;l++){let t=l;for(;n[t]!==t+1;)t=n[t]-1;n[l]=t+1}return[s-1,n,o]}fill_tratab(t,e,i){let s=0;const r=new Uint32Array(i+5).fill(0);let n=2147483647;for(let o=0;o<i;o++){let i=e[o];for(s=0;t[i-1]!==i;)if(i=t[i-1],s++,s>100){U.info("\nOoh no!!");break}r[o]=i,n=Math.min(n,i)}for(let o=0;o<i;o++)t[r[o]-1]=n}translate_labels(t,e,i,s){const r=e[0]*e[1]*e[2];let n=0;const o=new Uint32Array(r).fill(0);for(let h=0;h<s;h++)n=Math.max(n,i[h]);const a=new Uint32Array(n).fill(0);let l=0;for(let h=0;h<r;h++)t[h]&&(a[i[t[h]-1]-1]||(l+=1,a[i[t[h]-1]-1]=l),o[h]=a[i[t[h]-1]-1]);return[l,o]}largest_original_cluster_labels(t,e,i){const s=t.length,r=new Uint32Array(e+1).fill(0),n=new Uint32Array(e+1).fill(0);for(let l=0;l<s;l++){const e=t[l],s=i[l];r[s]=e,n[s]++}let o=0;for(let l=0;l<e+1;l++){const t=r[l];o=Math.max(o,t);for(let i=0;i<e+1;i++)i!==l&&t===r[i]&&(n[l]<n[i]||n[l]===n[i]&&l<i)&&(r[l]=0)}const a=new Uint32Array(s).fill(0);for(let l=0;l<s;l++)a[l]=r[i[l]];return[o,a]}bwlabel(t,e,i,s,r){void 0===i&&(i=26),void 0===s&&(s=!1),void 0===r&&(r=!1);const n=Date.now(),o=e[0]*e[1]*e[2],a=new Uint32Array(o).fill(0);if(![6,18,26].includes(i))return U.info("bwlabel: conn must be 6, 18 or 26."),[0,a];if(e[0]<2||e[1]<2||e[2]<1)return U.info("bwlabel: img must be 2 or 3-dimensional"),[0,a];if(s)for(let u=0;u<o;u++)0!==t[u]&&(a[u]=1);else a.set(t);let[l,h,c]=this.do_initial_labelling(a,e,i);void 0===h&&(h=new Uint32Array);const[d,m]=this.translate_labels(c,e,h,l);if(U.info(i+" neighbor clustering into "+d+" regions in "+(Date.now()-n)+"ms"),r){const[t,e]=this.largest_original_cluster_labels(a,d,m);return[t,e]}return[d,m]}async createConnectedLabelImage(t,e,i,s){void 0===e&&(e=26),void 0===i&&(i=!1),void 0===s&&(s=!1);const r=this.getVolumeIndexByID(t),n=Uint32Array.from(this.volumes[r].dims?.slice(1,4)??[]),o=Uint32Array.from(this.volumes[r].img?.slice()??[]),[a,l]=this.bwlabel(o,n,e,i,s),h=this.volumes[r].clone();h.opacity=.5,h.colormap="random";for(let c=0;c<h.img.length;c++)h.img[c]=l[c];return h.cal_min=0,h.cal_max=a,h}async scalecropUint8(t,e,i,s,r){void 0===e&&(e=0),void 0===i&&(i=255);const n=t.length,o=new Uint8Array(n);for(let a=0;a<n;a++){let n=t[a];n=e+r*(n-s),n=Math.max(n,e),n=Math.min(n,i),o[a]=n}return o}async scalecropFloat32(t,e,i,s,r){void 0===e&&(e=0),void 0===i&&(i=1);const n=t.length,o=new Float32Array(n);for(let a=0;a<n;a++){let n=t[a];n=e+r*(n-s),n=Math.max(n,e),n=Math.min(n,i),o[a]=n}return o}getScale(t,e,i,s,r){void 0===e&&(e=0),void 0===i&&(i=255),void 0===s&&(s=0),void 0===r&&(r=.999);let n=t.global_min,o=t.global_max;if(2===t.hdr.datatypeCode)return[n,1];if((!isFinite(s)||!isFinite(r))&&isFinite(t.cal_min)&&isFinite(t.cal_max)&&t.cal_max>t.cal_min){n=t.cal_min,o=t.cal_max;const s=(i-e)/(o-n);return U.info(" Robust Rescale:  min: "+n+"  max: "+o+" scale: "+s),[n,s]}let a=t.img;const l=t.hdr.dims[1]*t.hdr.dims[2]*t.hdr.dims[3];if(1!==t.hdr.scl_slope||0!==t.hdr.scl_inter){const e=t.img;a=new Float32Array(t.img.length);for(let i=0;i<l;i++)a[i]=e[i]*t.hdr.scl_slope+t.hdr.scl_inter}if(n<0&&U.warn("WARNING: Input image has value(s) below 0.0 !"),U.info(" Input:    min: "+n+"  max: "+o),0===s&&1===r)return[n,1];let h=0;for(let v=0;v<l;v++)Math.abs(a[v])>=1e-15&&h++;const c=1e3,d=(o-n)/c,m=new Array(c).fill(0);for(let v=0;v<l;v++){const t=a[v];let e=Math.floor((t-n)/d);e=Math.min(e,999),m[e]++}const u=new Array(c).fill(0);u[0]=m[0];for(let v=1;v<c;v++)u[v]=u[v-1]+m[v];let f=Math.floor(s*l),g=0;for(;g<c&&!(u[g]>=f);)g++;const A=n;for(n=g*d+A,f=l-Math.floor((1-r)*h),g=0;g<999&&!(u[g+1]>=f);)g++;o=g*d+A;let p=1;return n!==o&&(p=(i-e)/(o-n)),U.info(" Rescale:  min: "+n+"  max: "+o+" scale: "+p),[n,p]}conformVox2Vox(t,e,i,o,a){void 0===i&&(i=256),void 0===o&&(o=1),void 0===a&&(a=!1);const l=e.flat(),h=n.fA(l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8],l[9],l[10],l[11],l[12],l[13],l[14],l[15]),c=s.fA(t[1]/2,t[2]/2,t[3]/2,1),d=s.vt(),m=n.vt();n.mg(m,h),s.Z0(d,c,m);const u=r.fA(d[0],d[1],d[2]),f=r.fA(o,o,o);let g=n.fA(-1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1);a&&(g=n.fA(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)),n.mg(g,g);const A=s.fA(i,i,i,1),p=n.vt();n.hs(p,g,f);const v=s.fA(A[0],A[1],A[2],1);s.Z0(v,v,p),s.hs(v,v,.5);const x=r.vt();r.Re(x,u,r.fA(v[0],v[1],v[2]));const w=n.vt();n.mg(w,p),w[3]=x[0],w[7]=x[1],w[11]=x[2];const b=n.vt();n.B8(b,w);const y=n.vt();n.lK(y,h,b);const C=n.vt();return n.B8(C,y),[w,y,C]}async createNiftiArray(t,e,i,s,r){return void 0===t&&(t=[256,256,256]),void 0===e&&(e=[1,1,1]),void 0===i&&(i=[1,0,0,-128,0,1,0,-128,0,0,1,-128,0,0,0,1]),void 0===s&&(s=2),void 0===r&&(r=new Uint8Array),await Ve.createNiftiArray(t,e,i,s,r)}async niftiArray2NVImage(t){return void 0===t&&(t=new Uint8Array),await Ve.loadFromUrl({url:t})}async loadFromUrl(t){return await Ve.loadFromUrl({url:t})}async conform(t,e,i,s,r){void 0===e&&(e=!1),void 0===i&&(i=!0),void 0===s&&(s=!1),void 0===r&&(r=!1);const n=256,o=this.conformVox2Vox(t.hdr.dims,t.hdr.affine.flat(),n,1,e),a=o[0],l=o[2],h=new Float32Array(16777216),c=new Float32Array(t.img),d=t.hdr.dims[1]*t.hdr.dims[2]*t.hdr.dims[3];if(1!==t.hdr.scl_slope||0!==t.hdr.scl_inter)for(let C=0;C<d;C++)c[C]=c[C]*t.hdr.scl_slope+t.hdr.scl_inter;const m=t.hdr.dims[1],u=t.hdr.dims[2],f=t.hdr.dims[3],g=m*u;let A=-1;function p(t,e,i){return t+e*m+i*g}const v=l[0],x=l[4],w=l[8];if(i)for(let C=0;C<n;C++)for(let t=0;t<n;t++){const e=t*l[1]+C*l[2]+l[3],i=t*l[5]+C*l[6]+l[7],s=t*l[9]+C*l[10]+l[11];for(let t=0;t<n;t++){const r=t*v+e,n=t*x+i,o=t*w+s,a=Math.floor(r),l=Math.floor(n),d=Math.floor(o);if(A++,a<0||l<0||d<0)continue;const b=Math.ceil(r),y=Math.ceil(n),C=Math.ceil(o);if(b>=m||y>=u||C>=f)continue;const M=r-a,D=n-l,I=o-d,T=1-M,S=1-D,F=1-I,E=p(a,l,d);let B=0;B+=c[E]*T*S*F,B+=c[E+g]*T*S*I,B+=c[E+m]*T*D*F,B+=c[E+m+g]*T*D*I,B+=c[E+1]*M*S*F,B+=c[E+1+g]*M*S*I,B+=c[E+1+m]*M*D*F,B+=c[E+1+m+g]*M*D*I,h[A]=B}}else for(let C=0;C<n;C++)for(let t=0;t<n;t++){const e=t*l[1]+C*l[2]+l[3],i=t*l[5]+C*l[6]+l[7],s=t*l[9]+C*l[10]+l[11];for(let t=0;t<n;t++){const r=Math.round(t*v+e),n=Math.round(t*x+i),o=Math.round(t*w+s);A++,r<0||n<0||o<0||(r>=m||n>=u||o>=f||(h[A]=c[p(r,n,o)]))}}let b=0;r&&(b=NaN);let y=new Uint8Array;if(s){const e=await this.getScale(t,0,1,b),i=await this.scalecropFloat32(h,0,1,e[0],e[1]);y=await this.createNiftiArray([n,n,n],[1,1,1],Array.from(a),16,new Uint8Array(i.buffer))}else{const e=await this.getScale(t,0,255,b),i=await this.scalecropUint8(h,0,255,e[0],e[1]);y=await this.createNiftiArray([n,n,n],[1,1,1],Array.from(a),2,i)}return await this.niftiArray2NVImage(y)}setRenderDrawAmbientOcclusion(t){if(!this.renderShader)throw new Error("renderShader undefined");this.renderDrawAmbientOcclusion=t,this.renderShader.use(this.gl),this.gl.uniform1fv(this.renderShader.uniforms.renderDrawAmbientOcclusion,[this.renderDrawAmbientOcclusion,1]),this.drawScene()}setColorMap(t,e){this.setColormap(t,e)}setColormapNegative(t,e){const i=this.getVolumeIndexByID(t);this.volumes[i].colormapNegative=e,this.updateGLVolume()}setModulationImage(t,e,i){void 0===i&&(i=0);const s=this.getVolumeIndexByID(t);let r=null;e.length>0&&(r=this.getVolumeIndexByID(e)),this.volumes[s].modulationImage=r,this.volumes[s].modulateAlpha=i,this.updateGLVolume()}setGamma(t){void 0===t&&(t=1),this.scene.gamma=t,re.gamma=t,this.updateGLVolume()}async loadDeferred4DVolumes(t){const e=this.getVolumeIndexByID(t),i=this.volumes[e];if(i.nTotalFrame4D<=i.nFrame4D)return;let s;i.nTotalFrame4D=i.nFrame4D,s=i.fileObject?await Ve.loadFromFile({file:i.fileObject}):await Ve.loadFromUrl({url:i.url}),s&&(i.img=s.img.slice(),i.nTotalFrame4D=s.nTotalFrame4D,i.nFrame4D=s.nFrame4D,this.updateGLVolume())}setFrame4D(t,e){const i=this.getVolumeIndexByID(t),s=this.volumes[i];e>s.nFrame4D-1&&(e=s.nFrame4D-1),e<0&&(e=0),e!==s.frame4D&&(s.frame4D=e,this.updateGLVolume(),this.onFrameChange(s,e),this.createOnLocationChange())}getFrame4D(t){const e=this.getVolumeIndexByID(t);return this.volumes[e].frame4D}colormapFromKey(t){return re.colormapFromKey(t)}colormap(t,e){return void 0===t&&(t=""),void 0===e&&(e=!1),re.colormap(t,e)}createColormapTexture(t,e,i){return void 0===t&&(t=null),void 0===e&&(e=0),void 0===i&&(i=256),null!==t&&this.gl.deleteTexture(t),e<1||i<1?null:(t=this.gl.createTexture(),this.gl.activeTexture(qi),this.gl.bindTexture(this.gl.TEXTURE_2D,t),this.gl.texStorage2D(this.gl.TEXTURE_2D,1,this.gl.RGBA8,i,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_R,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),t)}addColormapList(t,e,i,s,r,n,o){void 0===t&&(t=""),void 0===e&&(e=NaN),void 0===i&&(i=NaN),void 0===s&&(s=!1),void 0===r&&(r=!1),void 0===n&&(n=!0),void 0===o&&(o=!1),t.length<1&&(n=!1),this.colormapLists.push({name:t,min:e,max:i,isColorbarFromZero:s,negative:r,visible:n,invert:o})}refreshColormaps(){if(this.colormapLists=[],this.volumes.length<1&&this.meshes.length<1)return;const t=this.volumes.length;if(t>0)for(let n=0;n<t;n++){const t=this.volumes[n],e=Yi(t.cal_min,t.cal_max,t.cal_minNeg,t.cal_maxNeg),i=0!==t.colormapType;this.addColormapList(t.colormapNegative,e[0],e[1],i,!0,t.colorbarVisible,t.colormapInvert),this.addColormapList(t.colormap,t.cal_min,t.cal_max,i,!1,t.colorbarVisible,t.colormapInvert)}const e=this.meshes.length;if(e>0)for(let n=0;n<e;n++){const t=this.meshes[n];if(!t.colorbarVisible)continue;const e=t.layers.length;if("edgeColormap"in t&&"edges"in t&&void 0!==t.edges){const e=Yi(t.edgeMin,t.edgeMax,NaN,NaN);this.addColormapList(t.edgeColormapNegative,e[0],e[1],!1,!0,!0,t.colormapInvert),this.addColormapList(t.edgeColormap,t.edgeMin,t.edgeMax,!1,!1,!0,t.colormapInvert)}if(!(e<1))for(let i=0;i<e;i++){const t=this.meshes[n].layers[i];if(!t.colorbarVisible)continue;if(t.colormap.length<1)continue;const e=0!==t.colormapType;if(t.useNegativeCmap){const i=Yi(t.cal_min,t.cal_max,t.cal_minNeg,t.cal_maxNeg);this.addColormapList(t.colormapNegative,i[0],i[1],e,!0,!0,t.colormapInvert)}this.addColormapList(t.colormap,t.cal_min,t.cal_max,e,!1,!0,t.colormapInvert)}}const i=this.colormapLists.length;if(i<1)return;this.colormapTexture=this.createColormapTexture(this.colormapTexture,i+1);let s=new Uint8ClampedArray;function r(t){const e=new Uint8ClampedArray(s.length+t.length);e.set(s),e.set(t,s.length),s=e}for(let n=0;n<i;n++)r(Array.from(this.colormap(this.colormapLists[n].name,this.colormapLists[n].invert)));return r(Array.from(this.drawLut.lut)),this.gl.texSubImage2D(this.gl.TEXTURE_2D,0,0,0,256,i+1,this.gl.RGBA,this.gl.UNSIGNED_BYTE,s),this}sliceScale(t){void 0===t&&(t=!1);let e=this.screenFieldOfViewMM(0);t&&(e=this.screenFieldOfViewVox(0));const i=Math.max(e[0],Math.max(e[1],e[2])),s=[e[0]/i,e[1]/i,e[2]/i];if(!this.back?.dims)throw new Error("back.dims undefined");return{volScale:s,vox:[this.back.dims[1],this.back.dims[2],this.back.dims[3]],longestAxis:i,dimsMM:e}}tileIndex(t,e){for(let i=0;i<this.screenSlices.length;i++){const s=this.screenSlices[i].leftTopWidthHeight;if(t>s[0]&&e>s[1]&&t<s[0]+s[2]&&e<s[1]+s[3])return i}return-1}inRenderTile(t,e){const i=this.tileIndex(t,e);return i>=0&&4===this.screenSlices[i].axCorSag?i:-1}sliceScroll3D(t){if(void 0===t&&(t=0),0!==t){if(this.volumes.length>0&&this.scene.clipPlaneDepthAziElev[0]<1.8){const e=this.scene.clipPlaneDepthAziElev.slice();return t>0&&(e[0]=Math.min(1.5,e[0]+.025)),t<0&&(e[0]=Math.max(-1.5,e[0]-.025)),e[0]!==this.scene.clipPlaneDepthAziElev[0]?(this.scene.clipPlaneDepthAziElev=e,this.setClipPlane(this.scene.clipPlaneDepthAziElev)):void 0}t>0&&(this.scene.volScaleMultiplier=Math.min(2,1.1*this.scene.volScaleMultiplier)),t<0&&(this.scene.volScaleMultiplier=Math.max(.5,.9*this.scene.volScaleMultiplier)),this.drawScene()}}deleteThumbnail(){this.bmpTexture&&(this.gl.deleteTexture(this.bmpTexture),this.bmpTexture=null,this.thumbnailVisible=!1)}inGraphTile(t,e){if(this.graph.opacity<=0||this.volumes.length<1||this.volumes[0].nFrame4D<1||!this.graph.plotLTWH)return!1;if(this.graph.plotLTWH[2]<1||this.graph.plotLTWH[3]<1)return!1;const i=[(t-this.graph.LTWH[0])/this.graph.LTWH[2],(e-this.graph.LTWH[1])/this.graph.LTWH[3]];return i[0]>0&&i[1]>0&&i[0]<=1&&i[1]<=1}updateBitmapFromClickToSegment(){if(null===this.clickToSegmentGrowingBitmap)return;if(null===this.drawBitmap)return;if(this.clickToSegmentGrowingBitmap.length!==this.drawBitmap.length)return;const t=this.drawBitmap.length;for(let e=0;e<t;e++)this.drawBitmap[e]=this.clickToSegmentGrowingBitmap[e]}sumBitmap(t){let e=0;for(let i=0;i<t.length;i++)e+=t[i];return e}doClickToSegment(t){const{tileIndex:e}=t;if(e<0||e>=this.screenSlices.length)return void U.warn(`Invalid tileIndex ${e} received in doClickToSegment.`);const i=this.screenSlices[e].axCorSag;if(i>2)return void U.warn("ClickToSegment attempted on non-2D slice tile.");const s=this.screenXY2TextureFrac(this.clickToSegmentXY[0],this.clickToSegmentXY[1],e,!1);if(s[0]<0)return void U.debug("Click location outside valid texture fraction for the tile.");const r=this.frac2vox(s),n=this.opts.clickToSegmentPercent;let o=this.back.getValue(r[0],r[1],r[2]);this.opts.clickToSegmentAutoIntensity&&(0!==n&&(0===o&&(o=.01),this.opts.clickToSegmentIntensityMax=o*(1+n),this.opts.clickToSegmentIntensityMin=o*(1-n)),o>.5*(this.back.cal_min+this.back.cal_max)?this.opts.clickToSegmentBright=!0:this.opts.clickToSegmentBright=!1);const a=this.opts.clickToSegmentBright?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;this.drawPenAxCorSag=i;const l=this.clickToSegmentIsGrowing?this.clickToSegmentGrowingBitmap:this.drawBitmap;if(!l){if(U.error("Target bitmap for flood fill is null."),this.clickToSegmentIsGrowing){if(this.drawBitmap||this.createEmptyDrawing(),!this.drawBitmap)return;this.clickToSegmentGrowingBitmap=this.drawBitmap.slice()}else if(this.createEmptyDrawing(),!this.drawBitmap)return;U.warn("Initialized missing bitmap in doClickToSegment.")}if(this.drawFloodFill([r[0],r[1],r[2]],this.opts.penValue,a,this.opts.clickToSegmentIntensityMin,this.opts.clickToSegmentIntensityMax,this.opts.floodFillNeighbors,this.opts.clickToSegmentMaxDistanceMM,this.opts.clickToSegmentIs2D,l),!this.clickToSegmentIsGrowing&&(U.debug("Applying clickToSegment mask to drawBitmap."),this.drawBitmap?(this.refreshDrawing(!1,!1),this.drawScene()):U.error("Cannot refresh drawing after click-to-segment apply, drawBitmap is null."),this.drawBitmap)){const t=this.getDescriptives({layer:0,masks:[],drawingIsMask:!0});this.onClickToSegment({mL:t.volumeML,mm3:t.volumeMM3})}this.createOnLocationChange(i)}mouseClick(t,e,i,s){if(void 0===i&&(i=0),void 0===s&&(s=!0),t*=this.uiData.dpr,e*=this.uiData.dpr,this.canvas.focus(),this.thumbnailVisible)return this.thumbnailVisible=!1,void Promise.all([this.loadVolumes(this.deferredVolumes),this.loadMeshes(this.deferredMeshes)]).catch((t=>{throw t}));if(this.inGraphTile(t,e)){if(!this.graph.plotLTWH)throw new Error("plotLTWH undefined");const i=[(t-this.graph.plotLTWH[0])/this.graph.plotLTWH[2],(e-this.graph.plotLTWH[1])/this.graph.plotLTWH[3]];if(i[0]>0&&i[1]>0&&i[0]<=1&&i[1]<=1){const t=Math.round(i[0]*(this.volumes[0].nFrame4D-1));return void this.setFrame4D(this.volumes[0].id,t)}i[0]>.5&&i[1]>1&&this.loadDeferred4DVolumes(this.volumes[0].id).catch((t=>{throw t}))}else{if(this.inRenderTile(t,e)>=0)return this.sliceScroll3D(i),void this.drawScene();if(!(this.screenSlices.length<1||this.gl.canvas.height<1||this.gl.canvas.width<1))for(let n=0;n<this.screenSlices.length;n++){const o=this.screenSlices[n].axCorSag;if(this.drawPenAxCorSag>=0&&this.drawPenAxCorSag!==o)continue;if(o>2&&!this.opts.clickToSegment&&0===i)continue;const a=this.screenXY2TextureFrac(t,e,n,!0);if(!(a[0]<0)){if(0!==i||!s){if(!s)return void(o<=2&&(this.scene.crosshairPos[2-o]=i,this.drawScene(),this.createOnLocationChange(o)));const t=i<0?-1:1,e=[0,0,0];return void(o<=2&&(e[2-o]=t,this.moveCrosshairInVox(e[0],e[1],e[2])))}if(this.opts.isForceMouseClickToVoxelCenters?this.scene.crosshairPos=r.o8(this.vox2frac(this.frac2vox(a))):this.scene.crosshairPos=r.o8(a),this.opts.drawingEnabled){const t=this.frac2vox(this.scene.crosshairPos);if(!isFinite(this.opts.penValue)||this.opts.penValue<0||Object.is(this.opts.penValue,-0)){let e=0,i=Math.abs(this.opts.penValue);const s=!0;return Object.is(this.opts.penValue,-0)?(e=0,i=0,U.debug("Erase Cluster selected")):(e=this.opts.penValue,U.debug("Intensity Grow selected",e)),this.drawFloodFill(t,i,e,NaN,NaN,this.opts.floodFillNeighbors,Number.POSITIVE_INFINITY,!1,this.drawBitmap,s),this.drawScene(),void this.createOnLocationChange(o)}if(this.opts.clickToSegment)return o<=2&&(this.clickToSegmentIsGrowing=!1,this.doClickToSegment({x:this.clickToSegmentXY[0],y:this.clickToSegmentXY[1],tileIndex:n})),void this.createOnLocationChange(o);if(0===this.opts.penType){if(isNaN(this.drawPenLocation[0]))this.drawPenAxCorSag=o,this.drawPenFillPts=[],this.drawPt(...t,this.opts.penValue);else{if(t[0]===this.drawPenLocation[0]&&t[1]===this.drawPenLocation[1]&&t[2]===this.drawPenLocation[2])return this.drawScene(),void this.createOnLocationChange(o);this.drawPenLine(t,this.drawPenLocation,this.opts.penValue)}this.drawPenLocation=t,this.opts.isFilledPen&&this.drawPenFillPts.push(t),this.refreshDrawing(!1,!1)}else 1!==this.opts.penType&&2!==this.opts.penType||(isNaN(this.drawShapeStartLocation[0])?(this.drawPenAxCorSag=o,this.drawShapeStartLocation=[...t],this.drawBitmap&&(this.drawShapePreviewBitmap=this.drawBitmap.slice())):this.drawShapePreviewBitmap&&this.drawBitmap&&(this.drawBitmap.set(this.drawShapePreviewBitmap),1===this.opts.penType?this.drawRectangleMask(this.drawShapeStartLocation,t,this.opts.penValue):2===this.opts.penType&&this.drawEllipseMask(this.drawShapeStartLocation,t,this.opts.penValue),this.refreshDrawing(!1,!1)))}return this.drawScene(),void this.createOnLocationChange(o)}}}}drawRuler(){let t=[],e=[];for(let A=0;A<this.screenSlices.length;A++)if(4!==this.screenSlices[A].axCorSag&&this.screenSlices[A].fovMM.length>1){e=this.screenSlices[A].leftTopWidthHeight,t=this.screenSlices[A].fovMM;break}if(e.length<4)return;const[i,s,r,n]=this.getBoundsRegion(),o=100/t[0]*e[2],a=Math.max(Math.round(.1*o),2),l=Number(this.opts.rulerWidth),h=Math.floor(e[0]+.5*e[2]-.5*o),c=Math.floor(e[1]+e[3]-a)+.5*l,d=Math.max(i,h),m=Math.min(i+r,h+o),u=Math.min(s+n,c);if(m<=d)return;const f=[d,u,m,u];let g=[0,0,0,1];this.opts.rulerColor[0]+this.opts.rulerColor[1]+this.opts.rulerColor[2]<.8&&(g=[1,1,1,1]),this.drawRuler10cm(f,g,l+1),this.drawRuler10cm(f,this.opts.rulerColor,l)}drawRuler10cm(t,e,i){if(void 0===i&&(i=1),!this.lineShader)throw new Error("lineShader undefined");this.gl.bindVertexArray(this.genericVAO),this.lineShader.use(this.gl),this.gl.uniform4fv(this.lineShader.uniforms.lineColor,e),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,i),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,t),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const s=-.1*(t[0]-t[2]),r=t[1]-Math.floor(.5*this.opts.rulerWidth),n=Math.floor(r-.35*s),o=Math.floor(r-.7*s);for(let a=0;a<11;a++){let e=t[0]+a*s;e=Math.max(e,t[0]+.5*i),e=Math.min(e,t[2]-.5*i);const l=[e,r,e,n];a%5==0&&(l[3]=o),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,l),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}this.gl.bindVertexArray(this.unusedVAO)}screenXY2mm(t,e,i){let r;void 0===i&&(i=-1);for(let n=0;n<this.screenSlices.length;n++){let o=n;i>=0&&(o=i);if(this.screenSlices[o].axCorSag>2)continue;const a=this.screenSlices[o].leftTopWidthHeight;if(t<a[0]||e<a[1]||t>a[0]+a[2]||e>a[1]+a[3])continue;if(r=this.screenXY2TextureFrac(t,e,o,!1),r[0]<0)continue;const l=this.frac2mm(r);return s.fA(l[0],l[1],l[2],o)}return s.fA(NaN,NaN,NaN,NaN)}dragForPanZoom(t){const e=this.screenXY2mm(t[2],t[3]);if(isNaN(e[0]))return;const i=this.screenXY2mm(t[0],t[1],e[3]);if(isNaN(i[0])||isNaN(e[0])||isNaN(e[3]))return;const r=s.vt(),n=this.uiData.pan2DxyzmmAtMouseDown[3];s.jb(r,e,i),this.scene.pan2Dxyzmm[0]=this.uiData.pan2DxyzmmAtMouseDown[0]+n*r[0],this.scene.pan2Dxyzmm[1]=this.uiData.pan2DxyzmmAtMouseDown[1]+n*r[1],this.scene.pan2Dxyzmm[2]=this.uiData.pan2DxyzmmAtMouseDown[2]+n*r[2],this.canvas.focus()}dragForCenterButton(t){this.dragForPanZoom(t)}dragForSlicer3D(t){let e=this.uiData.pan2DxyzmmAtMouseDown[3];e+=.01*(t[3]-t[1]),e=Math.max(e,.1),e=Math.min(e,10);const i=this.scene.pan2Dxyzmm[3]-e;this.opts.yoke3Dto2DZoom&&(this.scene.volScaleMultiplier=e),this.scene.pan2Dxyzmm[3]=e;const s=this.frac2mm(this.scene.crosshairPos);this.scene.pan2Dxyzmm[0]+=i*s[0],this.scene.pan2Dxyzmm[1]+=i*s[1],this.scene.pan2Dxyzmm[2]+=i*s[2]}drawMeasurementTool(t,e){void 0===e&&(e=!0);const i=this.gl;if(i.viewport(0,0,i.canvas.width,i.canvas.height),i.bindVertexArray(this.genericVAO),i.depthFunc(i.ALWAYS),i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl),i.uniform4fv(this.lineShader.uniforms.lineColor,this.opts.rulerColor),i.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[i.canvas.width,i.canvas.height]),i.uniform1f(this.lineShader.uniforms.thickness,this.opts.rulerWidth),i.uniform4fv(this.lineShader.uniforms.startXYendXY,t),i.drawArrays(i.TRIANGLE_STRIP,0,4);const s=this.opts.measureLineColor;s[3]=1,i.uniform4fv(this.lineShader.uniforms.lineColor,s);const n=this.opts.rulerWidth;i.uniform1f(this.lineShader.uniforms.thickness,2*n);let o=[t[0],t[1]-n,t[0],t[1]+n];i.uniform4fv(this.lineShader.uniforms.startXYendXY,o),i.drawArrays(i.TRIANGLE_STRIP,0,4),o=[t[2],t[3]-n,t[2],t[3]+n],i.uniform4fv(this.lineShader.uniforms.startXYendXY,o),i.drawArrays(i.TRIANGLE_STRIP,0,4);let a=this.canvasPos2frac([t[0],t[1]]),l=this.canvasPos2frac([t[2],t[3]]);if(a[0]>=0&&l[0]>=0){const i=this.frac2mm(a);a=r.fA(i[0],i[1],i[2]);const s=this.frac2mm(l);l=r.fA(s[0],s[1],s[2]);const n=r.vt();r.jb(n,a,l);const o=r.Il(n);let h=2;o>9&&(h=1),o>99&&(h=0);let c=o.toFixed(h);this.opts.showMeasureUnits&&(c=`${c} mm`);let d=t;const[m,u,f,g]=t,{origin:A,terminus:p}=function(t,e,i,s,r){const n=t-i,o=e-s;if(0===n&&0===o)return{origin:[i+r,s],terminus:[i+r,s]};const a=Math.sqrt(n*n+o*o),l=r*n/a,h=r*o/a;return{origin:[t+l,e+h],terminus:[i-l,s-h]}}(m,u,f,g,30);switch(this.opts.measureTextJustify){case"start":d=[...A,...A.map((t=>t+1))];break;case"end":d=d=[...p,...p.map((t=>t+1))];break;default:d=t}e&&this.drawTextBetween(d,c,this.opts.measureTextHeight/.06,this.opts.measureTextColor)}i.bindVertexArray(this.unusedVAO)}drawAngleMeasurementTool(){"drawing_first_line"===this.uiData.angleState?this.drawMeasurementTool([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]],!1):"drawing_second_line"===this.uiData.angleState&&(this.drawMeasurementTool(this.uiData.angleFirstLine,!1),this.drawMeasurementTool([this.uiData.angleFirstLine[2],this.uiData.angleFirstLine[3],this.uiData.dragEnd[0],this.uiData.dragEnd[1]],!1),this.drawAngleText())}drawAngleText(){const t=this.uiData.angleFirstLine,e=[this.uiData.angleFirstLine[2],this.uiData.angleFirstLine[3],this.uiData.dragEnd[0],this.uiData.dragEnd[1]],i=this.calculateAngleBetweenLines(t,e),s=this.uiData.angleFirstLine[2],r=this.uiData.angleFirstLine[3],n=`${i.toFixed(1)}\xb0`;this.drawTextBetween([s,r,s+1,r+1],n,this.opts.measureTextHeight/.06,this.opts.measureTextColor)}drawAngleTextForAngle(t){const e=this.calculateAngleBetweenLines(t.firstLine,t.secondLine),i=t.firstLine[2],s=t.firstLine[3],r=`${e.toFixed(1)}\xb0`;this.drawTextBetween([i,s,i+1,s+1],r,this.opts.measureTextHeight/.06,this.opts.measureTextColor)}calculateAngleBetweenLines(t,e){const i=t[2],s=t[3],r=t[0]-i,n=t[1]-s,o=e[2]-i,a=e[3]-s,l=r*o+n*a,h=Math.sqrt(r*r+n*n),c=Math.sqrt(o*o+a*a);if(0===h||0===c)return 0;const d=Math.max(-1,Math.min(1,l/(h*c)));return Math.acos(d)*(180/Math.PI)}resetAngleMeasurement(){this.uiData.angleState="none",this.uiData.angleFirstLine=[0,0,0,0]}getCurrentSliceInfo(){const t=this.tileIndex(this.uiData.dragStart[0],this.uiData.dragStart[1]);if(t>=0&&t<this.screenSlices.length){const e=this.screenSlices[t].axCorSag;let i=0;return 0===e?i=this.scene.crosshairPos[2]:1===e?i=this.scene.crosshairPos[1]:2===e&&(i=this.scene.crosshairPos[0]),{sliceIndex:t,sliceType:e,slicePosition:i}}const e=this.opts.sliceType;let i=0;if(0===e)i=this.scene.crosshairPos[2];else if(1===e)i=this.scene.crosshairPos[1];else if(2===e)i=this.scene.crosshairPos[0];else if(3===e){this.canvasPos2frac([this.uiData.dragStart[0],this.uiData.dragStart[1]])[0]>=0&&(i=this.scene.crosshairPos[2])}return{sliceIndex:-1,sliceType:e,slicePosition:i}}getCurrentSlicePosition(t){return 0===t?this.scene.crosshairPos[2]:1===t?this.scene.crosshairPos[1]:2===t?this.scene.crosshairPos[0]:0}shouldDrawOnCurrentSlice(t,e,i){if(3===this.opts.sliceType){if(e>2)return!1;for(let t=0;t<this.screenSlices.length;t++)if(this.screenSlices[t].axCorSag===e){const t=this.getCurrentSlicePosition(e),s=.001;if(Math.abs(t-i)<s)return!0}return!1}if(this.opts.sliceType!==e)return!1;const s=this.getCurrentSlicePosition(e);return Math.abs(s-i)<.001}clearMeasurements(){this.document.completedMeasurements=[],this.drawScene()}clearAngles(){this.document.completedAngles=[],this.drawScene()}clearAllMeasurements(){this.document.completedMeasurements=[],this.document.completedAngles=[],this.drawScene()}setDragMode(t){if("string"==typeof t)switch(t){case"none":this.opts.dragMode=0;break;case"contrast":this.opts.dragMode=1;break;case"measurement":this.opts.dragMode=2;break;case"angle":this.opts.dragMode=7;break;case"pan":this.opts.dragMode=3;break;case"slicer3D":this.opts.dragMode=4;break;case"callbackOnly":this.opts.dragMode=5;break;case"roiSelection":this.opts.dragMode=6;break;default:return void console.warn(`Unknown drag mode: ${t}`)}else this.opts.dragMode=t;7!==this.opts.dragMode&&this.resetAngleMeasurement(),this.clearActiveDragMode()}setMouseEventConfig(t){this.opts.mouseEventConfig=t,this.clearActiveDragMode()}setTouchEventConfig(t){this.opts.touchEventConfig=t,this.clearActiveDragMode()}getMouseEventConfig(){return this.opts.mouseEventConfig}getTouchEventConfig(){return this.opts.touchEventConfig}drawRect(t,e){if(void 0===e&&(e=[1,0,0,-1]),e[3]<0&&(e=this.opts.crosshairColor),!this.rectShader)throw new Error("rectShader undefined");this.opts.selectionBoxIsOutline?(this.drawCircle(t,e,.1),this.rectOutlineShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform1f(this.rectOutlineShader.uniforms.thickness,this.opts.selectionBoxLineThickness),this.gl.uniform4fv(this.rectOutlineShader.uniforms.lineColor,e),this.gl.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.rectOutlineShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)):(this.rectShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform4fv(this.rectShader.uniforms.lineColor,e),this.gl.uniform2fv(this.rectShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.rectShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO))}drawBoundsBox(t,e,i){if(void 0===i&&(i=2),!this.rectOutlineShader)throw new Error("rectOutlineShader undefined");const s=this.gl,[r,n,o,a]=t;s.viewport(0,0,s.canvas.width,s.canvas.height),this.rectOutlineShader.use(s),s.enable(s.BLEND),s.uniform1f(this.rectOutlineShader.uniforms.thickness,i),s.uniform4fv(this.rectOutlineShader.uniforms.lineColor,e),s.uniform2fv(this.rectOutlineShader.uniforms.canvasWidthHeight,[s.canvas.width,s.canvas.height]),s.uniform4f(this.rectOutlineShader.uniforms.leftTopWidthHeight,r,n,o,a),s.bindVertexArray(this.genericVAO),s.drawArrays(s.TRIANGLE_STRIP,0,4),s.bindVertexArray(this.unusedVAO)}drawCircle(t,e,i){if(void 0===e&&(e=this.opts.fontColor),void 0===i&&(i=1),!this.circleShader)throw new Error("circleShader undefined");this.circleShader.use(this.gl),this.gl.enable(this.gl.BLEND),this.gl.uniform4fv(this.circleShader.uniforms.circleColor,e),this.gl.uniform2fv(this.circleShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform4f(this.circleShader.uniforms.leftTopWidthHeight,t[0],t[1],t[2],t[3]),this.gl.uniform1f(this.circleShader.uniforms.fillPercent,i),this.gl.uniform4fv(this.circleShader.uniforms.circleColor,e),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawSelectionBox(t){this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),6!==this.getCurrentDragMode()?this.drawRect(t,this.opts.selectionBoxColor):this.drawCircle(t,this.opts.selectionBoxColor,.1)}effectiveCanvasHeight(){let t=this.gl.canvas.height;if(this.opts.bounds){const[[,e],[,i]]=this.opts.bounds,s=Math.round(e*this.gl.canvas.height);t=Math.round(i*this.gl.canvas.height)-s}return t-this.colorbarHeight}effectiveCanvasWidth(){let t=this.gl.canvas.width;if(this.opts.bounds){const[[e],[i]]=this.opts.bounds;t=Math.round((i-e)*this.gl.canvas.width)}return t-this.getLegendPanelWidth()}getAllLabels(){const t=this.meshes.filter((t=>"connectome"===t.type)).flatMap((t=>t.nodes)).map((t=>t.label)).filter((t=>void 0!==t));return[...this.document.labels,...t]}getConnectomeLabels(){const t=this.meshes.filter((t=>"connectome"===t.type&&!1!==t.showLegend)).flatMap((t=>t.nodes)).map((t=>t.label)).filter((t=>void 0!==t&&""!==t.text)),e=this.document.labels.filter((t=>null==t.anchor||0===t.anchor)),i=new Set(t);for(const r of e)i.add(r);const s=this.meshes.filter((t=>"mesh"===t.type));for(let r=0;r<s.length;r++)for(let t=0;t<s[r].layers.length;t++)if(s[r].layers[t].labels)for(let e=0;e<s[r].layers[t].labels.length;e++)i.add(s[r].layers[t].labels[e]);return Array.from(i)}getBulletMarginWidth(){let t=0;const e=this.getConnectomeLabels();if(0===e.length)return 0;const i=1===e.length?e[0].style.bulletScale:e.reduce(((t,e)=>t.style.bulletScale>e.style.bulletScale?t:e)).style.bulletScale,s=1===e.length?e[0]:e.reduce(((t,e)=>{const i=this.fontPx*t.style.textScale,s=this.fontPx*e.style.textScale;return this.textHeight(i,t.text)>this.textHeight(s,e.text)?t:e})),r=this.fontPx*s.style.textScale;return t=this.textHeight(r,s.text)*i,t+=r,t}getLegendPanelWidth(){const t=this.getConnectomeLabels();if(!this.opts.showLegend||0===t.length)return 0;const e=1*this.fontPx;let i=0;const s=t.reduce(((t,e)=>{const i=this.fontPx*t.style.textScale,s=this.fontPx*e.style.textScale;return this.textWidth(i,t.text)>this.textWidth(s,e.text)?t:e})),r=this.fontPx*s.style.textScale,n=this.textWidth(r,s.text),o=this.getBulletMarginWidth();return n&&(i=o+n,i+=2*e),i>=this.gl.canvas.width?0:i}getLegendPanelHeight(t){void 0===t&&(t=1);const e=this.getConnectomeLabels();let i=0;const s=this.fontPx;for(const r of e){const e=this.fontPx*r.style.textScale*t;i+=this.textHeight(e,r.text)}return i&&(i+=s/2*(e.length+1)*t),i}reserveColorbarPanel(){const t=3*this.fontPx;if(t<0)return[0,0,0,0];const[e,i,s,r]=this.getBoundsRegion(),n=(this.opts.colorbarWidth>0&&this.opts.colorbarWidth<=1?this.opts.colorbarWidth:1)*s,o=[e+(s-n)/2,i+r-t,n,t];return this.colorbarHeight=o[3]+1,o}drawColorbarCore(t,e,i,s,r,n){if(void 0===t&&(t=0),void 0===e&&(e=[0,0,0,0]),void 0===i&&(i=!1),void 0===s&&(s=0),void 0===r&&(r=1),e[2]<=0||e[3]<=0)return;const o=this.fontPx;if(o<=0)return;let a=o;const l=3*o;let h=o;if(e[3]<l){if(e[3]<3)return;a=1,h=e[3]-2}this.gl.disable(this.gl.DEPTH_TEST),this.colorbarHeight=e[3]+1;const c=[e[0]+a,e[1],e[2]-2*a,h],d=[c[0]-1,c[1]-1,c[2]+2,c[3]+2];if(this.opts.showColorbarBorder&&this.drawRect(d,this.opts.crosshairColor),!this.colorbarShader)throw new Error("colorbarShader undefined");this.colorbarShader.use(this.gl),this.gl.activeTexture(qi),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST);const m=t;if(this.gl.uniform1f(this.colorbarShader.uniforms.layer,m),this.gl.uniform2fv(this.colorbarShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.disable(this.gl.CULL_FACE),i){const t=[c[0]+c[2],c[1],-c[2],c[3]];this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight,t)}else this.gl.uniform4fv(this.colorbarShader.uniforms.leftTopWidthHeight,c);this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR);let u=0;if(n&&r<0&&i?(u=r,r=0):n&&s>0&&(u=s,s=0),s===r||o<1)return;const f=Math.abs(r-s);let[g,A]=ki(s,r);A<s&&(A+=g);let p=A;const v=[0,c[1]+c[3]-.5*o,2,.75*o],x=v[1]+v[3];for(;p<=r;){v[0]=c[0]+(p-s)/f*c[2],this.drawRect(v);const t=(1*p).toFixed(6).replace(/\.?0*$/,"");this.drawTextBelow([v[0],x],t),p+=g}if(0!==u){const t=[c[0]+(u-s)/f*c[2],c[1]-.25*c[3],2,1.5*c[3]];this.drawRect(t)}}drawColorbar(){const t=this.colormapLists,e=t.length;if(e<1)return;let i=0;for(let o=0;o<e;o++)t[o].visible&&i++;if(i<1)return;let s=this.reserveColorbarPanel();const r=3*this.fontPx;if(r<0)return;let n=s[2]/i;(s[2]<=0||s[3]<=0)&&(n=this.gl.canvas.width/i,s=[0,this.gl.canvas.height-r,n,r]),s[2]=n;for(let o=0;o<e;o++)t[o].visible&&(this.drawColorbarCore(o,s,t[o].negative,t[o].min,t[o].max,t[o].isColorbarFromZero),s[0]+=n)}textWidth(t,e){if(!e)return 0;let i=0;const s=(new TextEncoder).encode(e);for(let r=0;r<e.length;r++)i+=t*this.fontMets.mets[s[r]].xadv;return i}textHeight(t,e){if(!e)return 0;const i=new Set(Array.from(e)),s=(new TextEncoder).encode(Array.from(i).join(""));return t*Object.values(this.fontMets.mets).filter(((t,e)=>s.includes(e))).reduce(((t,e)=>t.lbwh[3]>e.lbwh[3]?t:e)).lbwh[3]}drawChar(t,e,i){if(!this.fontShader)throw new Error("fontShader undefined");const s=this.fontMets.mets[i],r=t[0]+e*s.lbwh[0],n=-e*s.lbwh[1],o=e*s.lbwh[2],a=e*s.lbwh[3],l=t[1]+(n-a)+e;return this.gl.uniform4f(this.fontShader.uniforms.leftTopWidthHeight,r,l,o,a),this.gl.uniform4fv(this.fontShader.uniforms.uvLeftTopWidthHeight,s.uv_lbwh),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),e*s.xadv}drawLoadingText(t){if(!t)return;if(!this.canvas)throw new Error("canvas undefined");const[e,i,s,r]=this.getBoundsRegion();this.gl.viewport(e,i,s,r),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.BLEND);const n=e+s/2,o=i+r/2;this.drawTextBelow([n,o],t,3)}drawText(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0)return;if(!this.fontShader)throw new Error("fontShader undefined");this.fontShader.use(this.gl);const r=this.fontPx*i;this.gl.enable(this.gl.BLEND),this.gl.uniform2f(this.fontShader.uniforms.canvasWidthHeight,this.gl.canvas.width,this.gl.canvas.height),null===s&&(s=this.opts.fontColor),this.gl.uniform4fv(this.fontShader.uniforms.fontColor,s);let n=r/this.fontMets.size*this.fontMets.distanceRange;n=Math.max(n,1),this.gl.uniform1f(this.fontShader.uniforms.screenPxRange,n);const o=(new TextEncoder).encode(e);this.gl.bindVertexArray(this.genericVAO);for(let a=0;a<e.length;a++)t[0]+=this.drawChar(t,r,o[a]);this.gl.bindVertexArray(this.unusedVAO)}drawTextRight(t,e,i,s){void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0||(t[1]-=.5*this.fontPx,this.drawText(t,e,i,s))}drawTextLeft(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0)return;const r=this.fontPx*i;t[0]-=this.textWidth(r,e),t[1]-=.5*r,this.drawText(t,e,i,s)}drawTextRightBelow(t,e,i,s){void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0||this.drawText(t,e,i,s)}drawTextBetween(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0)return;const r=[.5*(t[0]+t[2]),.5*(t[1]+t[3])],n=this.fontPx*i,o=this.textWidth(n,e);r[0]-=.5*o,r[1]-=.5*n;const a=[r[0]-1,r[1]-1,o+2,n+2];let l=s;null===l&&(l=this.opts.crosshairColor),l=l&&l[0]+l[1]+l[2]>.8?[0,0,0,.5]:[1,1,1,.5],this.drawRect(a,l),this.drawText(r,e,i,s)}drawTextBelow(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0)return;if(!this.canvas)throw new Error("canvas undefined");let r=this.fontPx*i,n=this.textWidth(r,e);n>this.canvas.width&&(i*=(this.canvas.width-2)/n,r=this.fontPx*i,n=this.textWidth(r,e)),t[0]-=.5*this.textWidth(r,e),t[0]=Math.max(t[0],1),t[0]=Math.min(t[0],this.canvas.width-n-1),this.drawText(t,e,i,s)}drawTextAbove(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=null),this.fontPx<=0)return;if(!this.canvas)throw new Error("canvas undefined");let r=this.fontPx*i,n=this.textWidth(r,e);n>this.canvas.width&&(i*=(this.canvas.width-2)/n,r=this.fontPx*i,n=this.textWidth(r,e)),t[0]-=.5*this.textWidth(r,e),t[0]=Math.max(t[0],1),t[0]=Math.min(t[0],this.canvas.width-n-1),t[1]-=r,this.drawText(t,e,i,s)}updateInterpolation(t,e){void 0===e&&(e=!1);let i=this.gl.LINEAR;!e&&this.opts.isNearestInterpolation&&(i=this.gl.NEAREST),0===t?this.gl.activeTexture(Hi):this.gl.activeTexture(Zi),this.opts.is2DSliceShader?(this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,i),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,i)):(this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MIN_FILTER,i),this.gl.texParameteri(this.gl.TEXTURE_3D,this.gl.TEXTURE_MAG_FILTER,i))}setAtlasOutline(t){this.opts.atlasOutline=t,this.updateGLVolume(),this.drawScene()}setInterpolation(t){this.opts.isNearestInterpolation=t;const e=this.volumes.length;if(!(e<1)){for(let t=0;t<e;t++)this.updateInterpolation(t);this.drawScene()}}calculateMvpMatrix2D(t,e,i,s,o,a,l,h){void 0===s&&(s=1/0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===l&&(l=0);this.gl.viewport(t[0],this.gl.canvas.height-(t[1]+t[3]),t[2],t[3]);let c=e[0],d=i[0],m=[c,e[1]],u=[d-c,i[1]-e[1]];h&&(m=[i[0],e[1]],u=[e[0]-i[0],i[1]-e[1]],c=-i[0],d=-e[0]);const f=2*Math.max(Math.abs(e[2]),Math.abs(i[2])),g=n.vt();let A=.01,p=8*f;if(s!==1/0){let t=h;0!==l||0!==a&&180!==a||(t=!t);let e=1.8*f-o;t||(e=1.8*f+o),A=e-s,p=e+s}n.v3(g,c,d,e[1],i[1],A,p);const v=n.vt();v[0]=-1;const x=r.fA(0,0,1.8*-f);n.Tl(v,v,x),n.eL(v,v,Oi(270-l)),n.Qr(v,v,Oi(a-180));const w=n.vt();n.B8(w,v);const b=n.vt();n.mg(b,w);const y=n.vt();return n.lw(y,g,v),{modelViewProjectionMatrix:y,modelMatrix:v,normalMatrix:b,leftTopMM:m,fovMM:u}}swizzleVec3MM(t,e){return 1===e?t=Wi(t,[0,2,1]):2===e&&(t=Wi(t,[1,2,0])),t}screenFieldOfViewVox(t){void 0===t&&(t=0);const e=r.o8(this.volumeObject3D.fieldOfViewDeObliqueMM);return this.swizzleVec3MM(e,t)}screenFieldOfViewMM(t,e){if(void 0===t&&(t=0),void 0===e&&(e=!1),this.volumes.length<1){let e=r.fA(this.extentsMin[0],this.extentsMin[1],this.extentsMin[2]),i=r.fA(this.extentsMax[0],this.extentsMax[1],this.extentsMax[2]);e=this.swizzleVec3MM(e,t),i=this.swizzleVec3MM(i,t);const s=r.vt();return r.Re(s,i,e),s}if(!e&&!this.opts.isSliceMM)return this.screenFieldOfViewVox(t);const i=this.volumeObject3D.extentsMin,s=this.volumeObject3D.extentsMax;let n=r.fA(i[0],i[1],i[2]),o=r.fA(s[0],s[1],s[2]);n=this.swizzleVec3MM(n,t),o=this.swizzleVec3MM(o,t);const a=r.vt();return r.Re(a,o,n),a}screenFieldOfViewExtendedVox(t){void 0===t&&(t=0);const e=this.volumes[0].extentsMinOrtho,i=this.volumes[0].extentsMaxOrtho;let s=r.fA(e[0],e[1],e[2]),o=r.fA(i[0],i[1],i[2]);const a=n.vt();s=this.swizzleVec3MM(s,t),o=this.swizzleVec3MM(o,t);const l=r.vt();return r.Re(l,o,s),{mnMM:s,mxMM:o,rotation:a,fovMM:l}}screenFieldOfViewExtendedMM(t){if(void 0===t&&(t=0),this.volumes.length<1){let e=r.fA(this.extentsMin[0],this.extentsMin[1],this.extentsMin[2]),i=r.fA(this.extentsMax[0],this.extentsMax[1],this.extentsMax[2]);const s=n.vt();e=this.swizzleVec3MM(e,t),i=this.swizzleVec3MM(i,t);const o=r.vt();return r.Re(o,i,e),{mnMM:e,mxMM:i,rotation:s,fovMM:o}}if(!this.volumeObject3D)throw new Error("volumeObject3D undefined");const e=this.volumeObject3D.extentsMin,i=this.volumeObject3D.extentsMax;let s=r.fA(e[0],e[1],e[2]),o=r.fA(i[0],i[1],i[2]);const a=n.vt();s=this.swizzleVec3MM(s,t),o=this.swizzleVec3MM(o,t);const l=r.vt();return r.Re(l,o,s),{mnMM:s,mxMM:o,rotation:a,fovMM:l}}drawSliceOrientationText(t,e,i){void 0===i&&(i=[NaN,NaN]),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height);let s="S";0===e&&(s="A");let r=this.opts.isRadiologicalConvention?"R":"L";2===e&&(r=this.opts.sagittalNoseLeft?"A":"P");let n="I";0===e&&(n="P");let o=this.opts.isRadiologicalConvention?"L":"R";if(2===e&&(o=this.opts.sagittalNoseLeft?"P":"A"),this.opts.isCornerOrientationText)return void this.drawTextRightBelow([t[0],t[1]],r+s);let a=!0,l=!0;const h=this.opts.showAllOrientationMarkers,c=this.opts.showAllOrientationMarkers;if(!isNaN(i[0])){const e=this.fontPx+2;i[1]>e&&(this.drawTextBelow([t[0]+.5*t[2],t[1]+i[1]-e],s),a=!1);const n=this.textWidth(e,r)+2;i[0]>n&&(this.drawTextRight([t[0]+i[0]-n,t[1]+.5*t[3]],r),l=!1)}a&&this.drawTextBelow([t[0]+.5*t[2],t[1]],s),l&&this.drawTextRight([t[0],t[1]+.5*t[3]],r),h&&this.drawTextAbove([t[0]+.5*t[2],t[1]+t[3]],n),c&&this.drawTextLeft([t[0]+t[2],t[1]+.5*t[3]],o)}xyMM2xyzMM(t,e){let i=2;1===t&&(i=1),2===t&&(i=0);let s=[0,0,0],n=[1,1,0],o=[1,0,1];s[i]=e,n[i]=e,o[i]=e,s=this.frac2mm(s),n=this.frac2mm(n),o=this.frac2mm(o),s=this.swizzleVec3MM(r.fA(s[0],s[1],s[2]),t),n=this.swizzleVec3MM(r.fA(n[0],n[1],n[2]),t),o=this.swizzleVec3MM(r.fA(o[0],o[1],o[2]),t);const a=(n[0]-s[0])*(o[1]-s[1])-(o[0]-s[0])*(n[1]-s[1]);let l=(n[0]-s[0])*(o[2]-s[2])-(o[0]-s[0])*(n[2]-s[2]);l/=a;let h=(n[1]-s[1])*(o[2]-s[2])-(o[1]-s[1])*(n[2]-s[2]);h/=a;const c=[0,0,0,0,0];return c[0]=s[0],c[1]=s[1],c[2]=s[2],c[3]=h,c[4]=l,c}draw2DMain(t,e,i){void 0===i&&(i=NaN);let s=new Float32Array([0,0,0]);this.volumes.length>0&&(s=new Float32Array(this.volumes[0].frac2mm.slice()));let o=this.screenFieldOfViewExtendedMM(e),a=n.vt();!this.opts.isSliceMM&&this.volumes.length>0&&(s=new Float32Array(this.volumes[0].frac2mmOrtho.slice()),a=n.o8(this.volumes[0].mm2ortho),o=this.screenFieldOfViewExtendedVox(e));let l=this.opts.isRadiologicalConvention&&e<2;i===1/0||i===-1/0?(l=i!==1/0,1===e&&(l=!l)):this.opts.sagittalNoseLeft&&2===e&&(l=!l);let h=0,c=0;2===e?c=l?90:-90:1===e?c=l?180:0:(c=l?180:0,h=l?-90:90);const d=this.gl;let m=!1;if(0===t[2]||0===t[3]){m=!0;const e=d.canvas.width/o.fovMM[0],i=d.canvas.height/o.fovMM[1],s=Math.min(e,i),r=e/s,n=i/s;o.fovMM[0]*=r,o.fovMM[1]*=n;let a=.5*(o.mnMM[0]+o.mxMM[0]);o.mnMM[0]=a-.5*o.fovMM[0],o.mxMM[0]=a+.5*o.fovMM[0],a=.5*(o.mnMM[1]+o.mxMM[1]),o.mnMM[1]=a-.5*o.fovMM[1],o.mxMM[1]=a+.5*o.fovMM[1],t=[0,0,d.canvas.width,d.canvas.height]}if(isNaN(i)){const t=this.scene.pan2Dxyzmm,i=this.swizzleVec3MM(r.fA(t[0],t[1],t[2]),e),s=this.scene.pan2Dxyzmm[3];o.mnMM[0]-=i[0],o.mxMM[0]-=i[0],o.mnMM[1]-=i[1],o.mxMM[1]-=i[1],o.mnMM[0]/=s,o.mxMM[0]/=s,o.mnMM[1]/=s,o.mxMM[1]/=s}let u=2;1===e&&(u=1),2===e&&(u=0);let f=this.scene.crosshairPos[u],g=this.frac2mm(this.scene.crosshairPos);if(!isNaN(i)&&i!==1/0&&i!==-1/0){g=this.frac2mm([.5,.5,.5]),g[u]=i;f=this.mm2frac(g)[u]}const A=g[u],p=d.canvas.height-t[1]-t[3],v=[t[0],p,t[2],t[3]];this.clearBounds(d.DEPTH_BUFFER_BIT,v),d.viewport(v[0],v[1],v[2],v[3]);let x=this.calculateMvpMatrix2D(t,o.mnMM,o.mxMM,1/0,0,c,h,l);if(i===1/0||i===-1/0){const i=t.slice();this.draw3D(t,x.modelViewProjectionMatrix,x.modelMatrix,x.normalMatrix,c,h);const s=this.screenSlices[this.screenSlices.length-1];return s.leftTopWidthHeight=i,s.axCorSag=e,s.sliceFrac=1/0,s.AxyzMxy=this.xyMM2xyzMM(e,f),s.leftTopMM=x.leftTopMM,void(s.fovMM=x.fovMM)}if(d.enable(d.DEPTH_TEST),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.disable(d.BLEND),d.depthFunc(d.ALWAYS),d.disable(d.CULL_FACE),this.volumes.length>0){let i=this.sliceMMShader;if(this.opts.is2DSliceShader&&(i=this.slice2DShader),this.opts.isV1SliceShader&&(i=this.sliceV1Shader),this.customSliceShader&&(i=this.customSliceShader),!i)throw new Error("slice Shader undefined");i.use(this.gl),d.uniform1f(i.uniforms.overlayOutlineWidth,this.overlayOutlineWidth),d.uniform1f(i.uniforms.overlayAlphaShader,this.overlayAlphaShader),d.uniform1i(i.uniforms.isAlphaClipDark,this.isAlphaClipDark?1:0),d.uniform1i(i.uniforms.backgroundMasksOverlays,this.backgroundMasksOverlays),d.uniform1f(i.uniforms.drawOpacity,this.drawOpacity),d.uniform1f(i.uniforms.drawRimOpacity,this.drawRimOpacity),d.enable(d.BLEND),d.blendFunc(d.SRC_ALPHA,d.ONE_MINUS_SRC_ALPHA),d.uniform1f(i.uniforms.opacity,this.volumes[0].opacity),d.uniform1i(i.uniforms.axCorSag,e),d.uniform1f(i.uniforms.slice,f),d.uniformMatrix4fv(i.uniforms.frac2mm,!1,s),d.uniformMatrix4fv(i.uniforms.mvpMtx,!1,x.modelViewProjectionMatrix.slice()),d.bindVertexArray(this.genericVAO),d.drawArrays(d.TRIANGLE_STRIP,0,4),d.bindVertexArray(this.unusedVAO),this.screenSlices.push({leftTopWidthHeight:t,axCorSag:e,sliceFrac:f,AxyzMxy:this.xyMM2xyzMM(e,f),leftTopMM:x.leftTopMM,screen2frac:[],fovMM:x.fovMM})}if(d.depthMask(!0),d.depthFunc(d.LEQUAL),isNaN(i)&&this.drawCrosshairs3D(!0,1,x.modelViewProjectionMatrix,!0,this.opts.isSliceMM),this.opts.meshThicknessOn2D>0){this.opts.meshThicknessOn2D!==1/0&&(x=this.calculateMvpMatrix2D(t,o.mnMM,o.mxMM,this.opts.meshThicknessOn2D,A,c,h,l));const e=n.o8(x.modelViewProjectionMatrix);n.lw(e,e,a),this.drawMesh3D(!0,1,e,x.modelMatrix,x.normalMatrix)}isNaN(i)&&this.drawCrosshairs3D(!1,.15,x.modelViewProjectionMatrix,!0,this.opts.isSliceMM),m&&this.opts.isOrientationTextVisible&&this.drawSliceOrientationText(t,e),this.readyForSync=!0}draw2D(t,e,i,s){void 0===i&&(i=NaN),void 0===s&&(s=[NaN,NaN]);const[r,n,o,a]=this.getBoundsRegion();let l;l=0===t[2]&&0===t[3]?this.opts.bounds?[r,n,o,a]:[0,0,this.gl.canvas.width,this.gl.canvas.height]:t.slice();const h=[NaN,NaN];if(s[0]===1/0){const t=this.sliceScale().volScale;let i=this.scaleSlice(t[0],t[1],[0,0],[l[2],l[3]]);1===e&&(i=this.scaleSlice(t[0],t[2],[0,0],[l[2],l[3]])),2===e&&(i=this.scaleSlice(t[1],t[2],[0,0],[l[2],l[3]])),s[0]=i[2],s[1]=i[3]}isNaN(s[0])||(h[0]=Math.floor(.5*(l[2]-s[0])),h[1]=Math.floor(.5*(l[3]-s[1])),l[0]+=h[0],l[1]+=h[1],l[2]=s[0],l[3]=s[1]),this.draw2DMain(l,e,i),i!==1/0&&i!==-1/0&&4!==e&&0!==l[2]&&0!==l[3]&&this.opts.isOrientationTextVisible&&this.drawSliceOrientationText(l,e,h)}calculateMvpMatrix(t,e,i,s,o){void 0===e&&(e=[0,0,0,0]),void 0===o&&(o=!0);const a=this.gl;0!==e[2]&&0!==e[3]||(e=[0,0,a.canvas.width,a.canvas.height]);const l=e[2]/e[3];let h=this.furthestFromPivot;const c=this.pivot3D,d=n.vt();h=.8*h/this.scene.volScaleMultiplier,l<1?n.v3(d,-h,h,-h/l,h/l,.01*h,8*h):n.v3(d,-h*l,h*l,-h,h,.01*h,8*h);const m=n.vt();o&&(m[0]=-1);const u=r.fA(0,0,1.8*-h);n.Tl(m,m,u),this.position&&n.Tl(m,m,this.position),n.eL(m,m,Oi(270-s)),n.Qr(m,m,Oi(i-180)),n.Tl(m,m,[-c[0],-c[1],-c[2]]);const f=n.vt();n.B8(f,m);const g=n.vt();n.mg(g,f);const A=n.vt();return n.lw(A,d,m),[A,m,g]}calculateModelMatrix(t,e){if(!this.back)throw new Error("back undefined");const i=n.vt();if(i[0]=-1,n.eL(i,i,Oi(270-e)),n.Qr(i,i,Oi(t-180)),this.back.obliqueRAS){const t=n.o8(this.back.obliqueRAS);n.lw(i,i,t)}return i}calculateRayDirection(t,e){const i=this.calculateModelMatrix(t,e),o=n.fA(1,0,0,0,0,-1,0,0,0,0,-1,0,0,0,0,1),a=n.vt();n.lw(a,o,i);const l=n.vt();n.B8(l,a);const h=s.fA(0,0,-1,1);s.Z0(h,h,l);const c=r.fA(h[0],h[1],h[2]);r.S8(c,c);const d=5e-5;return Math.abs(c[0])<d&&(c[0]=d),Math.abs(c[1])<d&&(c[1]=d),Math.abs(c[2])<d&&(c[2]=d),c}sceneExtentsMinMax(t){void 0===t&&(t=!0);let e=r.fA(0,0,0),i=r.fA(0,0,0);if(this.volumes.length>0){if(!this.volumeObject3D)throw new Error("volumeObject3D undefined");e=r.fA(this.volumeObject3D.extentsMin[0],this.volumeObject3D.extentsMin[1],this.volumeObject3D.extentsMin[2]),i=r.fA(this.volumeObject3D.extentsMax[0],this.volumeObject3D.extentsMax[1],this.volumeObject3D.extentsMax[2]),t||(e=r.fA(this.volumes[0].extentsMinOrtho[0],this.volumes[0].extentsMinOrtho[1],this.volumes[0].extentsMinOrtho[2]),i=r.fA(this.volumes[0].extentsMaxOrtho[0],this.volumes[0].extentsMaxOrtho[1],this.volumes[0].extentsMaxOrtho[2]))}if(this.meshes.length>0){if(this.volumes.length<1){const t=this.meshes[0].extentsMin,s=this.meshes[0].extentsMax;e=r.fA(t[0],t[1],t[2]),i=r.fA(s[0],s[1],s[2])}for(let t=0;t<this.meshes.length;t++){const s=this.meshes[t].extentsMin,n=this.meshes[t].extentsMax,o=r.fA(s[0],s[1],s[2]);r.jk(e,e,o);const a=r.fA(n[0],n[1],n[2]);r.T9(i,i,a)}}const s=r.vt();return r.Re(s,i,e),[e,i,s]}setPivot3D(){const[t,e]=this.sceneExtentsMinMax(),i=r.vt();r.WQ(i,t,e),r.hs(i,i,.5),this.pivot3D=[i[0],i[1],i[2]],r.Re(i,e,t),this.extentsMin=t,this.extentsMax=e,this.furthestFromPivot=.5*r.Bw(i)}getMaxVols(){if(this.volumes.length<1)return 0;let t=0;for(let e=0;e<this.volumes.length;e++)t=Math.max(t,this.volumes[e].nFrame4D);return t}detectPartialllyLoaded4D(){if(this.volumes.length<1)return!1;for(let t=0;t<this.volumes.length;t++)if(this.volumes[t].nFrame4D<this.volumes[t].hdr.dims[4])return!0;return!1}drawGraph(){if(this.getMaxVols()<2)return;const t=this.graph,[e,i,s,r]=this.getBoundsRegion();let n=0;if(t.autoSizeMultiplanar&&3===this.opts.sliceType)for(let B=0;B<this.screenSlices.length;B++){const e=this.screenSlices[B].axCorSag;if(0===e&&(n=this.screenSlices[B].leftTopWidthHeight[1]),2!==e)continue;const i=this.screenSlices[B].leftTopWidthHeight.slice();i[1]===n?(t.LTWH[0]=i[0]+i[2],t.LTWH[1]=i[1]):(t.LTWH[0]=i[0],t.LTWH[1]=i[1]+i[3]),t.LTWH[2]=i[2],t.LTWH[3]=i[2]}if(t.LTWH[0]=Math.max(e,t.LTWH[0]),t.LTWH[1]=Math.max(i,t.LTWH[1]),t.LTWH[2]=Math.min(s,t.LTWH[2]),t.LTWH[3]=Math.min(r,t.LTWH[3]),t.opacity<=0||t.LTWH[2]<=5||t.LTWH[3]<=5||Math.floor(t.LTWH[0]+t.LTWH[2])>e+s||Math.floor(t.LTWH[1]+t.LTWH[3])>i+r)return;t.backColor=[.15,.15,.15,t.opacity],t.lineColor=[1,1,1,1],this.opts.backColor[0]+this.opts.backColor[1]+this.opts.backColor[2]>1.5&&(t.backColor=[.95,.95,.95,t.opacity],t.lineColor=[0,0,0,1]);t.lineColor[3]=.2,t.textColor=t.lineColor.slice(),t.textColor[3]=1,t.lineThickness=3,t.gridLineThickness=1,t.lineAlpha=1,t.lines=[];const o=[];if(t.vols.length<1)null!=this.volumes[0]&&o.push(0);else for(let B=0;B<t.vols.length;B++){const e=t.vols[B];if(null==this.volumes[e])continue;this.volumes[e].nFrame4D<2||o.push(e)}if(o.length<1)return;const a=this.volumes[o[0]].nFrame4D;if(this.graph.selectedColumn=this.volumes[o[0]].frame4D,a<2)return void U.debug("Unable to generate a graph: Selected volume is 3D not 4D");for(let B=0;B<o.length;B++){t.lines[B]=[];const e=this.frac2vox(this.scene.crosshairPos),i=this.volumes[o[B]];let s=i.nFrame4D;s=Math.min(s,a);for(let r=0;r<s;r++){const s=i.getValue(e[0],e[1],e[2],r);t.lines[B].push(s)}}t.lineRGB=[[.8,0,0],[0,.7,0],[0,0,.9],[.7,.7,0],[.8,0,.8],[0,.7,.7],[.6,.6,.6],[0,0,0]];let l=t.lines[0][0],h=t.lines[0][0];for(let B=0;B<t.lines.length;B++)for(let e=0;e<t.lines[B].length;e++){const i=t.lines[B][e];l=Math.min(i,l),h=Math.max(i,h)}const c=this.volumes[o[0]].cal_min,d=this.volumes[o[0]].cal_max;if(t.isRangeCalMinMax&&c<d&&isFinite(c)&&isFinite(d)&&(l=c,h=d),t.normalizeValues&&h>l){const e=h-l;for(let i=0;i<t.lines.length;i++)for(let s=0;s<t.lines[i].length;s++){const r=t.lines[i][s];t.lines[i][s]=(r-l)/e}l=0,h=1}l>=h&&(h=l+1),this.drawRect(t.LTWH,t.backColor);const[m,u,f]=ki(l,h),g=Math.max(0,-1*Math.floor(Math.log(m)/Math.log(10)));function A(t){return t.toFixed(6).replace(/\.?0*$/,"")}l=Math.min(u,l),h=Math.max(f,h);let p=.7*this.fontPx;p=s/this.uiData.dpr*(r/this.uiData.dpr)<48e4?0:Math.max(p,this.opts.fontMinPx);const v=p/this.fontPx;let x=0,w=u;if(p>0)for(;w<=h;){const t=w.toFixed(g),e=this.textWidth(p,t);x=Math.max(e,x),w+=m}const b=.05,y=Math.abs(t.LTWH[2]),C=Math.abs(t.LTWH[3]),M=[t.LTWH[0]+b*y+x,t.LTWH[1]+b*C,t.LTWH[2]-x-.1*y,t.LTWH[3]-p-.125*C];this.graph.LTWH=t.LTWH,this.graph.plotLTWH=M,this.drawRect(M,this.opts.backColor);const D=M[3]/(h-l),I=M[2]/(t.lines[0].length-1),T=M[1]+M[3];w=u+.5*m;const S=t.lineColor.slice();for(S[3]=.5*t.lineColor[3];w<=h;){const e=T-(w-l)*D;this.drawLine([M[0],e,M[0]+M[2],e],t.gridLineThickness,S),w+=m}w=u;const F=.5*t.gridLineThickness;for(;w<=h;){const e=T-(w-l)*D;this.drawLine([M[0]-F,e,M[0]+M[2]+t.gridLineThickness,e],t.gridLineThickness,t.lineColor);const i=w.toFixed(g);p>0&&this.drawTextLeft([M[0]-6,e],i,v,t.textColor),w+=m}let E=1;for(;t.lines[0].length/E>20;)E*=5;for(let B=0;B<t.lines[0].length;B+=E){const e=B*I+M[0];let i=t.gridLineThickness;if(B%2==1)i*=.5,this.drawLine([e,M[1],e,M[1]+M[3]],i,S);else{const s=A(B);p>0&&this.drawTextBelow([e,2+M[1]+M[3]],s,v,t.textColor),this.drawLine([e,M[1],e,M[1]+M[3]],i,t.lineColor)}}for(let B=0;B<t.lines.length;B++){let e=[1,0,0,t.lineAlpha];B<t.lineRGB.length&&(e=[t.lineRGB[B][0],t.lineRGB[B][1],t.lineRGB[B][2],t.lineAlpha]);for(let i=1;i<t.lines[B].length;i++){const s=(i-1)*I,r=i*I,n=(t.lines[B][i-1]-l)*D,o=(t.lines[B][i]-l)*D,a=[M[0]+s,M[1]+M[3]-n,M[0]+r,M[1]+M[3]-o];this.drawLine(a,t.lineThickness,e)}}if(t.selectedColumn>=0&&t.selectedColumn<t.lines[0].length){const e=t.selectedColumn*I+M[0];this.drawLine([e,M[1],e,M[1]+M[3]],t.lineThickness,[t.lineRGB[0][0],t.lineRGB[0][1],t.lineRGB[0][2],.3])}p>0&&t.LTWH[1]+t.LTWH[3]>M[1]+M[3]+2.4*p&&this.drawTextBelow([M[0]+.5*M[2],M[1]+M[3]+1.2*p],"Volume",v,t.textColor),this.detectPartialllyLoaded4D()&&this.drawTextBelow([M[0]+M[2],M[1]+M[3]+.5*p],"...",v,t.textColor)}depthPicker(t,e){if(!this.uiData.mouseDepthPicker)return;this.uiData.mouseDepthPicker=!1;const i=this.gl,r=this.mousePos[0]*t[2]/t[2],o=i.canvas.height-this.mousePos[1]*t[3]/t[3]-1,a=new Uint8Array(4);if(i.readPixels(r,o,1,1,i.RGBA,i.UNSIGNED_BYTE,a),this.selectedObjectId=a[3],this.selectedObjectId===this.VOLUME_ID)return void(this.scene.crosshairPos=new Float32Array(a.slice(0,3)).map((t=>t/255)));const l=function(t){const e=[1/16777216,1/65536,1/256,1];return(t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3])/255}(a);if(l>1)return;const h=function(t,e,i,r){const o=s.fA(t,e,i,1),a=n.o8(r);n.B8(a,a),o[0]=2*o[0]-1,o[1]=2*o[1]-1,o[2]=2*o[2]-1;const l=s.vt();return s.Z0(l,o,a),0===l[3]||(l[0]/=l[3],l[1]/=l[3],l[2]/=l[3]),l}((this.mousePos[0]-t[0])/t[2],(i.canvas.height-this.mousePos[1]-t[1])/t[3],l,e),c=this.mm2frac(h,0,!0);c[0]<0||c[0]>1||c[1]<0||c[1]>1||c[2]<0||c[2]>1||(this.scene.crosshairPos=this.mm2frac(h,0,!0))}drawImage3D(t,e,i){if(0===this.volumes.length)return;const s=this.gl,r=this.calculateRayDirection(e,i),o=this.volumeObject3D;if(o){s.enable(s.BLEND),s.blendFunc(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA),s.enable(s.CULL_FACE),s.cullFace(s.FRONT);let a=this.renderShader;if(this.uiData.mouseDepthPicker&&(a=this.pickingImageShader),a.use(this.gl),s.uniform1i(a.uniforms.backgroundMasksOverlays,this.backgroundMasksOverlays),this.gradientTextureAmount>0&&a.uniforms.normMtx&&this.gradientTexture){s.activeTexture(Ji),s.bindTexture(s.TEXTURE_3D,this.gradientTexture);const t=this.calculateModelMatrix(e,i),r=n.vt();n.B8(r,t);const o=n.vt();n.mg(o,r),s.uniformMatrix4fv(a.uniforms.normMtx,!1,o)}this.drawBitmap&&this.drawBitmap.length>8?s.uniform2f(a.uniforms.renderDrawAmbientOcclusionXY,this.renderDrawAmbientOcclusion,this.drawOpacity):s.uniform2f(a.uniforms.renderDrawAmbientOcclusionXY,this.renderDrawAmbientOcclusion,0),this.gl.uniform4fv(a.uniforms.paqdUniforms,this.opts.paqdUniforms),s.uniformMatrix4fv(a.uniforms.mvpMtx,!1,t),s.uniformMatrix4fv(a.uniforms.matRAS,!1,this.back.matRAS),s.uniform3fv(a.uniforms.rayDir,r),this.gradientTextureAmount<0?s.uniform4fv(a.uniforms.clipPlane,[this.scene.crosshairPos[0],this.scene.crosshairPos[1],this.scene.crosshairPos[2],30]):s.uniform4fv(a.uniforms.clipPlane,this.scene.clipPlane),s.uniform1f(a.uniforms.drawOpacity,1),s.bindVertexArray(o.vao),s.drawElements(o.mode,o.indexCount,s.UNSIGNED_SHORT,0),s.bindVertexArray(this.unusedVAO)}}drawOrientationCube(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=0),!this.opts.isOrientCube)return;const s=.05*Math.min(t[2],t[3]);if(s<5)return;const r=this.gl;r.enable(r.CULL_FACE),r.cullFace(r.BACK),this.orientCubeShader.use(this.gl),r.bindVertexArray(this.orientCubeShaderVAO);const o=n.vt(),a=n.vt();n.v3(a,0,r.canvas.width,0,r.canvas.height,-10*s,10*s);let l=0;0===t[1]&&(l=r.canvas.height-this.effectiveCanvasHeight()),n.Tl(o,o,[1.8*s+t[0],l+1.8*s+t[1],0]),n.hs(o,o,[s,s,s]),n.eL(o,o,Oi(270-i)),n.Qr(o,o,Oi(-e));const h=n.vt();n.lw(h,a,o),r.uniformMatrix4fv(this.orientCubeShader.uniforms.u_matrix,!1,h),r.drawArrays(r.TRIANGLE_STRIP,0,168),r.bindVertexArray(this.unusedVAO),this.gl.disable(this.gl.CULL_FACE)}createOnLocationChange(t){void 0===t&&(t=NaN);const[e,i,s]=this.sceneExtentsMinMax(!0),r=Math.max(Math.max(s[0],s[1]),s[2]);let n=(o=.001*r,Math.max(0,-Math.ceil(Math.log10(Math.abs(o)))));var o;const a=this.frac2mm(this.scene.crosshairPos,0,!0);function l(t,e){return void 0===e&&(e=0),parseFloat(t.toFixed(e))}let h=l(a[0],n)+"\xd7"+l(a[1],n)+"\xd7"+l(a[2],n);if(this.volumes.length>0&&this.volumes[0].nFrame4D>0&&(h+="\xd7"+l(this.volumes[0].frame4D)),this.volumes.length>0){let t=" = ";for(let s=0;s<this.volumes.length;s++){const e=this.volumes[s].mm2vox(a);let i=this.volumes[s].getValue(e[0],e[1],e[2],this.volumes[s].frame4D);if(n=3,null!==this.volumes[s].colormapLabel){const r=Math.round(i);if(1002===this.volumes[s].hdr.intent_code&&2304===this.volumes[s].hdr.datatypeCode){const i=this.volumes[s].getValues(e[0],e[1],e[2],this.volumes[s].frame4D);if(i[2]>2){const e=Math.round(100*i[2]/255);if(t+=this.volumes[s].colormapLabel.labels[i[0]]+` (${e}%)`,i[3]>2){const e=Math.round(100*i[3]/255);t+=" "+this.volumes[s].colormapLabel.labels[i[1]]+` (${e}%)`}}}else r>=0&&this.volumes[s].colormapLabel.labels&&r<this.volumes[s].colormapLabel.labels.length?t+=this.volumes[s].colormapLabel.labels[r]:t+="undefined("+l(i,n)+")"}else t+=l(i,n);this.volumes[s].imaginary&&(i=this.volumes[s].getValue(e[0],e[1],e[2],this.volumes[s].frame4D,!0),i>=0&&(t+="+"),t+=l(i,n)),t+="   "}h+=t;const e=this.back.dimsRAS,i=e[1]*e[2]*e[3];if(this.drawBitmap&&this.drawBitmap.length===i){const t=this.frac2vox(this.scene.crosshairPos),i=t[0]+t[1]*e[1]+t[2]*e[1]*e[2];h+=" "+this.drawLut.labels[this.drawBitmap[i]]}}const c={mm:this.frac2mm(this.scene.crosshairPos,0,!0),axCorSag:t,vox:this.frac2vox(this.scene.crosshairPos),frac:this.scene.crosshairPos,xy:[this.mousePos[0],this.mousePos[1]],values:this.volumes.map((t=>{const e=this.frac2mm(this.scene.crosshairPos,0,!0),i=t.mm2vox(e),s=t.getValue(i[0],i[1],i[2],t.frame4D);return{name:t.name,value:s,id:t.id,mm:e,vox:i}})),string:h};this.onLocationChange(c)}addLabel(t,e,i,s,r){const n={textColor:this.opts.legendTextColor,textScale:1,textAlignment:"left",lineWidth:0,lineColor:this.opts.legendTextColor,lineTerminator:"none",bulletScale:0,bulletColor:this.opts.legendTextColor},o=e?{...n,...e}:{...n},a=new ce(t,{...o},i,s,r);return this.document.labels.push(a),a}calculateScreenPoint(t,e,i){const r=s.vt();return s.Z0(r,[...t,1],e),0!==r[3]&&(r[0]=.5*(r[0]/r[3]+1)*i[2],r[1]=.5*(1-r[1]/r[3])*i[3],r[2]/=r[3],r[0]+=i[0],r[1]+=i[1]),r}getLabelAtPoint(t){const e=this.legendFontScaling,i=this.fontPx*e,s=this.fontPx*e;for(const h of this.document.labels){if(null==h.anchor||0===h.anchor)continue;const i=this.fontPx*h.style.textScale*e,r=this.textHeight(i,h.text),n=this.textWidth(i,h.text);if(!(1&h.anchor&&t[0]>n)){if(2&h.anchor){if(t[0]<(this.gl.canvas.width-n)/2)continue;if(t[0]>(this.gl.canvas.width+n)/2)continue}if(!(4&h.anchor&&t[0]<this.gl.canvas.width-n)){if(8&h.anchor){if(t[1]<s/2)continue;if(t[1]>r+s/2)continue}if(16&h.anchor){if(t[1]<(this.gl.canvas.height-r-s)/2)continue;if(t[1]>(this.gl.canvas.height+r-s/2)/2)continue}if(32&h.anchor){if(t[1]<this.gl.canvas.height-r-s)continue;if(t[1]>this.gl.canvas.height-s/2)continue}return h}}}U.debug("screenPoint",t);const r=this.getLegendPanelHeight(e),n=this.getLegendPanelWidth(),o=this.gl.canvas.width-n;let a=(this.canvas.height-r)/2;if(U.debug("panelrect",o,a,o+n,a+r),t[0]<o||t[1]<a||t[0]>o+n||t[1]>a+r)return null;const l=this.getConnectomeLabels();for(const h of l){const s=this.fontPx*h.style.textScale*e,r=this.textHeight(s,h.text);if(t[1]>=a&&t[1]<=a+r+i/2)return U.debug(`label clicked ${h.text}`),h;a+=r,a+=i/2}return null}drawLabelLine(t,e,i,s,r){void 0===r&&(r=!1);const n=Array.isArray(t.points)&&Array.isArray(t.points[0])?t.points:[t.points];for(const o of n){const n=this.calculateScreenPoint(o,i,s);r?this.drawDottedLine([...e,n[0],n[1]],t.style.lineWidth,t.style.lineColor):this.draw3DLine(e,[n[0],n[1],n[2]],t.style.lineWidth,t.style.lineColor)}}draw3DLabel(t,e,i,s,r,n,o,a){void 0===a&&(a=1);const l=t.text,h=e[0],c=e[1],d=this.fontPx*a,m=this.textHeight(t.style.textScale,l)*d;if(t.style.lineWidth>0&&Array.isArray(t.points)&&this.drawLabelLine(t,[h,c+m],i,s,o),t.style.bulletScale){const e=t.style.bulletScale*m,i=c+(m-e)/2+e/2,s=h+(r-e)/2;this.drawCircle([s,i,e,e],t.style.bulletColor)}let u=h;if(n)if("left"!==t.style.textAlignment){const e=this.textWidth(t.style.textScale,t.text)*d;if("right"===t.style.textAlignment)u=h+n-1.5*d-e;else{u+=(n-(r||d)-e)/2}}else u+=r;const f=t.style.textScale;this.drawText([u,c],l,f,t.style.textColor)}draw3DLabels(t,e,i){void 0===i&&(i=!1);const s=this.getConnectomeLabels();if(!this.opts.showLegend||0===s.length)return;let r=this.getLegendPanelHeight(1);if(!this.canvas||r<1)return;const n=this.gl;if(n.disable(n.CULL_FACE),n.viewport(0,0,this.canvas.width,this.canvas.height),this.legendFontScaling=1,r>this.canvas.height){const t=10*this.uiData.dpr;this.legendFontScaling=Math.max(this.canvas.height-t,1)/r,U.debug(`Legend too large for screen, font reduction factor x${this.legendFontScaling}`),r=this.getLegendPanelHeight(this.legendFontScaling)}const o=this.fontPx*this.legendFontScaling,a=this.getBulletMarginWidth(),l=this.getLegendPanelWidth(),h=n.canvas.width-l;let c=(this.canvas.height-r)/2;this.drawRect([n.canvas.width-l,c,l-o,r],this.opts.legendBackgroundColor);const d=n.getParameter(n.BLEND),m=n.getParameter(n.DEPTH_FUNC);i||(n.disable(n.BLEND),n.depthFunc(n.LEQUAL));for(const u of s){this.draw3DLabel(u,[h,c],t,e,a,l,i,this.legendFontScaling);const s=this.fontPx*u.style.textScale;c+=this.textHeight(s,u.text)*this.legendFontScaling,c+=o/2}i||(n.depthFunc(m),d&&n.enable(n.BLEND))}drawAnchoredLabels(){const t=this.fontPx,e=this.document.labels.filter((t=>null!=t.anchor&&0!==t.anchor));for(const i of e){const e=i.text,s=this.textHeight(i.style.textScale,e)*t,r=this.textWidth(i.style.textScale,e)*t;let n,o;const a=1,l=this.fontPx*a,h=l;let c=l/4,d=0,m=0;1&i.anchor&&(n=0),4&i.anchor&&(n=this.canvas.width-r,d-=l/4),2&i.anchor&&(n=(this.canvas.width-r)/2,d-=l/4,c+=l/4),8&i.anchor&&(o=0),16&i.anchor&&(o=(this.canvas.height-s-l)/2,m-=l/4),32&i.anchor&&(o=this.canvas.height-s-l,m-=l/4),this.drawRect([n+d,o+m,r+c,s+h],i.style.backgroundColor),this.draw3DLabel(i,[n,o])}}draw3D(t,e,i,s,r,n){void 0===t&&(t=[0,0,0,0]),void 0===e&&(e=null),void 0===i&&(i=null),void 0===s&&(s=null),void 0===r&&(r=null),void 0===n&&(n=0);const o=this.gl,[a,l,h,c]=this.getBoundsRegion();let d=[...t];0!==d[2]&&0!==d[3]||(d=this.opts.bounds?[a,l,h,c]:[0,0,o.canvas.width,o.canvas.height]);const m=null!==r;this.setPivot3D(),m||(r=this.scene.renderAzimuth,n=this.scene.renderElevation),null===e&&([e,i,s]=this.calculateMvpMatrix(null,d,r,n));const u=[...d];this.screenSlices.push({leftTopWidthHeight:d.slice(),axCorSag:4,sliceFrac:0,AxyzMxy:[],leftTopMM:[],fovMM:[Ki(i),0]});const f=[d[0],o.canvas.height-d[3]-d[1],d[2],d[3]];if(d[1]=o.canvas.height-d[3]-d[1],o.enable(o.DEPTH_TEST),o.depthFunc(o.ALWAYS),o.depthMask(!0),this.draw3DLabels(e,u,!1),this.gl.viewport(f[0],f[1],f[2],f[3]),this.volumes.length>0&&(this.updateInterpolation(0,!0),this.updateInterpolation(1,!0),this.drawImage3D(e,r,n)),this.updateInterpolation(0),this.updateInterpolation(1),m||this.drawCrosshairs3D(!0,1,e),this.drawMesh3D(!0,1,e,i,s),this.uiData.mouseDepthPicker)return this.depthPicker(d,e),this.createOnLocationChange(),void this.draw3D(u,e,i,s,r,n);this.opts.meshXRay>0&&this.drawMesh3D(!1,this.opts.meshXRay,e,i,s),this.draw3DLabels(e,u,!1),o.viewport(d[0],d[1],d[2],d[3]),m||this.drawCrosshairs3D(!1,.15,e),o.viewport(a,l,h,c),this.drawOrientationCube(d,r,n);const g="azimuth: "+this.scene.renderAzimuth.toFixed(0)+" elevation: "+this.scene.renderElevation.toFixed(0);return this.readyForSync=!0,this.sync(),this.draw3DLabels(e,u,!0),g}drawMesh3D(t,e,i,s,r){if(void 0===t&&(t=!0),void 0===e&&(e=1),this.meshes.length<1)return;const n=this.gl;i||([i,s,r]=this.calculateMvpMatrix(this.volumeObject3D,void 0,this.scene.renderAzimuth,this.scene.renderElevation,!1)),n.enable(n.DEPTH_TEST),t?(n.clearDepth(0),n.clear(n.DEPTH_BUFFER_BIT),n.depthFunc(n.GREATER)):n.depthFunc(n.ALWAYS),n.enable(n.CULL_FACE),n.cullFace(n.BACK),n.frontFace(n.CCW),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA);let o=!1;for(const a of this.meshes){if(!a.visible||a.opacity<=0||a.indexCount<3)continue;const t=a.opacity*e;let s=this.meshShaders[a.meshShaderIndex].shader;this.uiData.mouseDepthPicker&&(s=this.pickingMeshShader),s.use(n),n.uniformMatrix4fv(s.uniforms.mvpMtx,!1,i),n.uniformMatrix4fv(s.uniforms.normMtx,!1,r),n.uniform1f(s.uniforms.opacity,t),t>=1?(n.disable(n.BLEND),n.depthMask(!0)):(n.enable(n.BLEND),n.depthMask(!1)),a.offsetPt0&&(a.fiberSides<3||a.fiberRadius<=0)?o=!0:(s.isMatcap&&(n.activeTexture(ji),n.bindTexture(n.TEXTURE_2D,this.matCapTexture)),n.bindVertexArray(a.vao),n.drawElements(n.TRIANGLES,a.indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO))}if(n.depthMask(!0),n.disable(n.BLEND),this.opts.meshXRay>0){n.enable(n.BLEND),n.depthMask(!1),n.depthFunc(n.ALWAYS);for(const t of this.meshes){if(!t.visible||t.indexCount<3)continue;const s=this.meshShaders[t.meshShaderIndex].shader;s.use(n),n.uniformMatrix4fv(s.uniforms.mvpMtx,!1,i),n.uniformMatrix4fv(s.uniforms.normMtx,!1,r),n.uniform1f(s.uniforms.opacity,t.opacity*e*this.opts.meshXRay),n.bindVertexArray(t.vao),n.drawElements(n.TRIANGLES,t.indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)}n.depthMask(!0),n.depthFunc(n.GREATER),n.disable(n.BLEND)}if(o){const t=this.fiberShader;t.use(n),n.uniformMatrix4fv(t.uniforms.mvpMtx,!1,i),n.uniform1f(t.uniforms.opacity,e);for(const e of this.meshes)e.offsetPt0&&(e.fiberSides>=3&&e.fiberRadius>0||(n.bindVertexArray(e.vaoFiber),n.drawElements(n.LINE_STRIP,e.indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)))}this.readyForSync=!0}drawCrosshairs3D(t,e,i,s,r){if(void 0===t&&(t=!0),void 0===e&&(e=1),void 0===i&&(i=null),void 0===s&&(s=!1),void 0===r&&(r=!0),!this.opts.show3Dcrosshair&&!s)return;if(this.opts.crosshairWidth<=0&&s)return;const n=this.gl,o=this.frac2mm(this.scene.crosshairPos,0,r);let a=1;const[l,h,c]=this.sceneExtentsMinMax(r);if(this.volumes.length>0){if(!this.back)throw new Error("back undefined");a=.5*Math.min(Math.min(this.back.pixDims[1],this.back.pixDims[2]),this.back.pixDims[3])}else(c[0]<50||c[0]>1e3)&&(a=.02*c[0]);if(a*=this.opts.crosshairWidth,"percent"===this.opts?.crosshairWidthUnit&&(a=c[0]*this.opts.crosshairWidth*.5*.01),"mm"===this.opts?.crosshairWidthUnit&&(a=.5*this.opts.crosshairWidth),null!==this.crosshairs3D&&this.crosshairs3D.mm[0]===o[0]&&this.crosshairs3D.mm[1]===o[1]&&this.crosshairs3D.mm[2]===o[2]||(null!==this.crosshairs3D&&(n.deleteBuffer(this.crosshairs3D.indexBuffer),n.deleteBuffer(this.crosshairs3D.vertexBuffer)),this.crosshairs3D=B.generateCrosshairs(this.gl,1,o,l,h,a,20,this.opts.crosshairGap),this.crosshairs3D.mm=o),!this.surfaceShader)throw new Error("surfaceShader undefined");const d=this.surfaceShader;d.use(this.gl),null==i&&([i]=this.calculateMvpMatrix(this.crosshairs3D,void 0,this.scene.renderAzimuth,this.scene.renderElevation)),n.uniformMatrix4fv(d.uniforms.mvpMtx,!1,i),n.disable(n.CULL_FACE),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.crosshairs3D.indexBuffer),n.enable(n.DEPTH_TEST);const m=[...this.opts.crosshairColor];t?(n.disable(n.BLEND),n.depthFunc(n.GREATER)):(n.enable(n.BLEND),n.blendFunc(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.ALWAYS)),m[3]=e,n.uniform4fv(d.uniforms.surfaceColor,m),n.bindVertexArray(this.crosshairs3D.vao),n.drawElements(n.TRIANGLES,this.crosshairs3D.indexCount,n.UNSIGNED_INT,0),n.bindVertexArray(this.unusedVAO)}mm2frac(t,e,i){if(void 0===e&&(e=0),void 0===i&&(i=!1),this.volumes.length<1){const e=r.fA(.1,.5,.5),[i,s,n]=this.sceneExtentsMinMax();return e[0]=(t[0]-i[0])/n[0],e[1]=(t[1]-i[1])/n[1],e[2]=(t[2]-i[2])/n[2],isFinite(e)||(isFinite(e[0])||(e[0]=.5),isFinite(e[1])||(e[1]=.5),isFinite(e[2])||(e[2]=.5),this.meshes.length<1&&U.error("mm2frac() not finite: objects not (yet) loaded.")),e}return this.volumes[e].convertMM2Frac(t,i||this.opts.isSliceMM)}vox2frac(t,e){return void 0===e&&(e=0),this.volumes[e].convertVox2Frac(t)}frac2vox(t,e){return void 0===e&&(e=0),this.volumes.length<=e?[0,0,0]:this.volumes[e].convertFrac2Vox(t)}moveCrosshairInVox(t,e,i){const s=this.frac2vox(this.scene.crosshairPos),r=s[2];s[0]+=t,s[1]+=e,s[2]+=i,s[0]=Gi(s[0],0,this.volumes[0].dimsRAS[1]-1),s[1]=Gi(s[1],0,this.volumes[0].dimsRAS[2]-1),s[2]=Gi(s[2],0,this.volumes[0].dimsRAS[3]-1),this.scene.crosshairPos=this.vox2frac(s),this.createOnLocationChange(),this.opts.is2DSliceShader&&r!==s[2]&&(this.updateGLVolume(),this.refreshDrawing(!1)),this.drawScene()}frac2mm(t,e,i){void 0===e&&(e=0),void 0===i&&(i=!1);const r=s.fA(t[0],t[1],t[2],1);if(this.volumes.length>0)return this.volumes[e].convertFrac2MM(t,i||this.opts.isSliceMM);{const[e,i]=this.sceneExtentsMinMax(),s=(t,e,i)=>t*(1-i)+e*i;r[0]=s(e[0],i[0],t[0]),r[1]=s(e[1],i[1],t[1]),r[2]=s(e[2],i[2],t[2])}return r}screenXY2TextureFrac(t,e,i,s){void 0===s&&(s=!0);const n=r.fA(-1,-1,-1),o=this.screenSlices[i].axCorSag;if(o>2)return n;const a=this.screenSlices[i].leftTopWidthHeight.slice();let l=!1;a[2]<0&&(l=!0,a[0]+=a[2],a[2]=-a[2]);let h=(t-a[0])/a[2];l&&(h=1-h);const c=1-(e-a[1])/a[3];if(h<0||h>1||c<0||c>1)return n;if(this.screenSlices[i].AxyzMxy.length<4)return n;let d=r.fA(0,0,0);d[0]=this.screenSlices[i].leftTopMM[0]+h*this.screenSlices[i].fovMM[0],d[1]=this.screenSlices[i].leftTopMM[1]+c*this.screenSlices[i].fovMM[1];const m=this.screenSlices[i].AxyzMxy;d[2]=m[2]+m[4]*(d[1]-m[1])-m[3]*(d[0]-m[0]),1===o&&(d=Wi(d,[0,2,1])),2===o&&(d=Wi(d,[2,0,1]));const u=this.mm2frac(d);return s&&(u[0]<0||u[0]>1||u[1]<0||u[1]>1||u[2]<0||u[2]>1)?n:u}canvasPos2frac(t){for(let e=0;e<this.screenSlices.length;e++){const i=this.screenXY2TextureFrac(t[0],t[1],e);if(i[0]>=0)return i}return[-1,-1,-1]}frac2canvasPosWithTile(t,e){const i=this.frac2mm(t);let s={index:-1,distance:1/0};for(let n=0;n<this.screenSlices.length;n++){const t=this.screenSlices[n].axCorSag;if(t>2)continue;if(this.screenSlices[n].AxyzMxy.length<4)continue;if(void 0!==e&&t!==e)continue;let o=r.fA(i[0],i[1],i[2]);1===t&&(o=Wi(o,[0,2,1])),2===t&&(o=Wi(o,[1,2,0]));const a=this.screenSlices[n].AxyzMxy,l=a[2]+a[4]*(o[1]-a[1])-a[3]*(o[0]-a[0]),h=Math.abs(o[2]-l),c=3===this.opts.sliceType?1:.1;if(h<s.distance&&(s={index:n,distance:h}),h<=c){const t=(o[0]-this.screenSlices[n].leftTopMM[0])/this.screenSlices[n].fovMM[0],e=(o[1]-this.screenSlices[n].leftTopMM[1])/this.screenSlices[n].fovMM[1];if(t>=0&&t<=1&&e>=0&&e<=1){const i=this.screenSlices[n].leftTopWidthHeight.slice();let s=!1;i[2]<0&&(s=!0,i[0]+=i[2],i[2]=-i[2]);let r=t;s&&(r=1-t);const o=1-e;return{pos:[i[0]+r*i[2],i[1]+o*i[3]],tileIndex:n}}}}return null}frac2canvasPos(t){const e=this.frac2mm(t);let i={index:-1,distance:1/0};for(let s=0;s<this.screenSlices.length;s++){const t=this.screenSlices[s].axCorSag;if(t>2)continue;if(this.screenSlices[s].AxyzMxy.length<4)continue;let n=r.fA(e[0],e[1],e[2]);1===t&&(n=Wi(n,[0,2,1])),2===t&&(n=Wi(n,[1,2,0]));const o=this.screenSlices[s].AxyzMxy,a=o[2]+o[4]*(n[1]-o[1])-o[3]*(n[0]-o[0]),l=Math.abs(n[2]-a),h=3===this.opts.sliceType?1:.1;if(l<i.distance&&(i={index:s,distance:l}),l<=h){const t=(n[0]-this.screenSlices[s].leftTopMM[0])/this.screenSlices[s].fovMM[0],e=(n[1]-this.screenSlices[s].leftTopMM[1])/this.screenSlices[s].fovMM[1];if(t>=0&&t<=1&&e>=0&&e<=1){const i=this.screenSlices[s].leftTopWidthHeight.slice();let r=!1;i[2]<0&&(r=!0,i[0]+=i[2],i[2]=-i[2]);let n=t;r&&(n=1-t);const o=1-e;return[i[0]+n*i[2],i[1]+o*i[3]]}}}if(i.index>=0&&i.distance<2){const t=i.index,s=this.screenSlices[t].axCorSag;let n=r.fA(e[0],e[1],e[2]);1===s&&(n=Wi(n,[0,2,1])),2===s&&(n=Wi(n,[1,2,0]));const o=this.screenSlices[t].AxyzMxy;n[2]=o[2]+o[4]*(n[1]-o[1])-o[3]*(n[0]-o[0]);const a=(n[0]-this.screenSlices[t].leftTopMM[0])/this.screenSlices[t].fovMM[0],l=(n[1]-this.screenSlices[t].leftTopMM[1])/this.screenSlices[t].fovMM[1];if(a>=-.1&&a<=1.1&&l>=-.1&&l<=1.1){const e=Math.max(0,Math.min(1,a)),i=Math.max(0,Math.min(1,l)),s=this.screenSlices[t].leftTopWidthHeight.slice();let r=!1;s[2]<0&&(r=!0,s[0]+=s[2],s[2]=-s[2]);let n=e;r&&(n=1-e);const o=1-i;return[s[0]+n*s[2],s[1]+o*s[3]]}}return null}scaleSlice(t,e,i,s){void 0===i&&(i=[0,0]),void 0===s&&(s=[0,0]);const r=0===s[0]?this.effectiveCanvasWidth()-i[0]:s[0]-i[0],n=0===s[1]?this.effectiveCanvasHeight()-i[1]:s[1]-i[1];let o=r/t;e*o>n&&(o=n/e);const a=t*o,l=e*o;return[.5*(r-a),.5*(n-l),a,l,o]}drawThumbnail(){if(!this.bmpShader)throw new Error("bmpShader undefined");this.bmpShader.use(this.gl);const[t,e,i,s]=this.getBoundsRegion();this.gl.uniform2f(this.bmpShader.uniforms.canvasWidthHeight,i,s);let r=s,n=s*this.bmpTextureWH;n>i&&(r=i/this.bmpTextureWH,n=i);const o=t+(i-n)/2,a=e+(s-r)/2;this.gl.uniform4f(this.bmpShader.uniforms.leftTopWidthHeight,o,a,n,r),this.gl.bindVertexArray(this.genericVAO),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawLine(t,e,i){if(void 0===e&&(e=1),void 0===i&&(i=[1,0,0,-1]),this.gl.bindVertexArray(this.genericVAO),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl),i[3]<0&&(i=this.opts.crosshairColor),this.gl.uniform4fv(this.lineShader.uniforms.lineColor,i),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,e),this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,t),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}draw3DLine(t,e,i,s){if(void 0===i&&(i=1),void 0===s&&(s=[1,0,0,-1]),this.gl.bindVertexArray(this.genericVAO),!this.line3DShader)throw new Error("line3DShader undefined");this.line3DShader.use(this.gl),s[3]<0&&(s=this.opts.crosshairColor),this.gl.uniform4fv(this.line3DShader.uniforms.lineColor,s),this.gl.uniform2fv(this.line3DShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.line3DShader.uniforms.thickness,i),this.gl.uniform2fv(this.line3DShader.uniforms.startXY,t),this.gl.uniform3fv(this.line3DShader.uniforms.endXYZ,e),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.bindVertexArray(this.unusedVAO)}drawDottedLine(t,e,i){if(void 0===e&&(e=1),void 0===i&&(i=[1,0,0,-1]),this.gl.bindVertexArray(this.genericVAO),!this.lineShader)throw new Error("lineShader undefined");this.lineShader.use(this.gl);const s=i[3]<0?[...this.opts.crosshairColor]:[...i];s[3]=.3;const r=o.fA(t[2]-t[0],t[3]-t[1]),n=o.Bw(r);o.S8(r,r);const a=1*this.fontPx;o.hs(r,r,a/2);const l=o.Bw(r);let h=Math.floor(n/l);n%l&&h++;const c=[t[0],t[1]];this.gl.uniform4fv(this.lineShader.uniforms.lineColor,s),this.gl.uniform2fv(this.lineShader.uniforms.canvasWidthHeight,[this.gl.canvas.width,this.gl.canvas.height]),this.gl.uniform1f(this.lineShader.uniforms.thickness,e);for(let o=0;o<h-1;o++){if(o%2){c[0]+=r[0],c[1]+=r[1];continue}const t=[c[0],c[1],c[0]+r[0],c[1]+r[1]];this.gl.uniform4fv(this.lineShader.uniforms.startXYendXY,t),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),c[0]+=r[0],c[1]+=r[1]}this.gl.bindVertexArray(this.unusedVAO)}drawGraphLine(t,e,i){void 0===e&&(e=[1,0,0,.5]),void 0===i&&(i=2),this.drawLine(t,i,e)}drawCrossLinesMM(t,e,i,s,r){if(t<0||this.screenSlices.length<=t)return;const n=this.screenSlices[t];let a=n.sliceFrac;a===1/0&&U.debug("Rendering approximate cross lines in world view mode"),a===1/0&&(a=.5);let l=s.slice(),h=r.slice();const c=Math.max(1,this.opts.crosshairWidth);function d(t){const e=o.fA(0,0);return e[0]=n.leftTopWidthHeight[0]+(t[0]-n.leftTopMM[0])/n.fovMM[0]*n.leftTopWidthHeight[2],e[1]=n.leftTopWidthHeight[1]+n.leftTopWidthHeight[3]-(t[1]-n.leftTopMM[1])/n.fovMM[1]*n.leftTopWidthHeight[3],e}if(1===e&&(l=i.slice()),2===e&&(l=i.slice(),h=s.slice()),l.length>0&&0===e){const t=a,e=1;for(let i=0;i<l.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=l[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([0,r,t]);n=Wi(n,[0,1,2]);let o=this.frac2mm([1,r,t]);o=Wi(o,[0,1,2]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}if(l.length>0&&1===e){const t=a,e=2;for(let i=0;i<l.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=l[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([0,t,r]);n=Wi(n,[0,2,1]);let o=this.frac2mm([1,t,r]);o=Wi(o,[0,2,1]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}if(l.length>0&&2===e){const t=a,e=2;for(let i=0;i<l.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=l[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([t,0,r]);n=Wi(n,[1,2,0]);let o=this.frac2mm([t,1,r]);o=Wi(o,[1,2,0]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}if(h.length>0&&0===e){const t=a,e=0;for(let i=0;i<h.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=h[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([r,0,t]);n=Wi(n,[0,1,2]);let o=this.frac2mm([r,1,t]);o=Wi(o,[0,1,2]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}if(h.length>0&&1===e){const t=a,e=0;for(let i=0;i<h.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=h[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([r,t,0]);n=Wi(n,[0,2,1]);let o=this.frac2mm([r,t,1]);o=Wi(o,[0,2,1]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}if(h.length>0&&2===e){const t=a,e=1;for(let i=0;i<h.length;i++){const s=this.frac2mm([.5,.5,.5]);s[e]=h[i];let r=this.mm2frac(s);r=r[e];let n=this.frac2mm([t,r,0]);n=Wi(n,[1,2,0]);let o=this.frac2mm([t,r,1]);o=Wi(o,[1,2,0]),n=d(n),o=d(o),this.drawLine([n[0],n[1],o[0],o[1]],c)}}}drawCrossLines(t,e,i,s,r){if(t<0||this.screenSlices.length<=t)return;if(this.opts.isSliceMM)return this.drawCrossLinesMM(t,e,i,s,r);if(this.screenSlices[t].sliceFrac===1/0)return this.drawCrossLinesMM(t,e,i,s,r);const n=this.screenSlices[t];let o=s.slice(),a=r.slice();if(1===e&&(o=i.slice()),2===e&&(o=i.slice(),a=s.slice()),o.length>0){const t=n.leftTopWidthHeight.slice();let i=2;0===e&&(i=1);const s=this.frac2mm([.5,.5,.5]);for(let e=0;e<o.length;e++){s[i]=o[e];const r=this.mm2frac(s);this.drawRect([t[0],t[1]+t[3]-r[i]*t[3],t[2],1])}}if(a.length>0){const t=n.leftTopWidthHeight.slice(),i=n.fovMM[0]<0;let s=0;2===e&&(s=1);const r=this.frac2mm([.5,.5,.5]);for(let e=0;e<a.length;e++){r[s]=a[e];const n=this.mm2frac(r);i?this.drawRect([t[0]+(t[2]-n[s]*t[2]),t[1],1,t[3]]):this.drawRect([t[0]+n[s]*t[2],t[1],1,t[3]])}}}drawMosaic(t){this.screenSlices=[];const[e,i,s,r]=this.getBoundsRegion(),n=this.screenFieldOfViewMM(0,!0),o=this.screenFieldOfViewMM(0),a=[],l=[],h=[],c=(t=t.replaceAll(";"," ;").trim()).split(/\s+/);let d=1;const m=this.fontPx;let u=0,f=0,g=0;this.volumes[0]?.dims||(g=Math.ceil(.3*this.opts.tileMargin));for(let A=0;A<2;A++){let t=!1,p=!1,v=0,x=0,w=0,b=0,y=!1,C=0,M=0,D=0,I=0;for(let s=0;s<c.length;s++){const r=c[s];if(r.includes("X")){p=!0;continue}if(r.includes("L")){y=!r.includes("-");continue}if(r.includes("H")){s++,M=Math.abs(Math.max(0,Math.min(1,parseFloat(c[s]))));continue}if(r.includes("V")){s++;continue}if(r.includes("A")){C=0;continue}if(r.includes("C")){C=1;continue}if(r.includes("S")){C=2;continue}if(r.includes("R")){t=!0;continue}if(r.includes(";")){w+=v,b=Math.max(b,x+D),v=0,x=0,D=0;continue}I=D,M>0&&!t&&(I=Math.round(I*(1-M))),x+=I,I=0;const T=parseFloat(r);if(isNaN(T))continue;let S=0,F=o;if(t&&(F=n),I=2===C?F[1]:F[0],S=0===C?F[1]:F[2],0===A)t||(0===C&&a.push(T),1===C&&l.push(T),2===C&&h.push(T));else{const s=[e+u+d*x,i+f+d*w,d*I,d*S];if(this.fontPx=y?m:0,t){let t=T<0?-1/0:1/0;Object.is(T,-0)&&(t=-1/0),this.draw2D(s,C,t)}else this.draw2D(s,C,T);p&&this.drawCrossLines(this.screenSlices.length-1,C,a,l,h),t=!1,p=!1}D=I,x+=g,v=Math.max(v,S)}if(w+=v,b=Math.max(b,x+D),b<=0||w<=0)break;const T=(s-2*this.opts.tileMargin-g)/b,S=(r-2*this.opts.tileMargin)/w;d=Math.min(T,S),this.opts.centerMosaic?(u=Math.floor(.5*(s-b*d)),f=Math.floor(.5*(r-w*d))):(u=this.opts.tileMargin,f=this.opts.tileMargin)}this.fontPx=m}calculateWidthHeight(t,e,i,s){let r,n;switch(t){case 0:r=e[0],n=e[1];break;case 1:r=e[0],n=e[2];break;case 2:r=e[1],n=e[2];break;default:return[i,s]}const o=r/n;let a,l;return o>i/s?(a=i,l=i/o):(l=s,a=s*o),[a,l]}getBoundsRegionCSS(){const t=this.gl.canvas.getBoundingClientRect();if(!this.opts.bounds)return[0,0,t.width,t.height];const[[e,i],[s,r]]=this.opts.bounds,n=Math.round(e*t.width),o=Math.round((s-e)*t.width),a=Math.round(i*t.height),l=Math.round(r*t.height),h=l-a;return[n,t.height-l,o,h]}eventInBounds(t){const e=this.gl.canvas.getBoundingClientRect();let i,s;if(t instanceof MouseEvent)i=t.clientX,s=t.clientY;else if(t instanceof TouchEvent){const e=t.touches[0]??t.changedTouches[0];if(!e)return!1;i=e.clientX,s=e.clientY}else i=t.clientX,s=t.clientY;const r=i-e.left,n=s-e.top,[o,a,l,h]=this.getBoundsRegionCSS();return r>=o&&r<=o+l&&n>=a&&n<=a+h}cursorInBounds(){if(this.mousePos[0]<0||this.mousePos[1]<0)return!1;const[t,e,i,s]=this.getBoundsRegion(),[r,n]=this.mousePos;return r>=t&&r<=t+i&&n>=e&&n<=e+s}getBoundsRegion(){const t=this.gl,e=this.uiData?.dpr||window.devicePixelRatio||1,i=t.canvas,s=i.clientWidth,r=i.clientHeight;if(!this.opts.bounds)return[0,0,t.canvas.width,t.canvas.height];const[[n,o],[a,l]]=this.opts.bounds,h=Math.floor(n*s*e),c=Math.ceil((a-n)*s*e);let d=Math.floor((1-l)*r*e),m=Math.ceil((l-o)*r*e);return d<0&&(m+=d,d=0),d+m>t.canvas.height&&(m=t.canvas.height-d),[h,d,c,m]}inBounds(t,e){const[i,s,r,n]=this.getBoundsRegion(),o=t*this.uiData.dpr,a=this.gl.canvas.height-e*this.uiData.dpr;return o>=i&&o<=i+r&&a>=s&&a<=s+n}bindTextures(){this.gl.activeTexture(Hi),this.gl.bindTexture(this.gl.TEXTURE_3D,this.volumeTexture),this.gl.activeTexture(Zi),this.gl.bindTexture(this.gl.TEXTURE_3D,this.overlayTexture),this.gl.activeTexture($i),this.gl.bindTexture(this.gl.TEXTURE_3D,this.paqdTexture),this.gl.activeTexture(33987),this.gl.bindTexture(this.gl.TEXTURE_2D,this.fontTexture),this.gl.activeTexture(qi),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colormapTexture),this.gl.activeTexture(ji),this.gl.bindTexture(this.gl.TEXTURE_2D,this.matCapTexture),this.gl.activeTexture(Ji),this.gl.bindTexture(this.gl.TEXTURE_2D,this.gradientTexture)}clearBounds(t,e){void 0===t&&(t=this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT);const i=this.gl,[s,r,n,o]=e??this.getBoundsRegion(),a=i.canvas.height-r-o;t&i.DEPTH_BUFFER_BIT&&i.clearDepth(1),i.enable(i.SCISSOR_TEST),i.scissor(s,a,n,o),t&i.COLOR_BUFFER_BIT&&i.clearColor(this.opts.backColor[0],this.opts.backColor[1],this.opts.backColor[2],this.opts.backColor[3]),i.clear(t),i.disable(i.SCISSOR_TEST)}drawBoundsBorder(){if(!this.opts.showBoundsBorder)return;const[t,e,i,s]=this.getBoundsRegion();this.drawBoundsBox([t,e,i,s],this.opts.boundsBorderColor,this.opts.selectionBoxLineThickness)}drawSceneCore(){if(!this.initialized)return;this.colorbarHeight=0;const[t,e,i,s]=this.getBoundsRegion();if(this.gl.viewport(t,e,i,s),this.clearBounds(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.bindTextures(),this.bmpTexture&&this.thumbnailVisible)return void this.drawThumbnail();let r="";if(0===this.volumes.length||void 0===this.volumes[0].dims)return this.meshes.length>0?this.sliceMosaicString.length>0?(this.opts.isColorbar&&this.reserveColorbarPanel(),this.drawMosaic(this.sliceMosaicString),void(this.opts.isColorbar&&this.drawColorbar())):(this.screenSlices=[],this.draw3D([t,e,i,s]),void(this.opts.isColorbar&&this.drawColorbar())):void this.drawLoadingText(this.opts.loadingText);if(this.uiData.isDragging&&this.scene.clipPlaneDepthAziElev[0]<1.8&&this.inRenderTile(this.uiData.dragStart[0],this.uiData.dragStart[1])>=0){const t=this.uiData.dragStart[0]-this.uiData.dragEnd[0],e=this.uiData.dragStart[1]-this.uiData.dragEnd[1],i=this.uiData.dragClipPlaneStartDepthAziElev.slice();if(i[1]-=t,i[1]=i[1]%360,i[2]+=e,i[1]!==this.scene.clipPlaneDepthAziElev[1]||i[2]!==this.scene.clipPlaneDepthAziElev[2])return this.scene.clipPlaneDepthAziElev=i,this.setClipPlane(this.scene.clipPlaneDepthAziElev)}if(this.sliceMosaicString.length<1&&4===this.opts.sliceType)return this.opts.isColorbar&&this.reserveColorbarPanel(),this.screenSlices=[],this.draw3D(),void(this.opts.isColorbar&&this.drawColorbar());this.opts.isColorbar&&this.reserveColorbarPanel();const n=this.getMaxVols(),o=3===this.opts.sliceType&&n>1&&this.graph.autoSizeMultiplanar&&this.graph.opacity>0;if(this.sliceMosaicString.length>0)this.drawMosaic(this.sliceMosaicString);else{const r=[0,0];let a=!1;if(this.screenSlices=[],this.customLayout&&this.customLayout.length>0){this.screenSlices=[];const{volScale:r}=this.sliceScale();for(const n of this.customLayout){const{sliceType:o,position:a,sliceMM:l}=n,h=[t+a[0]*i,e+a[1]*s,a[2]*i,a[3]*s];if(h[0]+h[2]>t+i&&(U.warn("adjusting slice width because it would have been clipped"),h[2]=t+i-h[0]),h[1]+h[3]>e+s&&(U.warn("adjusting slice height because it would have been clipped"),h[3]=e+s-h[1]),4===o)this.draw3D(h);else{const t=this.calculateWidthHeight(o,r,h[2],h[3]);this.draw2D(h,o,l??NaN,t)}}}else if(0===this.opts.sliceType||1===this.opts.sliceType||2===this.opts.sliceType){const{volScale:r}=this.sliceScale(),n=[t,e,i,s],o=this.calculateWidthHeight(this.opts.sliceType,r,n[2],n[3]);this.draw2D([0,0,0,0],this.opts.sliceType,NaN,o)}else{let t=function(t,e){return[(t-1)*h+t*c,(e-1)*h+e*c]},e=!1;this.opts.multiplanarForceRender?(e=!0,this.opts.multiplanarForceRender?this.opts.multiplanarShowRender=1:this.opts.multiplanarShowRender=2,delete this.opts.multiplanarForceRender):1===this.opts.multiplanarShowRender&&(e=!0);const i=isFinite(this.drawPenLocation[0])&&this.opts.drawingEnabled,{volScale:s}=this.sliceScale(),l=s.slice();this.opts.multiplanarEqualSize&&(s[0]=1,s[1]=1,s[2]=1),"number"!=typeof this.opts.multiplanarPadPixels&&U.debug("multiplanarPadPixels must be numeric");const h=parseFloat(`${this.opts.multiplanarPadPixels}`)*this.uiData.dpr;let c=this.opts.tileMargin*this.uiData.dpr;c<0&&(c=2*(2+Math.ceil(this.fontPx)));const[d,m,u,f]=this.getBoundsRegion();let g=[this.effectiveCanvasWidth(),this.effectiveCanvasHeight()];this.opts.heroImageFraction>0&&this.opts.heroImageFraction<1&&(e=!1,a=!0,g[0]>g[1]&&3!==this.opts.multiplanarLayout?r[0]=g[0]*this.opts.heroImageFraction:r[1]=g[1]*this.opts.heroImageFraction,g=[g[0]-r[0],g[1]-r[1]]);const A=this.scaleSlice(s[0]+s[1],s[1]+s[2],t(2,2),g),p=Math.max(Math.max(s[1],s[2]),s[0]),v=this.scaleSlice(s[0]+s[0]+s[1],Math.max(s[1],s[2]),t(3,1),g),x=this.scaleSlice(s[0]+s[0]+s[1]+p,Math.max(s[1],s[2]),t(4,1),g),w=this.scaleSlice(p,s[1]+s[2]+s[2],t(1,3),g),b=this.scaleSlice(p,s[1]+s[2]+s[2]+p,t(1,4),g);let y=!i&&(n<2||!o),C=!1,M=!1,D=!1;1===this.opts.multiplanarLayout?C=!0:2===this.opts.multiplanarLayout?M=!0:3===this.opts.multiplanarLayout?D=!0:w[4]>v[4]&&w[4]>A[4]?C=!0:v[4]>A[4]?D=!0:M=!0;let I=A;if(C?(I=w,!a&&(e||2===this.opts.multiplanarShowRender&&b[4]>=w[4])?I=b:y=!1):D&&(I=v,!a&&(e||2===this.opts.multiplanarShowRender&&x[4]>=v[4])?I=x:y=!1),a){const t=0===r[0]?u:r[0],e=0===r[1]?f:r[1];if(0===this.opts?.heroSliceType||1===this.opts?.heroSliceType||2===this.opts?.heroSliceType)this.draw2D([d,m,t,e],this.opts.heroSliceType,NaN,[1/0,1/0]);else{const i=I.slice();t===u&&(i[0]=0),this.draw3D([d+i[0],m,t,e])}I[0]+=r[0],I[1]+=r[1],y=!1}const T=s[0]*I[4]+c,S=s[1]*I[4]+c,F=s[2]*I[4]+c,E=l[0]*I[4],B=l[1]*I[4],V=l[2]*I[4];if(C){if(this.draw2D([d+I[0],m+I[1],T,S],0,NaN,[E,B]),this.draw2D([d+I[0],m+I[1]+S+h,T,F],1,NaN,[E,V]),this.draw2D([d+I[0],m+I[1]+S+h+F+h,S,F],2,NaN,[B,V]),y){const t=p*I[4];this.draw3D([d+I[0],m+I[1]+S+F+F+3*h,t,t])}}else if(D){if(this.draw2D([d+I[0],m+I[1],T,S],0,NaN,[E,B]),this.draw2D([d+I[0]+T+h,m+I[1],T,F],1,NaN,[E,V]),this.draw2D([d+I[0]+T+T+2*h,m+I[1],S,F],2,NaN,[B,V]),y){const t=p*I[4];this.draw3D([d+I[0]+T+T+S+3*h,m+I[1],t,t])}}else M&&(e||(y=!1),2===this.opts.multiplanarShowRender&&(y=!0),a&&(y=!1),this.draw2D([d+I[0],m+I[1]+F+h,T,S],0,NaN,[E,B]),this.draw2D([d+I[0],m+I[1],T,F],1,NaN,[E,V]),this.draw2D([d+I[0]+T+h,m+I[1],S,F],2,NaN,[B,V]),y&&this.draw3D([d+I[0]+T+h,m+I[1]+F+h,S,S]))}}if(this.opts.isRuler&&this.drawRuler(),this.opts.isColorbar&&this.drawColorbar(),o&&this.drawGraph(),this.uiData.isDragging){if(this.uiData.mouseButtonCenterDown)return void this.dragForCenterButton([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(4===this.getCurrentDragMode())return void this.dragForSlicer3D([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(3===this.getCurrentDragMode())return void this.dragForPanZoom([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]);if(this.inRenderTile(this.uiData.dragStart[0],this.uiData.dragStart[1])>=0)return;2===this.getCurrentDragMode()&&this.drawMeasurementTool([this.uiData.dragStart[0],this.uiData.dragStart[1],this.uiData.dragEnd[0],this.uiData.dragEnd[1]]),7===this.getCurrentDragMode()&&this.drawAngleMeasurementTool();const t=this.getCurrentDragMode();if(1===t||6===t){const t=Math.abs(this.uiData.dragStart[0]-this.uiData.dragEnd[0]),e=Math.abs(this.uiData.dragStart[1]-this.uiData.dragEnd[1]);this.drawSelectionBox([Math.min(this.uiData.dragStart[0],this.uiData.dragEnd[0]),Math.min(this.uiData.dragStart[1],this.uiData.dragEnd[1]),t,e])}}for(const l of this.document.completedMeasurements)if(this.shouldDrawOnCurrentSlice(l.sliceIndex,l.sliceType,l.slicePosition)){const t=this.mm2frac(l.startMM),e=this.mm2frac(l.endMM),i=this.frac2canvasPosWithTile(t,l.sliceType),s=this.frac2canvasPosWithTile(e,l.sliceType);i&&s&&i.tileIndex===s.tileIndex&&this.drawMeasurementTool([i.pos[0],i.pos[1],s.pos[0],s.pos[1]])}for(let l=0;l<this.document.completedAngles.length;l++){const t=this.document.completedAngles[l];if(this.shouldDrawOnCurrentSlice(t.sliceIndex,t.sliceType,t.slicePosition)){const e=this.mm2frac(t.firstLineMM.start),i=this.mm2frac(t.firstLineMM.end),s=this.mm2frac(t.secondLineMM.start),r=this.mm2frac(t.secondLineMM.end),n=this.frac2canvasPosWithTile(e,t.sliceType),o=this.frac2canvasPosWithTile(i,t.sliceType),a=this.frac2canvasPosWithTile(s,t.sliceType),l=this.frac2canvasPosWithTile(r,t.sliceType);if(n&&o&&a&&l&&n.tileIndex===o.tileIndex&&n.tileIndex===a.tileIndex&&n.tileIndex===l.tileIndex){this.drawMeasurementTool([n.pos[0],n.pos[1],o.pos[0],o.pos[1]],!1),this.drawMeasurementTool([a.pos[0],a.pos[1],l.pos[0],l.pos[1]],!1);const e={firstLine:[n.pos[0],n.pos[1],o.pos[0],o.pos[1]],secondLine:[a.pos[0],a.pos[1],l.pos[0],l.pos[1]],sliceIndex:t.sliceIndex,sliceType:t.sliceType,slicePosition:t.slicePosition};this.drawAngleTextForAngle(e)}}}const a=this.frac2mm([this.scene.crosshairPos[0],this.scene.crosshairPos[1],this.scene.crosshairPos[2]]);return r=a[0].toFixed(2)+"\xd7"+a[1].toFixed(2)+"\xd7"+a[2].toFixed(2),this.readyForSync=!0,this.sync(),this.drawAnchoredLabels(),this.drawBoundsBorder(),r}drawScene(){if(this.isBusy)return void(this.needsRefresh=!0);this.isBusy=!1,this.needsRefresh=!1;let t=this.drawSceneCore();return null!==this._gl&&this.gl.finish(),this.needsRefresh&&(t=this.drawScene()),t}get gl(){if(!this._gl)throw new Error("unable to get WebGL context. Maybe the browser doesn't support WebGL2.");return this._gl}set gl(t){this._gl=t}findDrawingBoundarySlices(t){if(!this.back||!this.back.dims||!this.drawBitmap)return null;const e={dimX:this.back.dims[1],dimY:this.back.dims[2],dimZ:this.back.dims[3]};return function(t,e,i){const{dimX:s,dimY:r,dimZ:n}=i;let o;if(0===t)o=n;else if(1===t)o=r;else{if(2!==t)return null;o=s}let a=-1,l=-1;for(let h=0;h<o;h++){let i=!1;if(0===t){const t=h*s*r;for(let n=0;n<s*r;n++)if(e[t+n]>0){i=!0;break}}else if(1===t)for(let t=0;t<n;t++){for(let n=0;n<s;n++)if(e[n+h*s+t*s*r]>0){i=!0;break}if(i)break}else if(2===t)for(let t=0;t<n;t++){for(let n=0;n<r;n++)if(e[h+n*s+t*s*r]>0){i=!0;break}if(i)break}i&&(-1===a&&(a=h),l=h)}return-1===a||-1===l?null:{first:a,last:l}}(t,this.drawBitmap,e)}interpolateMaskSlices(t,e,i){if(void 0===i&&(i={}),!this.back||!this.back.dims||!this.drawBitmap)throw new Error("Background image and drawing bitmap must be loaded");const s={dimX:this.back.dims[1],dimY:this.back.dims[2],dimZ:this.back.dims[3]},r=this.back.img,n=this.back.global_max;!function(t,e,i,s,r,n,o,a){const{dimX:l,dimY:h,dimZ:c}=e,d=o.sliceType??0;let m,u,f;if(0===d)m=l,u=h,f=c-1;else if(1===d)m=l,u=c,f=h-1;else{if(2!==d)throw new Error("Invalid slice type. Must be AXIAL, CORONAL, or SAGITTAL");m=h,u=c,f=l-1}const g={intensityWeight:o.intensityWeight??.7,binaryThreshold:o.binaryThreshold??.375,intensitySigma:o.intensitySigma??.1,applySmoothingToSlices:o.applySmoothingToSlices??!0,useIntensityGuided:o.useIntensityGuided??!0};if(void 0!==r&&void 0!==n){if(r>=n)throw new Error("Low slice index must be less than high slice index");if(r<0||n>f)throw new Error(`Slice indices out of bounds [0, ${f}]`)}const A=new Map;for(let p=0;p<=f;p++){const i=qe(p,d,t,e);for(let t=0;t<i.length;t++){const e=i[t];if(e>0)if(A.has(e)){const t=A.get(e);t.min=Math.min(t.min,p),t.max=Math.max(t.max,p)}else A.set(e,{min:p,max:p})}}for(const[p,v]of A){const o=void 0!==r?Math.max(r,v.min):v.min,a=void 0!==n?Math.min(n,v.max):v.max;if(o>=a||a-o<2)continue;const l=qe(o,d,t,e),h=qe(a,d,t,e),c=new Float32Array(l.length),f=new Float32Array(h.length);for(let t=0;t<l.length;t++)c[t]=l[t]===p?1:0,f[t]=h[t]===p?1:0;g.applySmoothingToSlices&&(Je(c,m,u),Je(f,m,u));for(let r=o+1;r<a;r++){const n=new Float32Array(m*u);g.useIntensityGuided&&i?ti(c,f,r,o,a,n,g,Ze(o,d,i,e,s),Ze(a,d,i,e,s),Ze(r,d,i,e,s)):$e(c,f,r,o,a,n),je(n,r,d,t,e,g.binaryThreshold,p)}}a()}(this.drawBitmap,s,r,n,t,e,i,(()=>this.refreshDrawing(!0)))}};zi=new WeakMap}}]);