"use strict";(self.webpackChunk_niivue_docs=self.webpackChunk_niivue_docs||[]).push([[426],{213:(e,i,t)=>{t.d(i,{A:()=>s});const s=t.p+"assets/images/overlay-92d965bb02fa6834e39d35c6a536de93.png"},1184:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var s=t(4041);const n={},r=s.createContext(n);function a(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:i},e.children)}},2077:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"webgl","title":"WebGL2","description":"Introduction","source":"@site/docs/webgl.mdx","sourceDirName":".","slug":"/webgl","permalink":"/docs/webgl","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"WebGL2","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Plugins","permalink":"/docs/plugins"},"next":{"title":"Fonts","permalink":"/docs/fonts"}}');var n=t(1085),r=t(1184);const a={title:"WebGL2",sidebar_position:10},o=void 0,l={},h=[{value:"Introduction",id:"introduction",level:2},{value:"Strengths and Weaknesses",id:"strengths-and-weaknesses",level:5},{value:"Textures",id:"textures",level:5},{value:"Color Schemes",id:"color-schemes",level:5},{value:"Overlays",id:"overlays",level:5},{value:"Future Directions",id:"future-directions",level:5},{value:"Links",id:"links",level:5}];function d(e){const i={a:"a",code:"code",h2:"h2",h5:"h5",img:"img",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsxs)(i.p,{children:["This project requires WebGL2. This specification was ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/WebGL",children:"finalized in January 2017"}),". It is supported by ",(0,n.jsx)(i.a,{href:"https://caniuse.com/webgl2",children:"all popular modern browsers"}),". NiiVue exploits WebGL2 features that ",(0,n.jsx)(i.a,{href:"https://webgl2fundamentals.org/webgl/lessons/webgl2-whats-new.html",children:"are not available in WebGL1"}),". Specifically, the images are represented using non-Power of two 3D textures. The shaders used by WebGL2 are written using the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/OpenGL_ES",children:"OpenGL ES 3.0"})," version of the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/OpenGL_Shading_Language",children:"OpenGL Shading Language (GLSL)"}),". WebGL2 added additional texture formats that provide native support for most ",(0,n.jsx)(i.a,{href:"https://brainder.org/2012/09/23/the-nifti-file-format/",children:"NIfTI format data types"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["NiiVue uses WebGL not only to display images but also to accelerate many of the functions. For example, the ",(0,n.jsx)(i.a,{href:"http://pieper.github.io/sites/glimp/growcut.html",children:"grow cut"})," drawings and the image reslicing described below."]}),"\n",(0,n.jsx)(i.h5,{id:"strengths-and-weaknesses",children:"Strengths and Weaknesses"}),"\n",(0,n.jsxs)(i.p,{children:["WebGL is a modern shader-based language. It lacks the fixed function pipeline, quad primitives and helper functions of legacy OpenGL. The benefit of this approach is that it forces the developer to use efficient methods that map closely to modern hardware design. However, it does have a steep learning curve. The minimal design of WebGL allows ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/ANGLE",children:"ANGLE"})," to map it directly to the most efficient graphics library available (METAL, Vulkan, DirectX or Modern OpenGL). However, as it was designed as the least common denominator between these competing libraries, it does lack some useful features like geometry shaders. Therefore, one must adopt alternative approaches to implement features such as ",(0,n.jsx)(i.a,{href:"https://github.com/niivue/niivue/issues/458",children:"wireframes and illuminated streamlines"}),". It also lacks ",(0,n.jsx)(i.a,{href:"https://github.com/niivue/niivue/issues/447",children:"clip planes"})," and the ",(0,n.jsx)(i.a,{href:"https://github.com/niivue/niivue/issues/345",children:"depth buffer is read only"}),"."]}),"\n",(0,n.jsx)(i.h5,{id:"textures",children:"Textures"}),"\n",(0,n.jsxs)(i.p,{children:["The term Textures refers to bitmap images that are stored on the graphics card. WebGL2 can support 1D, 2D, and 3D textures. The WebGL context can only have a limited number of textures active at one time (with the command ",(0,n.jsx)(i.code,{children:"activeTexture"})," deterimining which textures are available). A WebGL 2 context provides a minimum of ",(0,n.jsx)(i.a,{href:"https://webgl2fundamentals.org/webgl/lessons/webgl-cross-platform-issues.html#device-limits",children:"32 total loaded textures, with a fragment program able to access at least 16 concurrently"}),". You can think of these active textures as slots that are available for the shaders to access. NiiVue consistently uses the same slots for specific textures. While this is not required by WebGL, it simplifies the code (e.g. otherwise many calls to bind textures to specific slots of the style ",(0,n.jsx)(i.code,{children:"gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_3D, this.overlayTexture)"}),"). This means that each draw call does not need to explicitly set the active textures. Therefore, slots 0..7 should be considered reserved and not used for other functions. The code currently uses slots 8..15 transiently, so these could be easily used by other functions."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE0_BACK_VOL"}),": Background volume. This 3D scalar bitmap stores the voxel intensities of the background image."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE1_COLORMAPS"}),": Active colormaps. This 2D RGBA bitmap converts the scalar volume voxel intensities to RGBA values (e.g. Grayscale, Viridis). Note that each voxelwise layer can have two unique colormaps (for positive and negative values) and meshes can also have colormaps."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE2_OVERLAY_VOL"}),": Overlay volumes. This 3D RGBA bitmap stores the blended values of all loaded overlays."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE3_FONT"}),": Font. This is a 2D bitmap that stores the ",(0,n.jsx)(i.a,{href:"https://github.com/Chlumsky/msdfgen",children:"multi-channel signed distance field typeface"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE4_THUMBNAIL"}),": Thumbnail. This is a 2D bitmap that can be rapidly displayed. When a user clicks on the thumbnail the (large and slow) volumes and meshes will be loaded."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE5_MATCAP"}),": Matcap. This is a 2D bitmap used for exclusively by the matcap mesh shader (transiently enabled with the shader, so available for other functions). It is also used as a temporary 2D texture: this is used to blend multiple overlays into a single texture (TEXTURE2)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE6_GRADIENT"}),": Gradient texture for ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/shiny.volumes.html",children:"shiny volume rendering shaders"})," that use a gradient map for lighting."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE7_DRAW"}),": Drawing texture: this stores any active drawing, having the same resolution as TEXTURE0."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE8_GRADIENT_TEMP"}),": Transient texture used when generating TEXTURE6_GRADIENT."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE9_ORIENT"}),": Transient texture used when re-orienting voxel-based volumes to RAS orientation."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE10_BLEND"}),": Transient texture for blending different overlay volumes into the single TEXTURE2_OVERLAY_VOL."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE11_GC_BACK"}),": Transient texture used ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/draw2.html",children:"growcut"})," shader: background voxel intensity."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE12_GC_STRENGTH0"}),": Transient texture used ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/draw2.html",children:"growcut"})," shader: edge strength that ping-pongs between read and write."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE13_GC_STRENGTH1"}),": Transient texture used ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/draw2.html",children:"growcut"})," shader: edge strength that ping-pongs between write and read."]}),"\n",(0,n.jsxs)(i.li,{children:["`TEXTURE14_GC_LABEL0: Transient texture used ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/draw2.html",children:"growcut"})," shader: drawing color that ping-pongs between read and write."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"TEXTURE15_GC_LABEL1"}),": Transient texture used ",(0,n.jsx)(i.a,{href:"https://niivue.github.io/niivue/features/draw2.html",children:"growcut"})," shader: drawing color that ping-pongs between write and read."]}),"\n"]}),"\n",(0,n.jsx)(i.h5,{id:"color-schemes",children:"Color Schemes"}),"\n",(0,n.jsxs)(i.p,{children:["The user can choose different colormaps for displaying dark to bright voxels. In addition to grayscale, one can choose from the ",(0,n.jsx)(i.a,{href:"https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html",children:"viridis color palettes"})," (Cividis, Inferno, Plasma and Viridis) which are designed to be both salient and compatible with the most common forms of colorblindness. Since WebGL2 does not support 1D textures, these are codes as 2D bitmap textures (sampler2D, with a width of 256 pixels and a height of one pixel). This explains the GLSL definition ",(0,n.jsx)(i.code,{children:"sampler2D colormap"}),", with reading using ",(0,n.jsx)(i.code,{children:"texture(colormap, vec2(f, 0.5))"})," (where f is a fraction from 0..1, and 0.5 indicates sampling in the vertical middle of the bitmap)."]}),"\n",(0,n.jsx)(i.h5,{id:"overlays",children:"Overlays"}),"\n",(0,n.jsx)(i.p,{children:"Overlay images are resliced to match the resolution of the background image. Multiple overlays may be loaded, but they are all blended together to generate a single RGBA texture. This overcomes OpenGL limits on the number of active textures loaded, and improves the speed of rendering."}),"\n",(0,n.jsxs)(i.p,{children:["JavaScript is slower than natively compiled programs for many computations, ",(0,n.jsx)(i.a,{href:"http://openglinsights.com/discovering.html#WebGLforOpenGLDevelopers",children:"using WebGL can dramatically increase performance providing near native performance"}),". Therefore, while using the GPU instead of the CPU can accelerate performance regardless of language, the benefits are greater for JavaScript. Reslicing 3D volumes is compute intensive. Specifically, the GPU-based WebGL reslicing algorithm is also about an order of magnitude faster than the standard JavaScript code."]}),"\n",(0,n.jsxs)(i.p,{children:["The reslicing algorithm uses the ",(0,n.jsx)(i.a,{href:"https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glTexStorage3D.xhtml",children:"R8UI, R16I, R16UI and R32F"})," base formats for the ",(0,n.jsx)(i.a,{href:"https://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h",children:"NIfTI"})," ",(0,n.jsx)(i.code,{children:"DT_UINT8"}),", ",(0,n.jsx)(i.code,{children:"DT_INT16"}),", ",(0,n.jsx)(i.code,{children:"DT_UINT16"}),", and ",(0,n.jsx)(i.code,{children:"DT_FLOAT32"})," datatypes. One limitation of WebGL is that these texture formats are not ",(0,n.jsx)(i.a,{href:"https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html",children:"filterable"}),", meaning that only ",(0,n.jsx)(i.a,{href:"https://open.gl/textures",children:"nearest"})," interpolation is available. Therefore, overlays may appear blocky if there is not a one-to-one correspondence between the background image and an overlay. On the other hand, this is often desired for thresholded statistical maps (where many voxels are artificially zeroed). Another quirk of WebGL is that three shader programs are required to support unsigned integer, signed integer and floating point textures (using ",(0,n.jsx)(i.code,{children:"usampler3D"}),", ",(0,n.jsx)(i.code,{children:"isampler3D"})," and ",(0,n.jsx)(i.code,{children:"sampler3D"})," respectively)."]}),"\n",(0,n.jsxs)(i.p,{children:["The algorithm of the reslicing shader is shown in the Figure below. Each texture is a unit normalized cube (with the voxels accessed in the range 0..1 in the X,Y,Z dimensions, regardless of the number of voxels in the column, row and slice dimension). A 4x4 matrix provides the ",(0,n.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Transformation_matrix",children:"affine transformation"})," mapping the overlay (red in figure below) to the background image (black in image below). Since WebGL works with 2D framebuffers, the shader is run for every 2D slice of the background image's 3D volume. Therefore, this compute shader requires only the standard WebGL2 functions, without requiring the nascent ",(0,n.jsx)(i.a,{href:"https://www.khronos.org/registry/webgl/specs/latest/2.0-compute/",children:"compute extensions"}),"."]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Overlay image",src:t(213).A+"",width:"862",height:"862"})}),"\n",(0,n.jsx)(i.h5,{id:"future-directions",children:"Future Directions"}),"\n",(0,n.jsx)(i.p,{children:"This section describes methods that could enhance NiiVue visualization. Each will require development resources and the complexity impacts the simplicity and maintainability of NiiVue. Further, each impacts performance which may impact the experience on low-powered devices. Therefore, if implemented they would likely be optional effects."}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://github.com/niivue/niivue/issues/458",children:"Barycentric Effects"})," could allow wire-frame visualization. As WebGL lacks geometry shaders, implementing these effects is possible but has performance implications."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://github.com/niivue/niivue/issues/458",children:"Streamline Effects"})," can enhance the appearance of fibers. As WebGL does not include geometry shaders, ",(0,n.jsx)(i.a,{href:"https://www.researchgate.net/publication/319441378_A_Simple_and_Efficient_Cylinder_Imposter_Approach_to_Visualize_DTI_Fiber_Tracts",children:"imposters could be used"}),". This method has performance implications."]}),"\n",(0,n.jsxs)(i.li,{children:["Ambient Occlusion models how valleys (e.g. sulci) are more shaded from light than ridges (gyri). ",(0,n.jsx)(i.a,{href:"https://volview.netlify.app/",children:"VolView"})," provides ",(0,n.jsx)(i.a,{href:"https://github.com/Kitware/vtk-js/blob/dd45c408217e5d632de0ff98f45765abf92daba8/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl#L768",children:"one JavaScript approach"}),", ",(0,n.jsx)(i.a,{href:"https://ieeexplore.ieee.org/abstract/document/4840341",children:"Hernell"})," provides another approach. One method may be to use a blurred opacity map to simulate shading. All these approaches have performance implications."]}),"\n",(0,n.jsxs)(i.li,{children:["The desktop-based ",(0,n.jsx)(i.a,{href:"https://community.mrtrix.org/t/streamlines-tractography-output-problem/903/8",children:"mrtrix"})," and ",(0,n.jsx)(i.a,{href:"https://sites.google.com/a/labsolver.org/dsi-studio/Manual/odf-visualization",children:"dsi-studio"})," can display Orientation Distribution Functions that allow users to evaluate the quality of diffusion data. Developing similar functionality for the web would be useful. These methods have performance implications."]}),"\n"]}),"\n",(0,n.jsx)(i.h5,{id:"links",children:"Links"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://webglinsights.github.io/index.html",children:"WebGL Insights"})," is free and a terrific resource."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.a,{href:"https://webgl2fundamentals.org/",children:"WebGL2 Fundamentals"})," provides outstanding tutorials."]}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);