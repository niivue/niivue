<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>UIKit Components Test - Medical Imaging Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #ffffff;
            overflow: hidden;
        }
        
        #container {
            display: block;
            height: 100vh;
            padding-top: 40px;
        }
        
        #canvas-container {
            width: 100%;
            height: calc(100vh - 40px);
            position: relative;
            background: #000;
        }
        
        #gl1 {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Enhanced Canvas Styling - Main canvas only */
        #gl1 {
            display: block !important;
            border: 2px solid #333 !important;
            border-radius: 6px !important;
            background: #1a1a1a !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            transition: all 0.2s ease !important;
        }
        
        #gl1:hover {
            border-color: #4CAF50 !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 8px rgba(76, 175, 80, 0.3) !important;
        }
        
        #log-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 250px;
            background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 11px;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .log-entry {
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-info { 
            color: #4CAF50; 
            border-left-color: #4CAF50;
        }
        .log-warn { 
            color: #FF9800; 
            background: rgba(255, 152, 0, 0.1); 
            border-left-color: #FF9800;
        }
        .log-error { 
            color: #F44336; 
            background: rgba(244, 67, 54, 0.1); 
            border-left-color: #F44336;
        }
        .log-event { 
            color: #2196F3; 
            background: rgba(33, 150, 243, 0.1); 
            border-left-color: #2196F3;
        }
        
        #status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(90deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 13px;
            color: #ccc;
            z-index: 1000;
            border-bottom: 2px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .status-item {
            margin-right: 30px;
            display: flex;
            align-items: center;
        }
        
        .status-item::before {
            content: "‚óè";
            margin-right: 8px;
            color: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-value {
            color: #4CAF50;
            font-weight: bold;
            background: rgba(76, 175, 80, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }
        
        /* Navbar Toggle (Hamburger Menu) */
        .navbar-toggle {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 24px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            padding: 2px;
            border-radius: 4px;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .navbar-toggle:hover {
            background: rgba(76, 175, 80, 0.2);
            transform: translateY(-50%) scale(1.1);
        }
        
        .hamburger-line {
            width: 20px;
            height: 2px;
            background-color: #4CAF50;
            border-radius: 1px;
            transition: all 0.3s ease;
        }
        
        .navbar-toggle:hover .hamburger-line {
            background-color: #45a049;
        }
        
        /* Animation for active state */
        .navbar-toggle.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }
        
        .navbar-toggle.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        
        .navbar-toggle.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }
        
        /* Components panel visibility control */
        .components-hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="status-bar">
        <div class="status-item">UIKit Components Test - Medical Imaging</div>
        <div class="status-item">Status: <span class="status-value" id="status-text">Initializing...</span></div>
        <div class="status-item">WebGL: <span class="status-value" id="webgl-status">Checking...</span></div>
        <div id="navbar-toggle" class="navbar-toggle" title="Toggle Components Panel">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </div>
    </div>

    <div id="container">
        <div id="canvas-container">
            <canvas id="gl1"></canvas>
        </div>
                </div>
                
    <!-- Hidden HTML elements for value updates -->
    <div style="display: none;">
        <span id="brightness-value">50%</span>
        <span id="contrast-value">50%</span>
        <span id="zoom-value">100%</span>
        <span id="opacity-value">100%</span>
        <span id="slice-value">50%</span>
        <span id="crosshair-status">Enabled</span>
        <span id="colorbar-status">Visible</span>
        <span id="radiological-status">Disabled</span>
        <span id="interpolation-status">Enabled</span>
        <span id="info-brightness">50%</span>
        <span id="info-contrast">50%</span>
        <span id="info-zoom">100%</span>
        <span id="info-opacity">100%</span>
        <span id="info-slice">50%</span>
        <span id="info-crosshair">Enabled</span>
        <span id="info-colorbar">Visible</span>
        <span id="info-radiological">Disabled</span>
        <span id="info-interpolation">Enabled</span>
        
        <!-- Hidden buttons for functionality -->
                    <button id="reset-btn">Reset All</button>
                    <button id="save-btn">Save Preset</button>
                    <button id="load-btn">Load Preset</button>
    </div>
    
    <div id="log-panel" style="display: none;">
        <div class="log-entry log-info">UIKit Components Test Started</div>
        <div class="log-entry log-info">Initializing WebGL context...</div>
    </div>

    <script type="module">
        import * as niivue from '../niivue/dist/index.js'
        import { 
            UIKRenderer, 
            UIKFont,
            UIKSlider,
            UIKToggle,
            UIKPanel,
            UIKColormapSelector,
            UIKViewModeSelector,
            UIKButton
        } from '../uikit/dist/index.es.js'

        // Logging system
        let logsVisible = false
        
        function log(message, type = 'info') {
            const logPanel = document.getElementById('log-panel')
            const entry = document.createElement('div')
            entry.className = `log-entry log-${type}`
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`
            logPanel.appendChild(entry)
            logPanel.scrollTop = logPanel.scrollHeight
            console.log(`[${type.toUpperCase()}] ${message}`)
        }
        
        function toggleLogs() {
            const logPanel = document.getElementById('log-panel')
            logsVisible = !logsVisible
            logPanel.style.display = logsVisible ? 'block' : 'none'
            
            if (uikitComponents.logsButton) {
                uikitComponents.logsButton.setText(logsVisible ? 'üìã Hide' : 'üìã Logs')
            }
            
            log(`Logs panel ${logsVisible ? 'shown' : 'hidden'}`, 'event')
        }

        // Status updates
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text
            log(`Status: ${text}`)
        }

        // ===============================
        // LAYOUT CONFIGURATION SYSTEM
        // ===============================
        // Centralized configuration to make the demo flexible and robust
        const LAYOUT_CONFIG = {
            // Main panel configuration
            panel: {
                width: 330,
                rightMargin: 350, // Distance from right edge of canvas
                topMargin: 20,
                backgroundColor: [0.12, 0.12, 0.12, 0.95],
                gradientEnd: [0.16, 0.16, 0.16, 0.95],
                borderColor: [0.27, 0.27, 0.27, 1.0],
                shadowOffset: 5,
                shadowAlpha: 0.5
            },
            
            // Blue section panels with individual attractive colors
            sections: {
                // Default colors (kept for backwards compatibility)
                backgroundColor: [0.18, 0.22, 0.28, 0.9],
                borderColor: [0.29, 0.33, 0.41, 1.0],
                titleColor: [0.408, 0.827, 0.569, 1], 
                cornerRadius: 8,
                borderThickness: 1,
                gap: 15, // Gap between sections
                
                // Individual section heights and attractive colors
                medicalControls: { 
                    height: 240,
                    backgroundColor: [0.176, 0.216, 0.282, 0.8], 
                    borderColor: [0.25, 0.35, 0.45, 1.0]
                },
                viewControls: { 
                    height: 160,
                    backgroundColor: [0.176, 0.216, 0.282, 0.8], 
                    borderColor: [0.35, 0.25, 0.45, 1.0]
                },
                advancedControls: { 
                    height: 240,
                    backgroundColor: [0.176, 0.216, 0.282, 0.8], 
                    borderColor: [0.25, 0.45, 0.35, 1.0]
                },
                actions: { 
                    height: 160,
                    backgroundColor: [0.176, 0.216, 0.282, 0.8], 
                    borderColor: [0.45, 0.35, 0.25, 1.0]
                }
            },
            
            // Content margins within blue panels
            content: {
                marginLeft: 15,
                marginRight: 15,
                marginTop: 40, // Increased from 30 to 40 to accommodate larger title margins (28)
                marginBottom: 15
            },
            
            // Component spacing and sizing
            components: {
                // Slider configuration
                sliders: {
                    width: 170,
                    height: 16,
                    spacing: 32,
                    labelOffset: 110, // Further increased distance for clear separation between labels and sliders
                    marginLeft: 10,
                    marginRight: 10,
                    topOffset: 25, // Configurable vertical offset from section title for better centering
                    showValues: false,
                    textScale: 0.02 // Match View Controls text scale
                },
                
                // Toggle configuration
                toggles: {
                    height: 22,
                    spacing: 28,
                    labelAreaWidth: 180, // Space reserved for labels
                    switchWidth: 60,
                    marginFromEdge: 10
                },
                
                // Button configuration - Enhanced with new robust properties
                buttons: {
                    height: 30,
                    gap: 10,
                    rowSpacing: 40,
                    textColor: [0.0, 0.0, 0.0, 1.0], // Black text
                    borderWidth: 1,
                    borderRadius: 4,
                    padding: [4, 4],
                    // New robust button properties
                    textScale: 0.025,
                    charWidthMultiplier: 7,
                    textHeight: 14,
                    textVerticalOffset: 4
                },
                
                // Selector configuration - Enhanced with new robust properties
                selectors: {
                    colormap: {
                        height: 120,
                        marginLeft: 10,
                        marginRight: 10,
                        // New robust colormap selector properties
                        textScale: 0.018,
                        gradientWidth: 60,
                        gradientHeight: 10,
                        itemPadding: 2,
                        textSpacing: 8,
                        textVerticalOffset: 0,
                        gradientSegments: 20
                    },
                    viewMode: {
                        height: 45,
                        bottomMargin: 15,
                        marginLeft: 10,
                        marginRight: 10,
                        // New robust view mode selector properties
                        textScale: 0.016,
                        buttonPadding: 4,
                        textVerticalOffset: 0,
                        charWidthMultiplier: 1.8
                    }
                }
            },
            
            // Text styling
            text: {
                titleScale: 0.02,
                componentScale: 0.025,
                titleMargins: {
                    medicalControls: 28,  // Increased from 18 to 28 for better spacing
                    viewControls: 28,     // Increased from 18 to 28 for better spacing
                    advancedControls: 28, // Increased from 18 to 28 for better spacing
                    actions: 28           // Increased from 18 to 28 for better spacing
                }
            }
        }

        // ===============================
        // LAYOUT CALCULATION FUNCTIONS
        // ===============================
        
        /**
         * Calculate panel dimensions and positions based on canvas size
         */
        function calculatePanelLayout(canvasWidth, canvasHeight) {
            const config = LAYOUT_CONFIG
            
            return {
                // Main panel
                panelX: canvasWidth - config.panel.rightMargin,
                panelY: config.panel.topMargin,
                panelWidth: config.panel.width,
                
                // Blue panels
                bluePanelX: (canvasWidth - config.panel.rightMargin) + 5,
                bluePanelWidth: config.panel.width - 10,
                
                // Content area within blue panels
                contentX: (canvasWidth - config.panel.rightMargin) + 5 + config.content.marginLeft,
                contentWidth: config.panel.width - 10 - config.content.marginLeft - config.content.marginRight,
                
                // Section positions
                sections: {
                    medical: {
                        y: config.panel.topMargin,
                        height: config.sections.medicalControls.height
                    },
                    view: {
                        y: config.panel.topMargin + config.sections.medicalControls.height + config.sections.gap,
                        height: config.sections.viewControls.height
                    },
                    advanced: {
                        y: config.panel.topMargin + config.sections.medicalControls.height + config.sections.gap + 
                           config.sections.viewControls.height + config.sections.gap,
                        height: config.sections.advancedControls.height
                    },
                    actions: {
                        y: config.panel.topMargin + config.sections.medicalControls.height + config.sections.gap + 
                           config.sections.viewControls.height + config.sections.gap + 
                           config.sections.advancedControls.height + config.sections.gap,
                        height: config.sections.actions.height
                    }
                },
                
                // Total panel height
                totalHeight: config.sections.medicalControls.height + config.sections.viewControls.height + 
                            config.sections.advancedControls.height + config.sections.actions.height + 
                            (config.sections.gap * 3) + config.content.marginBottom
            }
        }

        /**
         * Calculate component positions within sections
         */
        function calculateComponentPositions(layout) {
            const config = LAYOUT_CONFIG
            
            return {
                // Slider positions (accounting for label offset)
                sliders: {
                    x: layout.contentX + config.components.sliders.marginLeft + config.components.sliders.labelOffset,
                    width: config.components.sliders.width,
                    height: config.components.sliders.height,
                    spacing: config.components.sliders.spacing,
                    startY: layout.sections.medical.y + config.content.marginTop + config.components.sliders.topOffset,
                    labelX: layout.contentX + config.components.sliders.marginLeft
                },
                
                // Toggle positions
                toggles: {
                    x: layout.contentX,
                    width: layout.contentWidth - 20,
                    height: config.components.toggles.height,
                    spacing: config.components.toggles.spacing,
                    startY: layout.sections.view.y + config.content.marginTop
                },
                
                // Button positions
                buttons: {
                    x: layout.contentX + 10,
                    width: (layout.contentWidth - 30) / 2,
                    height: config.components.buttons.height,
                    gap: config.components.buttons.gap,
                    rowSpacing: config.components.buttons.rowSpacing,
                    startY: layout.sections.actions.y + config.content.marginTop
                },
                
                // Selector positions
                selectors: {
                    colormap: {
                        x: layout.contentX + config.components.selectors.colormap.marginLeft,
                        y: layout.sections.advanced.y + config.content.marginTop,
                        width: layout.contentWidth - config.components.selectors.colormap.marginLeft - config.components.selectors.colormap.marginRight,
                        height: config.components.selectors.colormap.height
                    },
                    viewMode: {
                        x: layout.contentX + config.components.selectors.viewMode.marginLeft,
                        y: layout.sections.advanced.y + layout.sections.advanced.height - 
                           config.components.selectors.viewMode.height - config.components.selectors.viewMode.bottomMargin,
                        width: layout.contentWidth - config.components.selectors.viewMode.marginLeft - config.components.selectors.viewMode.marginRight,
                        height: config.components.selectors.viewMode.height
                    }
                }
            }
        }

        // Medical imaging parameters
        const medicalParams = {
            brightness: 0.5,
            contrast: 0.5,
            zoom: 1.0,
            opacity: 1.0,
            slice: 0.5,
            crosshair: true,
            colorbar: true,
            radiological: false,
            interpolation: true,
            colormap: 'gray',
            viewMode: 'MultiPlanar'
        }

        // Component panel visibility state
        let componentsVisible = true

        // UIKit component instances
        let uikitComponents = {
            brightnessSlider: null,
            contrastSlider: null,
            zoomSlider: null,
            opacitySlider: null,
            sliceSlider: null,
            crosshairToggle: null,
            colorbarToggle: null,
            radiologicalToggle: null,
            interpolationToggle: null,
            colormapSelector: null,
            viewModeSelector: null,
            screenshotButton: null,
            backgroundButton: null,
            logsButton: null,
            resetButton: null
        }

        // Medical imaging state
        let currentBackground = 'dark' // dark, light

        // Global variables - declare all at the top
        let nv = null // Niivue instance
        let uikitRenderer = null
        let uikitFont = null

        // WebGL state management functions
        function saveGLState(gl) {
            return {
                viewport: new Int32Array(gl.getParameter(gl.VIEWPORT)),
                depthTest: gl.getParameter(gl.DEPTH_TEST),
                blend: gl.getParameter(gl.BLEND),
                blendFuncSrcRGB: gl.getParameter(gl.BLEND_SRC_RGB),
                blendFuncDstRGB: gl.getParameter(gl.BLEND_DST_RGB),
                blendFuncSrcAlpha: gl.getParameter(gl.BLEND_SRC_ALPHA),
                blendFuncDstAlpha: gl.getParameter(gl.BLEND_DST_ALPHA),
                scissorTest: gl.getParameter(gl.SCISSOR_TEST),
                scissorBox: new Int32Array(gl.getParameter(gl.SCISSOR_BOX)),
                framebuffer: gl.getParameter(gl.FRAMEBUFFER_BINDING),
                currentProgram: gl.getParameter(gl.CURRENT_PROGRAM)
            };
        }

        function restoreGLState(gl, state) {
            gl.viewport(state.viewport[0], state.viewport[1], state.viewport[2], state.viewport[3]);
            state.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST);
            state.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND);
            gl.blendFuncSeparate(
                state.blendFuncSrcRGB, state.blendFuncDstRGB,
                state.blendFuncSrcAlpha, state.blendFuncDstAlpha
            );
            state.scissorTest ? gl.enable(gl.SCISSOR_TEST) : gl.disable(gl.SCISSOR_TEST);
            gl.scissor(state.scissorBox[0], state.scissorBox[1], state.scissorBox[2], state.scissorBox[3]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.framebuffer);
            gl.useProgram(state.currentProgram);
        }

        // Initialize Niivue with medical image and UIKit integration
        async function initializeNiivue() {
            try {
                log('Starting Niivue initialization...', 'info')
                updateStatus('Creating Niivue instance...')
                
                // Check if required modules are available
                if (!niivue) {
                    throw new Error('Niivue module not loaded')
                }
                if (!UIKRenderer) {
                    throw new Error('UIKRenderer not available')
                }
                if (!UIKFont) {
                    throw new Error('UIKFont not available')
                }
                log('All required modules loaded successfully', 'info')
                
                // Create Niivue with medical imaging optimized settings
                nv = new niivue.Niivue({
                    backColor: [0.1, 0.1, 0.1, 1],
                    show3Dcrosshair: true,
                    onLocationChange: handleLocationChange,
                    dragAndDropEnabled: true
                })
                
                log('Niivue instance created successfully', 'info')
                
                // Configure for medical imaging
                nv.opts.isColorbar = true
                nv.setRadiologicalConvention(false)
                
                updateStatus('Attaching to canvas...')
                await nv.attachTo('gl1')
                
                log('Niivue attached to canvas successfully', 'info')
                
                // Check WebGL status
                const gl = nv.gl
                if (!gl) {
                    throw new Error('Failed to create WebGL context')
                }
                
                log(`WebGL context created: ${gl.constructor.name}`, 'info')
                document.getElementById('webgl-status').textContent = 'WebGL2 Ready'
                
                updateStatus('Initializing UIKit on main canvas...')
                
                // Initialize UIKit renderer using the same WebGL context as Niivue
                uikitRenderer = new UIKRenderer(gl)
                uikitFont = new UIKFont(gl, [1, 1, 1, 1])
                
                log('UIKit renderer and font instances created', 'info')
                
                // Load font using the working approach from previous version
                try {
                    // Dynamic imports for font files - use font files from uikit package
                    const { default: defaultFontPNG } = await import('../uikit/src/fonts/Roboto-Regular.png')
                    const { default: defaultFontJSON } = await import('../uikit/src/fonts/Roboto-Regular.json')
                    
                    const fontTexture = await uikitFont.loadFontTexture(defaultFontPNG)
                    if (!fontTexture) {
                        throw new Error(`Failed to load font texture`)
                    }
                    uikitFont.loadFromRawData(defaultFontJSON)
                    log('UIKit font loaded successfully using dynamic imports from uikit package', 'info')
                } catch (fontError) {
                    log(`Font loading failed: ${fontError.message}`, 'warn')
                    log('Falling back to default font system', 'info')
                    try {
                        await uikitFont.loadDefaultFont()
                        log('Default UIKit font loaded as fallback', 'info')
                    } catch (fallbackError) {
                        log(`Fallback font loading also failed: ${fallbackError.message}`, 'error')
                        log('Proceeding with basic font fallback', 'info')
                    }
                }
                
                log('UIKit renderer and font initialized on main canvas', 'info')
                
                updateStatus('Loading medical image...')
                
                // Try to load a medical brain image (MNI152 template)
                const volumeList = [{ 
                    url: 'https://niivue.github.io/niivue-demo-images/mni152.nii.gz',
                    colormap: 'gray',
                    opacity: 1.0,
                    visible: true
                }]
                
                try {
                    await nv.loadVolumes(volumeList)
                    log(`Medical image loaded: ${volumeList[0].url}`, 'info')
                    log(`Volume dimensions: ${nv.volumes[0].dims}`, 'info')
                    
                    // Set optimal view for medical imaging
                    nv.setSliceType(nv.sliceTypeMultiplanar)
                    nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                    nv.setRenderAzimuthElevation(120, 10)
                    
                    // Set rendering parameters for better visualization
                    nv.setInterpolation(true) // Smoother display
                    nv.opts.isColorbar = true
                    
                    // Configure slice positions for all three views
                    nv.scene.sagittalPos = 0.5
                    nv.scene.coronalPos = 0.5
                    nv.scene.axialPos = 0.5
                    
                    // Update the volume rendering
                    nv.updateGLVolume()
                    
                } catch (imageError) {
                    log(`Failed to load medical image: ${imageError.message}`, 'error')
                    log(`Attempted URL: ${volumeList[0].url}`, 'error')
                    log('Creating demo without medical image - UIKit components will still work', 'warn')
                    
                    // Set up basic view even without image
                    nv.setSliceType(nv.sliceTypeMultiplanar)
                    nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                    
                    updateStatus('Demo Ready - Drag and drop a NIfTI file to test')
                }
                
                log('Medical image loaded successfully', 'info')
                updateStatus('Creating UI overlay components...')
                
                // Wait for layout to be properly calculated before creating components
                setTimeout(async () => {
                    // Force canvas to update its dimensions
                    const canvas = document.getElementById('gl1')
                    canvas.width = canvas.clientWidth
                    canvas.height = canvas.clientHeight
                    
                    log(`Canvas dimensions: ${canvas.width}x${canvas.height}`, 'info')
                    
                    // Create UIKit components on the main canvas as overlays
                    await createUIKitOverlayComponents()
                    
                    updateStatus('Ready - Medical Imaging Interface with UIKit HUD Active')
                    log('All systems ready for medical imaging with integrated UIKit overlay', 'info')
                }, 500)
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error')
                updateStatus('Initialization Failed')
                document.getElementById('webgl-status').textContent = 'Error'
            }
        }

        // Handle location changes in medical image
        function handleLocationChange(data) {
            if (data && data.string) {
                log(`Location: ${data.string}`, 'event')
            }
        }

        // Create UIKit overlay components on the main Niivue canvas
        async function createUIKitOverlayComponents() {
            try {
                log('Creating UIKit overlay components on main Niivue canvas', 'info')
                
                // Get canvas dimensions for positioning
                const canvas = document.getElementById('gl1')
                const canvasWidth = canvas.width
                const canvasHeight = canvas.height
                
                // Calculate layout based on canvas size
                const layout = calculatePanelLayout(canvasWidth, canvasHeight)
                const componentPositions = calculateComponentPositions(layout)
                
                // SECTION 1: Medical Imaging Controls (Sliders)
                // Position sliders within blue panel bounds with proper spacing like other sections
                let currentY = componentPositions.sliders.startY
                const sliderConfig = LAYOUT_CONFIG.components.sliders
                
                // Create brightness slider
                uikitComponents.brightnessSlider = new UIKSlider(uikitRenderer, {
                    bounds: [componentPositions.sliders.x, currentY, sliderConfig.width, sliderConfig.height],
                            value: medicalParams.brightness,
                            min: 0,
                            max: 1,
                    label: 'Brightness',
                    labelOffset: -sliderConfig.labelOffset, // Position label to the left of slider
                    showValue: sliderConfig.showValues,
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1],
                        fillColor: [0.0, 0.8, 0.0, 1],
                        thumbColor: [1.0, 1.0, 1.0, 1],
                        textColor: [1.0, 1.0, 1.0, 1],
                        textScale: sliderConfig.textScale
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.brightness = value
                                updateBrightness(value)
                                document.getElementById('brightness-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-brightness').textContent = Math.round(value * 100) + '%'
                                log(`Brightness adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += sliderConfig.spacing
                
                // Create contrast slider
                uikitComponents.contrastSlider = new UIKSlider(uikitRenderer, {
                    bounds: [componentPositions.sliders.x, currentY, sliderConfig.width, sliderConfig.height],
                            value: medicalParams.contrast,
                            min: 0,
                            max: 1,
                    label: 'Contrast',
                    labelOffset: -sliderConfig.labelOffset, // Position label to the left of slider
                    showValue: sliderConfig.showValues,
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1],
                        fillColor: [1.0, 0.6, 0.0, 1],
                        thumbColor: [1.0, 1.0, 1.0, 1],
                        textColor: [1.0, 1.0, 1.0, 1],
                        textScale: sliderConfig.textScale
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.contrast = value
                                updateContrast(value)
                                document.getElementById('contrast-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-contrast').textContent = Math.round(value * 100) + '%'
                                log(`Contrast adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += sliderConfig.spacing
                
                // Create zoom slider
                uikitComponents.zoomSlider = new UIKSlider(uikitRenderer, {
                    bounds: [componentPositions.sliders.x, currentY, sliderConfig.width, sliderConfig.height],
                            value: medicalParams.zoom,
                            min: 0.1,
                            max: 5.0,
                    label: 'Zoom',
                    labelOffset: -sliderConfig.labelOffset, // Position label to the left of slider
                    showValue: sliderConfig.showValues,
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1],
                        fillColor: [0.0, 0.6, 1.0, 1],
                        thumbColor: [1.0, 1.0, 1.0, 1],
                        textColor: [1.0, 1.0, 1.0, 1],
                        textScale: sliderConfig.textScale
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.zoom = value
                                updateZoom(value)
                                document.getElementById('zoom-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-zoom').textContent = Math.round(value * 100) + '%'
                                log(`Zoom adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += sliderConfig.spacing
                
                // Create opacity slider
                uikitComponents.opacitySlider = new UIKSlider(uikitRenderer, {
                    bounds: [componentPositions.sliders.x, currentY, sliderConfig.width, sliderConfig.height],
                            value: medicalParams.opacity,
                            min: 0,
                            max: 1,
                    label: 'Opacity',
                    labelOffset: -sliderConfig.labelOffset, // Position label to the left of slider
                    showValue: sliderConfig.showValues,
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1],
                        fillColor: [0.8, 0.0, 0.8, 1],
                        thumbColor: [1.0, 1.0, 1.0, 1],
                        textColor: [1.0, 1.0, 1.0, 1],
                        textScale: sliderConfig.textScale
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.opacity = value
                                updateOpacity(value)
                                document.getElementById('opacity-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-opacity').textContent = Math.round(value * 100) + '%'
                                log(`Opacity adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += sliderConfig.spacing
                
                // Create slice position slider
                uikitComponents.sliceSlider = new UIKSlider(uikitRenderer, {
                    bounds: [componentPositions.sliders.x, currentY, sliderConfig.width, sliderConfig.height],
                            value: medicalParams.slice,
                            min: 0,
                            max: 1,
                    label: 'Slice Position',
                    labelOffset: -sliderConfig.labelOffset, // Position label to the left of slider
                    showValue: sliderConfig.showValues,
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1],
                        fillColor: [1.0, 1.0, 0.0, 1],
                        thumbColor: [1.0, 1.0, 1.0, 1],
                        textColor: [1.0, 1.0, 1.0, 1],
                        textScale: sliderConfig.textScale
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.slice = value
                                updateSlice(value)
                                document.getElementById('slice-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-slice').textContent = Math.round(value * 100) + '%'
                                log(`Slice position adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                        
                // SECTION 2: View Controls (Toggles)
                // Position toggles within blue panel bounds to match Advanced Controls alignment
                currentY = componentPositions.toggles.startY
                const toggleConfig = LAYOUT_CONFIG.components.toggles
                
                // Create crosshair toggle
                uikitComponents.crosshairToggle = new UIKToggle(uikitRenderer, {
                    bounds: [componentPositions.toggles.x, currentY, componentPositions.toggles.width, toggleConfig.height],
                            checked: medicalParams.crosshair,
                            type: 'switch',
                    label: 'Crosshair',
                    labelPosition: 'left',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.crosshair = checked
                                updateCrosshair(checked)
                                document.getElementById('crosshair-status').textContent = checked ? 'Enabled' : 'Disabled'
                                document.getElementById('info-crosshair').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Crosshair ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                currentY += toggleConfig.spacing
                
                // Create colorbar toggle
                uikitComponents.colorbarToggle = new UIKToggle(uikitRenderer, {
                    bounds: [componentPositions.toggles.x, currentY, componentPositions.toggles.width, toggleConfig.height],
                            checked: medicalParams.colorbar,
                            type: 'switch',
                    label: 'Colorbar',
                    labelPosition: 'left',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.colorbar = checked
                                updateColorbar(checked)
                                document.getElementById('colorbar-status').textContent = checked ? 'Visible' : 'Hidden'
                                document.getElementById('info-colorbar').textContent = checked ? 'Visible' : 'Hidden'
                                log(`Colorbar ${checked ? 'shown' : 'hidden'}`, 'event')
                            }
                        })
                currentY += toggleConfig.spacing
                
                // Create radiological toggle
                uikitComponents.radiologicalToggle = new UIKToggle(uikitRenderer, {
                    bounds: [componentPositions.toggles.x, currentY, componentPositions.toggles.width, toggleConfig.height],
                            checked: medicalParams.radiological,
                            type: 'switch',
                    label: 'Radiological',
                    labelPosition: 'left',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.radiological = checked
                                updateRadiological(checked)
                                document.getElementById('radiological-status').textContent = checked ? 'Enabled' : 'Disabled'
                                document.getElementById('info-radiological').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Radiological convention ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                currentY += toggleConfig.spacing
                
                // Create interpolation toggle
                uikitComponents.interpolationToggle = new UIKToggle(uikitRenderer, {
                    bounds: [componentPositions.toggles.x, currentY, componentPositions.toggles.width, toggleConfig.height],
                            checked: medicalParams.interpolation,
                            type: 'switch',
                    label: 'Interpolation',
                    labelPosition: 'left',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.interpolation = checked
                                updateInterpolation(checked)
                                document.getElementById('interpolation-status').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Interpolation ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                        
                // SECTION 3: Advanced Controls
                // Position selectors within blue panel bounds
                currentY = componentPositions.selectors.colormap.y
                const selectorConfig = LAYOUT_CONFIG.components.selectors
                
                // Create colormap selector with larger size and thicker rows
                uikitComponents.colormapSelector = new UIKColormapSelector(uikitRenderer, {
                    bounds: [componentPositions.selectors.colormap.x, currentY, componentPositions.selectors.colormap.width, selectorConfig.colormap.height],
                        selectedColormap: medicalParams.colormap,
                        colormaps: ['gray', 'plasma', 'viridis', 'inferno', 'hot', 'cool'],
                    font: uikitFont,
                    onColormapChange: updateColormap,
                    style: {
                        textScale: selectorConfig.colormap.textScale,
                        gradientWidth: selectorConfig.colormap.gradientWidth,
                        gradientHeight: selectorConfig.colormap.gradientHeight,
                        itemPadding: selectorConfig.colormap.itemPadding,
                        textSpacing: selectorConfig.colormap.textSpacing,
                        textVerticalOffset: selectorConfig.colormap.textVerticalOffset,
                        gradientSegments: selectorConfig.colormap.gradientSegments
                    }
                })
                    
                // Calculate position for view mode selector at bottom of Advanced Controls section
                const viewModeSelectorY = componentPositions.selectors.viewMode.y
                
                // Create view mode selector positioned at bottom
                uikitComponents.viewModeSelector = new UIKViewModeSelector(uikitRenderer, {
                    bounds: [componentPositions.selectors.viewMode.x, viewModeSelectorY, componentPositions.selectors.viewMode.width, selectorConfig.viewMode.height],
                        selectedMode: medicalParams.viewMode,
                        modes: ['Axial', 'Sagittal', 'Coronal', 'MultiPlanar'],
                    font: uikitFont,
                    onModeChange: updateViewMode,
                    style: {
                        textScale: selectorConfig.viewMode.textScale,
                        buttonPadding: selectorConfig.viewMode.buttonPadding,
                        textVerticalOffset: selectorConfig.viewMode.textVerticalOffset,
                        charWidthMultiplier: selectorConfig.viewMode.charWidthMultiplier
                    }
                })
                    
                // SECTION 4: Action Buttons
                // Center buttons vertically within the blue panel
                const buttonConfig = LAYOUT_CONFIG.components.buttons
                const buttonWidth = componentPositions.buttons.width
                const buttonHeight = buttonConfig.height
                const buttonGap = buttonConfig.gap
                const buttonRowSpacing = buttonConfig.rowSpacing
                
                // Calculate vertical centering within the Actions section
                const totalButtonsHeight = (buttonHeight * 2) + buttonRowSpacing
                const availableVerticalSpace = layout.sections.actions.height - LAYOUT_CONFIG.content.marginTop - LAYOUT_CONFIG.content.marginBottom
                const verticalOffset = (availableVerticalSpace - totalButtonsHeight) / 2 + 15
                currentY = layout.sections.actions.y + LAYOUT_CONFIG.content.marginTop + verticalOffset
                
                // Row 1: Screenshot and Background buttons
                uikitComponents.screenshotButton = new UIKButton(uikitRenderer, {
                    bounds: [componentPositions.buttons.x, currentY, buttonWidth, buttonHeight],
                    text: 'Save',
                    font: uikitFont,
                    onClick: () => {
                        if (nv) {
                            nv.drawScene()
                            renderUIKitOverlay()
                            nv.gl.finish()
                            
                            const canvas = document.getElementById('gl1')
                            canvas.toBlob((blob) => {
                                if (!blob) {
                                    log('Failed to create screenshot', 'error')
                                    return
                                }
                                
                                const filename = 'MedicalImage_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png'
                                const a = document.createElement('a')
                                document.body.appendChild(a)
                                a.style.display = 'none'
                                const url = window.URL.createObjectURL(blob)
                                a.href = url
                                a.download = filename
                                a.click()
                                a.remove()
                                window.URL.revokeObjectURL(url)
                                
                                log('Screenshot saved with UIKit overlay', 'info')
                            })
                            }
                        },
                        style: {
                        backgroundColor: [0.2, 0.6, 0.9, 1.0],
                        hoverColor: [0.3, 0.7, 1.0, 1.0],
                        activeColor: [0.1, 0.5, 0.8, 1.0],
                        borderColor: [0.4, 0.8, 1.0, 1.0],
                        textColor: buttonConfig.textColor,
                        borderWidth: buttonConfig.borderWidth,
                        borderRadius: buttonConfig.borderRadius,
                        padding: buttonConfig.padding,
                        textScale: buttonConfig.textScale,
                        charWidthMultiplier: buttonConfig.charWidthMultiplier,
                        textHeight: buttonConfig.textHeight,
                        textVerticalOffset: buttonConfig.textVerticalOffset
                    }
                })
                
                // Background Toggle Button
                uikitComponents.backgroundButton = new UIKButton(uikitRenderer, {
                    bounds: [componentPositions.buttons.x + buttonWidth + buttonGap, currentY, buttonWidth, buttonHeight],
                        text: 'Dark',
                    font: uikitFont,
                        onClick: () => {
                            if (nv) {
                                if (currentBackground === 'dark') {
                                nv.opts.backColor = [1, 1, 1, 1]
                                    currentBackground = 'light'
                                    uikitComponents.backgroundButton.setText('Light')
                                } else {
                                nv.opts.backColor = [0.1, 0.1, 0.1, 1]
                                    currentBackground = 'dark'
                                    uikitComponents.backgroundButton.setText('Dark')
                                }
                                nv.drawScene()
                                log(`Background changed to ${currentBackground}`, 'event')
                            }
                        },
                        style: {
                        backgroundColor: [0.6, 0.4, 0.9, 1.0],
                        hoverColor: [0.7, 0.5, 1.0, 1.0],
                        activeColor: [0.5, 0.3, 0.8, 1.0],
                        borderColor: [0.8, 0.6, 1.0, 1.0],
                        textColor: buttonConfig.textColor,
                        borderWidth: buttonConfig.borderWidth,
                        borderRadius: buttonConfig.borderRadius,
                        padding: buttonConfig.padding,
                        textScale: buttonConfig.textScale,
                        charWidthMultiplier: buttonConfig.charWidthMultiplier,
                        textHeight: buttonConfig.textHeight,
                        textVerticalOffset: buttonConfig.textVerticalOffset
                    }
                })
                    
                // Row 2: Logs and Reset buttons
                currentY += buttonRowSpacing
                uikitComponents.logsButton = new UIKButton(uikitRenderer, {
                    bounds: [componentPositions.buttons.x, currentY, buttonWidth, buttonHeight],
                        text: 'Logs',
                    font: uikitFont,
                        onClick: () => {
                        const logPanel = document.getElementById('log-panel')
                        if (logPanel.style.display === 'none') {
                            logPanel.style.display = 'block'
                            uikitComponents.logsButton.setText('Hide')
                            log('Log panel opened', 'info')
                        } else {
                            logPanel.style.display = 'none'
                            uikitComponents.logsButton.setText('Logs')
                            log('Log panel closed', 'info')
                        }
                        },
                        style: {
                        backgroundColor: [0.9, 0.6, 0.2, 1.0],
                            hoverColor: [1.0, 0.7, 0.3, 1.0],
                        activeColor: [0.8, 0.5, 0.1, 1.0],
                            borderColor: [1.0, 0.8, 0.4, 1.0],
                        textColor: buttonConfig.textColor,
                        borderWidth: buttonConfig.borderWidth,
                        borderRadius: buttonConfig.borderRadius,
                        padding: buttonConfig.padding,
                        textScale: buttonConfig.textScale,
                        charWidthMultiplier: buttonConfig.charWidthMultiplier,
                        textHeight: buttonConfig.textHeight,
                        textVerticalOffset: buttonConfig.textVerticalOffset
                    }
                })
                
                // Reset All Button
                uikitComponents.resetButton = new UIKButton(uikitRenderer, {
                    bounds: [componentPositions.buttons.x + buttonWidth + buttonGap, currentY, buttonWidth, buttonHeight],
                    text: 'Reset',
                    font: uikitFont,
                    onClick: () => {
                        const initialParams = {
                            brightness: 0.5,
                            contrast: 0.5,
                            zoom: 1.0,
                            opacity: 1.0,
                            slice: 0.5,
                            crosshair: true,
                            colorbar: true,
                            radiological: false,
                            interpolation: true,
                            colormap: 'gray',
                            viewMode: 'MultiPlanar'
                        }
                        
                        Object.assign(medicalParams, initialParams)
                        
                        if (nv) {
                            nv.setSliceType(nv.sliceTypeMultiplanar)
                            nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                            
                            if (nv.volumes.length > 0) {
                                nv.volumes[0].cal_min = (1 - initialParams.brightness) * 100
                                nv.volumes[0].cal_max = 100 + ((1 - initialParams.contrast) * 200)
                                nv.volumes[0].opacity = initialParams.opacity
                                nv.volumes[0].colormap = initialParams.colormap
                            }
                            
                            nv.scene.volScaleMultiplier = initialParams.zoom
                            nv.scene.sagittalPos = initialParams.slice
                            nv.scene.coronalPos = initialParams.slice
                            nv.scene.axialPos = initialParams.slice
                            
                            nv.opts.show3Dcrosshair = initialParams.crosshair
                            nv.opts.isColorbar = initialParams.colorbar
                            nv.setRadiologicalConvention(initialParams.radiological)
                            nv.setInterpolation(initialParams.interpolation)
                            
                            nv.updateGLVolume()
                            nv.drawScene()
                        }
                        
                        if (uikitComponents.brightnessSlider) uikitComponents.brightnessSlider.setValue(initialParams.brightness)
                        if (uikitComponents.contrastSlider) uikitComponents.contrastSlider.setValue(initialParams.contrast)
                        if (uikitComponents.zoomSlider) uikitComponents.zoomSlider.setValue(initialParams.zoom)
                        if (uikitComponents.opacitySlider) uikitComponents.opacitySlider.setValue(initialParams.opacity)
                        if (uikitComponents.sliceSlider) uikitComponents.sliceSlider.setValue(initialParams.slice)
                        if (uikitComponents.crosshairToggle) uikitComponents.crosshairToggle.setChecked(initialParams.crosshair)
                        if (uikitComponents.colorbarToggle) uikitComponents.colorbarToggle.setChecked(initialParams.colorbar)
                        if (uikitComponents.radiologicalToggle) uikitComponents.radiologicalToggle.setChecked(initialParams.radiological)
                        if (uikitComponents.interpolationToggle) uikitComponents.interpolationToggle.setChecked(initialParams.interpolation)
                        if (uikitComponents.viewModeSelector) uikitComponents.viewModeSelector.setSelectedMode(initialParams.viewMode)
                        
                        log('All parameters reset to defaults', 'info')
                        },
                        style: {
                        backgroundColor: [0.9, 0.2, 0.2, 1.0],
                        hoverColor: [1.0, 0.3, 0.3, 1.0],
                        activeColor: [0.8, 0.1, 0.1, 1.0],
                        borderColor: [1.0, 0.4, 0.4, 1.0],
                        textColor: buttonConfig.textColor,
                        borderWidth: buttonConfig.borderWidth,
                        borderRadius: buttonConfig.borderRadius,
                        padding: buttonConfig.padding,
                        textScale: buttonConfig.textScale,
                        charWidthMultiplier: buttonConfig.charWidthMultiplier,
                        textHeight: buttonConfig.textHeight,
                        textVerticalOffset: buttonConfig.textVerticalOffset
                    }
                })
                    
                log('All UIKit overlay components created successfully on main canvas', 'info')
                
            } catch (error) {
                log(`Failed to create UIKit overlay components: ${error.message}`, 'error')
                throw error
            }
        }

        // Handle mouse events for UIKit overlay components on main canvas
        function handleUIKitMouseEvents(event) {
            if (!uikitRenderer) return false

            // Get canvas bounds for proper mouse coordinate calculation
            const canvas = document.getElementById('gl1')
                const rect = canvas.getBoundingClientRect()
            
            // Calculate proper mouse coordinates relative to canvas
            const mouseX = event.clientX - rect.left
            const mouseY = event.clientY - rect.top
            
            // Create a proper mouse event with correct coordinates
            const mouseEvent = {
                type: event.type,
                offsetX: mouseX,
                offsetY: mouseY,
                clientX: event.clientX,
                clientY: event.clientY,
                    target: canvas,
                preventDefault: () => event.preventDefault(),
                stopPropagation: () => event.stopPropagation()
            }

            let handled = false
            
            // Check each overlay component for mouse interaction
            for (const [name, component] of Object.entries(uikitComponents)) {
                if (component && component.handleMouseEvent) {
                    try {
                        if (component.handleMouseEvent(mouseEvent)) {
                            handled = true
                            log(`Mouse event handled by ${name}`, 'event')
                            break
                        }
                    } catch (error) {
                        log(`Error in ${name} mouse handler: ${error.message}`, 'error')
                    }
                }
            }
            
            return handled
        }

        // Medical imaging parameter update functions
        function updateBrightness(value) {
            medicalParams.brightness = value
            if (nv && nv.volumes && nv.volumes.length > 0) {
                nv.volumes[0].cal_min = (1 - value) * 100
                nv.updateGLVolume()
                nv.drawScene()
                log(`Brightness adjusted to ${Math.round(value * 100)}%`, 'event')
            }
            
            document.getElementById('brightness-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-brightness').textContent = `${Math.round(value * 100)}%`
        }

        function updateContrast(value) {
            medicalParams.contrast = value
            if (nv && nv.volumes.length > 0) {
                const baseMax = 100 + ((1 - value) * 200)
                nv.volumes[0].cal_max = baseMax
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('contrast-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-contrast').textContent = `${Math.round(value * 100)}%`
            log(`Contrast adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateZoom(value) {
            medicalParams.zoom = value
            if (nv) {
                nv.scene.volScaleMultiplier = value
                nv.drawScene()
            }
            
            document.getElementById('zoom-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-zoom').textContent = `${Math.round(value * 100)}%`
            log(`Zoom adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateOpacity(value) {
            medicalParams.opacity = value
            if (nv && nv.volumes.length > 0) {
                nv.volumes[0].opacity = value
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('opacity-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-opacity').textContent = `${Math.round(value * 100)}%`
            log(`Opacity adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateSlice(value) {
            medicalParams.slice = value
            if (nv) {
                nv.scene.sagittalPos = value
                nv.scene.coronalPos = value
                nv.scene.axialPos = value
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('slice-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-slice').textContent = `${Math.round(value * 100)}%`
            log(`Slice position adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateCrosshair(checked) {
            medicalParams.crosshair = checked
            if (nv) {
                nv.opts.show3Dcrosshair = checked
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('crosshair-status').textContent = status
            document.getElementById('info-crosshair').textContent = status
            log(`Crosshair ${status.toLowerCase()}`, 'event')
        }

        function updateColorbar(checked) {
            medicalParams.colorbar = checked
            if (nv) {
                nv.opts.isColorbar = checked
                nv.drawScene()
            }
            
            const status = checked ? 'Visible' : 'Hidden'
            document.getElementById('colorbar-status').textContent = status
            document.getElementById('info-colorbar').textContent = status
            log(`Colorbar ${status.toLowerCase()}`, 'event')
        }

        function updateRadiological(checked) {
            medicalParams.radiological = checked
            if (nv) {
                nv.setRadiologicalConvention(checked)
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('radiological-status').textContent = status
            document.getElementById('info-radiological').textContent = status
            log(`Radiological ${status.toLowerCase()}`, 'event')
        }

        function updateInterpolation(checked) {
            medicalParams.interpolation = checked
            if (nv) {
                nv.setInterpolation(checked)
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('interpolation-status').textContent = status
            document.getElementById('info-interpolation').textContent = status
            log(`Interpolation ${status.toLowerCase()}`, 'event')
        }

        function updateColormap(colormap) {
            medicalParams.colormap = colormap
            if (nv) {
                nv.volumes[0].colormap = colormap
                nv.updateGLVolume()
                nv.drawScene()
            }
            log(`Colormap changed to ${colormap}`, 'event')
        }

        function updateViewMode(mode) {
            medicalParams.viewMode = mode
            if (nv) {
                let sliceType
                switch (mode) {
                    case 'Axial':
                        sliceType = nv.sliceTypeAxial
                        break
                    case 'Coronal':
                        sliceType = nv.sliceTypeCoronal
                        break
                    case 'Sagittal':
                        sliceType = nv.sliceTypeSagittal
                        break
                    case 'Render':
                        sliceType = nv.sliceTypeRender
                        break
                    case 'MultiPlanar':
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER
                        break
                    case 'MultiPlanarRender':
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                        break
                    default:
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                }
                
                nv.setSliceType(sliceType)
                nv.drawScene()
                log(`View mode applied: ${mode}`, 'debug')
            }
            log(`View mode changed to ${mode}`, 'event')
        }

        // Updated render loop for UIKit overlay components with proper styling
        function renderUIKitOverlay() {
            if (!uikitRenderer || !uikitFont) return
            
            // Check if components panel is visible
            if (!componentsVisible) return
            
            // Get WebGL context and save current state
            const gl = nv.gl
            const canvas = document.getElementById('gl1')
            const state = saveGLState(gl)
            
            // Set UIKit rendering state
            gl.viewport(0, 0, canvas.width, canvas.height)
            gl.disable(gl.DEPTH_TEST)
            gl.enable(gl.BLEND)
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
            
            // Define UI panel dimensions and position
            const panelX = canvas.width - 350
            const panelY = 20
            const panelWidth = 330
            
            // Calculate required height based on all sections
            const section1Height = 240  // Medical Imaging Controls
            const section2Height = 160  // View Controls  
            const section3Height = 240  // Advanced Controls
            const section4Height = 160  // Actions
            const sectionGap = 15        // Gap between sections
            const bottomMargin = 20      // Bottom margin
            
            const panelHeight = section1Height + sectionGap + section2Height + sectionGap + 
                               section3Height + sectionGap + section4Height + bottomMargin
            
            // Draw main panel background with gradient effect
            const backgroundColor = [0.12, 0.12, 0.12, 0.95]
            const gradientEnd = [0.16, 0.16, 0.16, 0.95]
            
            for (let i = 0; i < panelHeight; i++) {
                const gradientFactor = i / panelHeight
                const bgColor = [
                    backgroundColor[0] + (gradientEnd[0] - backgroundColor[0]) * gradientFactor,
                    backgroundColor[1] + (gradientEnd[1] - backgroundColor[1]) * gradientFactor,
                    backgroundColor[2] + (gradientEnd[2] - backgroundColor[2]) * gradientFactor,
                    backgroundColor[3]
                ]
                uikitRenderer.drawLine({
                    startEnd: [panelX - 10, panelY - 10 + i, panelX - 10 + panelWidth + 20, panelY - 10 + i],
                    thickness: 1,
                    color: bgColor
                })
            }
            
            // Draw panel shadow effect
            for (let i = 1; i <= 5; i++) {
                const shadowAlpha = 0.5 * (1 - (i - 1) / 4)
                uikitRenderer.drawLine({
                    startEnd: [panelX - 10 - i, panelY - 10, panelX - 10 - i, panelY - 10 + panelHeight],
                    thickness: 1,
                    color: [0, 0, 0, shadowAlpha]
                })
            }
            
            // Draw panel border
            uikitRenderer.drawLine({
                startEnd: [panelX - 10, panelY - 10, panelX - 10, panelY - 10 + panelHeight],
                thickness: 1,
                color: [0.27, 0.27, 0.27, 1.0]
            })
            
            // Section styling - use individual attractive colors for each section
            
            // SECTION 1: Medical Imaging Controls - Deep Blue
            const section1Y = panelY
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section1Y, panelWidth - 10, section1Height],
                fillColor: LAYOUT_CONFIG.sections.medicalControls.backgroundColor,
                outlineColor: LAYOUT_CONFIG.sections.medicalControls.borderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 2: View Controls - Purple
            const section2Y = section1Y + section1Height + 15
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section2Y, panelWidth - 10, section2Height],
                fillColor: LAYOUT_CONFIG.sections.viewControls.backgroundColor,
                outlineColor: LAYOUT_CONFIG.sections.viewControls.borderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 3: Advanced Controls - Teal
            const section3Y = section2Y + section2Height + 15
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section3Y, panelWidth - 10, section3Height],
                fillColor: LAYOUT_CONFIG.sections.advancedControls.backgroundColor,
                outlineColor: LAYOUT_CONFIG.sections.advancedControls.borderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 4: Actions - Warm Brown
            const section4Y = section3Y + section3Height + 15
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section4Y, panelWidth - 10, section4Height],
                fillColor: LAYOUT_CONFIG.sections.actions.backgroundColor,
                outlineColor: LAYOUT_CONFIG.sections.actions.borderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // Draw section titles - properly centered within each blue panel with configurable top margin
            if (uikitFont && uikitFont.isFontLoaded) {
                const titleScale = LAYOUT_CONFIG.text.titleScale // Use configuration for text scale
                const titleMargins = LAYOUT_CONFIG.text.titleMargins // Use configuration for margins
                const panelCenterX = panelX + (panelWidth / 2)
                
                // MEDICAL IMAGING CONTROLS title (centered with configurable top margin)
                const title1 = 'MEDICAL IMAGING CONTROLS'
                const title1Width = title1.length * 5 // Approximate character width for centering
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelCenterX - title1Width, section1Y + titleMargins.medicalControls], // Use configuration margin
                    str: title1,
                    scale: titleScale,
                    color: LAYOUT_CONFIG.sections.titleColor // Use configuration color
                })
                
                // VIEW CONTROLS title (centered with configurable top margin)
                const title2 = 'VIEW CONTROLS'
                const title2Width = title2.length * 5
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelCenterX - title2Width, section2Y + titleMargins.viewControls], // Use configuration margin
                    str: title2,
                    scale: titleScale,
                    color: LAYOUT_CONFIG.sections.titleColor // Use configuration color
                })
                
                // ADVANCED CONTROLS title (centered with configurable top margin)
                const title3 = 'ADVANCED CONTROLS'
                const title3Width = title3.length * 5
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelCenterX - title3Width, section3Y + titleMargins.advancedControls], // Use configuration margin
                    str: title3,
                    scale: titleScale,
                    color: LAYOUT_CONFIG.sections.titleColor // Use configuration color
                })
                
                // ACTIONS title (centered with configurable top margin)
                const title4 = 'ACTIONS'
                const title4Width = title4.length * 5
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelCenterX - title4Width, section4Y + titleMargins.actions], // Use configuration margin
                    str: title4,
                    scale: titleScale,
                    color: LAYOUT_CONFIG.sections.titleColor // Use configuration color
                })
            }
            
            // Render all components
            Object.values(uikitComponents).forEach(component => {
                if (component && component.render) {
                if (typeof component.update === 'function') {
                    component.update()
                }
                component.render()
                }
            })
            
            // Restore WebGL state
            restoreGLState(gl, state)
        }

        // Main render loop
        function renderLoop() {
            if (nv) {
                // Render Niivue scene first
                nv.drawScene()
                
                // Render UIKit overlay components on the main canvas
                renderUIKitOverlay()
            }
            
            requestAnimationFrame(renderLoop)
        }

        // Navbar toggle event handler
        document.getElementById('navbar-toggle').addEventListener('click', () => {
            componentsVisible = !componentsVisible
            const toggleButton = document.getElementById('navbar-toggle')
            
            if (componentsVisible) {
                toggleButton.classList.remove('active')
                log('Components panel shown', 'info')
            } else {
                toggleButton.classList.add('active')
                log('Components panel hidden', 'info')
            }
        })

        // Button event handlers
        document.getElementById('reset-btn').addEventListener('click', () => {
            const initialParams = {
                brightness: 0.5,
                contrast: 0.5,
                zoom: 1.0,
                opacity: 1.0,
                slice: 0.5,
                crosshair: true,
                colorbar: true,
                radiological: false,
                interpolation: true,
                colormap: 'gray',
                viewMode: 'MultiPlanar'
            }
            
            Object.assign(medicalParams, initialParams)
            
            if (nv) {
                nv.setSliceType(nv.sliceTypeMultiplanar)
                nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                
                if (nv.volumes.length > 0) {
                    nv.volumes[0].cal_min = (1 - initialParams.brightness) * 100
                    nv.volumes[0].cal_max = 100 + ((1 - initialParams.contrast) * 200)
                    nv.volumes[0].opacity = initialParams.opacity
                    nv.volumes[0].colormap = initialParams.colormap
                }
                
                nv.scene.volScaleMultiplier = initialParams.zoom
                nv.scene.sagittalPos = initialParams.slice
                nv.scene.coronalPos = initialParams.slice
                nv.scene.axialPos = initialParams.slice
                
                nv.opts.show3Dcrosshair = initialParams.crosshair
                nv.opts.isColorbar = initialParams.colorbar
                nv.setRadiologicalConvention(initialParams.radiological)
                nv.setInterpolation(initialParams.interpolation)
                
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            if (uikitComponents.brightnessSlider) uikitComponents.brightnessSlider.setValue(initialParams.brightness)
            if (uikitComponents.contrastSlider) uikitComponents.contrastSlider.setValue(initialParams.contrast)
            if (uikitComponents.zoomSlider) uikitComponents.zoomSlider.setValue(initialParams.zoom)
            if (uikitComponents.opacitySlider) uikitComponents.opacitySlider.setValue(initialParams.opacity)
            if (uikitComponents.sliceSlider) uikitComponents.sliceSlider.setValue(initialParams.slice)
            if (uikitComponents.crosshairToggle) uikitComponents.crosshairToggle.setChecked(initialParams.crosshair)
            if (uikitComponents.colorbarToggle) uikitComponents.colorbarToggle.setChecked(initialParams.colorbar)
            if (uikitComponents.radiologicalToggle) uikitComponents.radiologicalToggle.setChecked(initialParams.radiological)
            if (uikitComponents.interpolationToggle) uikitComponents.interpolationToggle.setChecked(initialParams.interpolation)
            if (uikitComponents.viewModeSelector) uikitComponents.viewModeSelector.setSelectedMode(initialParams.viewMode)
            
            document.getElementById('brightness-value').textContent = Math.round(initialParams.brightness * 100) + '%'
            document.getElementById('contrast-value').textContent = Math.round(initialParams.contrast * 100) + '%'
            document.getElementById('zoom-value').textContent = Math.round(initialParams.zoom * 100) + '%'
            document.getElementById('opacity-value').textContent = Math.round(initialParams.opacity * 100) + '%'
            document.getElementById('slice-value').textContent = Math.round(initialParams.slice * 100) + '%'
            document.getElementById('crosshair-status').textContent = initialParams.crosshair ? 'Enabled' : 'Disabled'
            document.getElementById('colorbar-status').textContent = initialParams.colorbar ? 'Visible' : 'Hidden'
            document.getElementById('radiological-status').textContent = initialParams.radiological ? 'Enabled' : 'Disabled'
            document.getElementById('interpolation-status').textContent = initialParams.interpolation ? 'Enabled' : 'Disabled'
            
            document.getElementById('info-brightness').textContent = Math.round(initialParams.brightness * 100) + '%'
            document.getElementById('info-contrast').textContent = Math.round(initialParams.contrast * 100) + '%'
            document.getElementById('info-zoom').textContent = Math.round(initialParams.zoom * 100) + '%'
            document.getElementById('info-opacity').textContent = Math.round(initialParams.opacity * 100) + '%'
            document.getElementById('info-slice').textContent = Math.round(initialParams.slice * 100) + '%'
            document.getElementById('info-crosshair').textContent = initialParams.crosshair ? 'Enabled' : 'Disabled'
            document.getElementById('info-colorbar').textContent = initialParams.colorbar ? 'Visible' : 'Hidden'
            document.getElementById('info-radiological').textContent = initialParams.radiological ? 'Enabled' : 'Disabled'
            document.getElementById('info-interpolation').textContent = initialParams.interpolation ? 'Enabled' : 'Disabled'
            
            log('All parameters reset to initial defaults', 'info')
        })

        document.getElementById('save-btn').addEventListener('click', () => {
            localStorage.setItem('medicalImagingPreset', JSON.stringify(medicalParams))
            log('Preset saved to local storage', 'info')
        })

        document.getElementById('load-btn').addEventListener('click', () => {
            const saved = localStorage.getItem('medicalImagingPreset')
            if (saved) {
                const params = JSON.parse(saved)
                Object.assign(medicalParams, params)
                
                if (uikitComponents.brightnessSlider) uikitComponents.brightnessSlider.setValue(params.brightness)
                if (uikitComponents.contrastSlider) uikitComponents.contrastSlider.setValue(params.contrast)
                if (uikitComponents.zoomSlider) uikitComponents.zoomSlider.setValue(params.zoom)
                if (uikitComponents.opacitySlider) uikitComponents.opacitySlider.setValue(params.opacity)
                if (uikitComponents.sliceSlider) uikitComponents.sliceSlider.setValue(params.slice)
                if (uikitComponents.crosshairToggle) uikitComponents.crosshairToggle.setChecked(params.crosshair)
                if (uikitComponents.colorbarToggle) uikitComponents.colorbarToggle.setChecked(params.colorbar)
                if (uikitComponents.radiologicalToggle) uikitComponents.radiologicalToggle.setChecked(params.radiological)
                if (uikitComponents.interpolationToggle) uikitComponents.interpolationToggle.setChecked(params.interpolation)
                if (uikitComponents.colormapSelector) uikitComponents.colormapSelector.setSelectedColormap(params.colormap)
                if (uikitComponents.viewModeSelector) uikitComponents.viewModeSelector.setSelectedMode(params.viewMode)
                
                log('Preset loaded from local storage', 'info')
            } else {
                log('No saved preset found', 'warn')
            }
        })

        // Set up mouse event handling for UIKit components
        function setupMouseEventHandling() {
            const canvas = document.getElementById('gl1')
            
            canvas.addEventListener('mousedown', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('mousemove', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('mouseup', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('click', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
        }

        // Initialize everything
        window.addEventListener('load', async () => {
            log('Page loaded, starting initialization...', 'info')
            await initializeNiivue()
            setupMouseEventHandling()
            renderLoop()
        })

        // Handle window resize
        window.addEventListener('resize', () => {
            if (nv) {
                nv.resizeListener()
                log('Window resized, adjusting layout', 'info')
            }
        })

    </script>
</body>
</html> 