<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>UIKit Components Test - Medical Imaging Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #ffffff;
            overflow: hidden;
        }
        
        #container {
            display: block;
            height: 100vh;
            padding-top: 40px;
        }
        
        #canvas-container {
            width: 100%;
            height: calc(100vh - 40px);
            position: relative;
            background: #000;
        }
        
        #gl1 {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Enhanced Canvas Styling - Main canvas only */
        #gl1 {
            display: block !important;
            border: 2px solid #333 !important;
            border-radius: 6px !important;
            background: #1a1a1a !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            transition: all 0.2s ease !important;
        }
        
        #gl1:hover {
            border-color: #4CAF50 !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 8px rgba(76, 175, 80, 0.3) !important;
        }
        
        #log-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 250px;
            background: linear-gradient(145deg, #1a1a1a, #0d0d0d);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 11px;
            z-index: 1000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .log-entry {
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-info { 
            color: #4CAF50; 
            border-left-color: #4CAF50;
        }
        .log-warn { 
            color: #FF9800; 
            background: rgba(255, 152, 0, 0.1); 
            border-left-color: #FF9800;
        }
        .log-error { 
            color: #F44336; 
            background: rgba(244, 67, 54, 0.1); 
            border-left-color: #F44336;
        }
        .log-event { 
            color: #2196F3; 
            background: rgba(33, 150, 243, 0.1); 
            border-left-color: #2196F3;
        }
        
        #status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(90deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 13px;
            color: #ccc;
            z-index: 1000;
            border-bottom: 2px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .status-item {
            margin-right: 30px;
            display: flex;
            align-items: center;
        }
        
        .status-item::before {
            content: "‚óè";
            margin-right: 8px;
            color: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-value {
            color: #4CAF50;
            font-weight: bold;
            background: rgba(76, 175, 80, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="status-bar">
        <div class="status-item">UIKit Components Test - Medical Imaging</div>
        <div class="status-item">Status: <span class="status-value" id="status-text">Initializing...</span></div>
        <div class="status-item">WebGL: <span class="status-value" id="webgl-status">Checking...</span></div>
    </div>

    <div id="container">
        <div id="canvas-container">
            <canvas id="gl1"></canvas>
        </div>
                </div>
                
    <!-- Hidden HTML elements for value updates -->
    <div style="display: none;">
        <span id="brightness-value">50%</span>
        <span id="contrast-value">50%</span>
        <span id="zoom-value">100%</span>
        <span id="opacity-value">100%</span>
        <span id="slice-value">50%</span>
        <span id="crosshair-status">Enabled</span>
        <span id="colorbar-status">Visible</span>
        <span id="radiological-status">Disabled</span>
        <span id="interpolation-status">Enabled</span>
        <span id="info-brightness">50%</span>
        <span id="info-contrast">50%</span>
        <span id="info-zoom">100%</span>
        <span id="info-opacity">100%</span>
        <span id="info-slice">50%</span>
        <span id="info-crosshair">Enabled</span>
        <span id="info-colorbar">Visible</span>
        <span id="info-radiological">Disabled</span>
        <span id="info-interpolation">Enabled</span>
        
        <!-- Hidden buttons for functionality -->
                    <button id="reset-btn">Reset All</button>
                    <button id="save-btn">Save Preset</button>
                    <button id="load-btn">Load Preset</button>
    </div>
    
    <div id="log-panel" style="display: none;">
        <div class="log-entry log-info">UIKit Components Test Started</div>
        <div class="log-entry log-info">Initializing WebGL context...</div>
    </div>

    <script type="module">
        import * as niivue from '../niivue/dist/index.js'
        import { 
            UIKRenderer, 
            UIKFont,
            UIKSlider,
            UIKToggle,
            UIKPanel,
            UIKColormapSelector,
            UIKViewModeSelector,
            UIKButton
        } from '../uikit/dist/index.es.js'

        // Logging system
        let logsVisible = false
        
        function log(message, type = 'info') {
            const logPanel = document.getElementById('log-panel')
            const entry = document.createElement('div')
            entry.className = `log-entry log-${type}`
            entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`
            logPanel.appendChild(entry)
            logPanel.scrollTop = logPanel.scrollHeight
            console.log(`[${type.toUpperCase()}] ${message}`)
        }
        
        function toggleLogs() {
            const logPanel = document.getElementById('log-panel')
            logsVisible = !logsVisible
            logPanel.style.display = logsVisible ? 'block' : 'none'
            
            if (uikitComponents.logsButton) {
                uikitComponents.logsButton.setText(logsVisible ? 'üìã Hide' : 'üìã Logs')
            }
            
            log(`Logs panel ${logsVisible ? 'shown' : 'hidden'}`, 'event')
        }

        // Status updates
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text
            log(`Status: ${text}`)
        }

        // Global variables
        let nv = null
        let medicalParams = {
            brightness: 0.5,
            contrast: 0.5,
            zoom: 1.0,
            opacity: 1.0,
            slice: 0.5,
            crosshair: true,
            colorbar: true,
            radiological: false,
            interpolation: true,
            colormap: 'gray',
            viewMode: 'MultiPlanar'
        }

        // UIKit component instances
        let uikitComponents = {
            brightnessSlider: null,
            contrastSlider: null,
            zoomSlider: null,
            opacitySlider: null,
            sliceSlider: null,
            crosshairToggle: null,
            colorbarToggle: null,
            radiologicalToggle: null,
            interpolationToggle: null,
            colormapSelector: null,
            viewModeSelector: null,
            screenshotButton: null,
            backgroundButton: null,
            logsButton: null,
            resetButton: null
        }

        // Medical imaging state
        let currentBackground = 'dark' // dark, light

        // Global UIKit variables for single canvas approach
        let uikitRenderer = null
        let uikitFont = null

        // WebGL state management functions
        function saveGLState(gl) {
            return {
                viewport: new Int32Array(gl.getParameter(gl.VIEWPORT)),
                depthTest: gl.getParameter(gl.DEPTH_TEST),
                blend: gl.getParameter(gl.BLEND),
                blendFuncSrcRGB: gl.getParameter(gl.BLEND_SRC_RGB),
                blendFuncDstRGB: gl.getParameter(gl.BLEND_DST_RGB),
                blendFuncSrcAlpha: gl.getParameter(gl.BLEND_SRC_ALPHA),
                blendFuncDstAlpha: gl.getParameter(gl.BLEND_DST_ALPHA),
                scissorTest: gl.getParameter(gl.SCISSOR_TEST),
                scissorBox: new Int32Array(gl.getParameter(gl.SCISSOR_BOX)),
                framebuffer: gl.getParameter(gl.FRAMEBUFFER_BINDING),
                currentProgram: gl.getParameter(gl.CURRENT_PROGRAM)
            };
        }

        function restoreGLState(gl, state) {
            gl.viewport(state.viewport[0], state.viewport[1], state.viewport[2], state.viewport[3]);
            state.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST);
            state.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND);
            gl.blendFuncSeparate(
                state.blendFuncSrcRGB, state.blendFuncDstRGB,
                state.blendFuncSrcAlpha, state.blendFuncDstAlpha
            );
            state.scissorTest ? gl.enable(gl.SCISSOR_TEST) : gl.disable(gl.SCISSOR_TEST);
            gl.scissor(state.scissorBox[0], state.scissorBox[1], state.scissorBox[2], state.scissorBox[3]);
            gl.bindFramebuffer(gl.FRAMEBUFFER, state.framebuffer);
            gl.useProgram(state.currentProgram);
        }

        // Initialize Niivue with medical image and UIKit integration
        async function initializeNiivue() {
            try {
                updateStatus('Creating Niivue instance...')
                
                // Create Niivue with medical imaging optimized settings
                nv = new niivue.Niivue({
                    backColor: [0.1, 0.1, 0.1, 1],
                    show3Dcrosshair: true,
                    onLocationChange: handleLocationChange,
                    dragAndDropEnabled: true
                })
                
                // Configure for medical imaging
                nv.opts.isColorbar = true
                nv.setRadiologicalConvention(false)
                
                updateStatus('Attaching to canvas...')
                await nv.attachTo('gl1')
                
                // Check WebGL status
                const gl = nv.gl
                if (gl) {
                    document.getElementById('webgl-status').textContent = 'WebGL2 Ready'
                    log('WebGL2 context created successfully', 'info')
                } else {
                    throw new Error('Failed to create WebGL context')
                }
                
                updateStatus('Initializing UIKit on main canvas...')
                
                // Initialize UIKit renderer using the same WebGL context as Niivue
                uikitRenderer = new UIKRenderer(gl)
                uikitFont = new UIKFont(gl, [1, 1, 1, 1])
                await uikitFont.loadDefaultFont()
                
                log('UIKit renderer and font initialized on main canvas', 'info')
                
                updateStatus('Loading medical image...')
                
                // Try to load a medical brain image (MNI152 template)
                const volumeList = [{ 
                    url: 'https://niivue.github.io/niivue-demo-images/mni152.nii.gz',
                    colormap: 'gray',
                    opacity: 1.0,
                    visible: true
                }]
                
                try {
                    await nv.loadVolumes(volumeList)
                    log(`Medical image loaded: ${volumeList[0].url}`, 'info')
                    log(`Volume dimensions: ${nv.volumes[0].dims}`, 'info')
                    
                    // Set optimal view for medical imaging
                    nv.setSliceType(nv.sliceTypeMultiplanar)
                    nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                    nv.setRenderAzimuthElevation(120, 10)
                    
                    // Set rendering parameters for better visualization
                    nv.setInterpolation(true) // Smoother display
                    nv.opts.isColorbar = true
                    
                    // Configure slice positions for all three views
                    nv.scene.sagittalPos = 0.5
                    nv.scene.coronalPos = 0.5
                    nv.scene.axialPos = 0.5
                    
                    // Update the volume rendering
                    nv.updateGLVolume()
                    
                } catch (imageError) {
                    log(`Failed to load medical image: ${imageError.message}`, 'error')
                    log(`Attempted URL: ${volumeList[0].url}`, 'error')
                    log('Creating demo without medical image - UIKit components will still work', 'warn')
                    
                    // Set up basic view even without image
                    nv.setSliceType(nv.sliceTypeMultiplanar)
                    nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                    
                    updateStatus('Demo Ready - Drag and drop a NIfTI file to test')
                }
                
                log('Medical image loaded successfully', 'info')
                updateStatus('Creating UI overlay components...')
                
                // Wait for layout to be properly calculated before creating components
                setTimeout(async () => {
                    // Force canvas to update its dimensions
                    const canvas = document.getElementById('gl1')
                    canvas.width = canvas.clientWidth
                    canvas.height = canvas.clientHeight
                    
                    log(`Canvas dimensions: ${canvas.width}x${canvas.height}`, 'info')
                    
                    // Create UIKit components on the main canvas as overlays
                    await createUIKitOverlayComponents()
                    
                    updateStatus('Ready - Medical Imaging Interface with UIKit HUD Active')
                    log('All systems ready for medical imaging with integrated UIKit overlay', 'info')
                }, 500)
                
            } catch (error) {
                log(`Initialization error: ${error.message}`, 'error')
                updateStatus('Initialization Failed')
                document.getElementById('webgl-status').textContent = 'Error'
            }
        }

        // Handle location changes in medical image
        function handleLocationChange(data) {
            if (data && data.string) {
                log(`Location: ${data.string}`, 'event')
            }
        }

        // Create UIKit overlay components on the main Niivue canvas
        async function createUIKitOverlayComponents() {
            try {
                log('Creating UIKit overlay components on main Niivue canvas', 'info')
                
                // Get canvas dimensions for positioning
                const canvas = document.getElementById('gl1')
                const canvasWidth = canvas.width
                const canvasHeight = canvas.height
                
                // Define styled panel layout matching the original sidebar design
                const panelX = canvasWidth - 350 // Reduced panel width to 350px
                const panelY = 20 // 20px from top
                const panelWidth = 330 // Reduced panel width
                const sliderWidth = 180 // Reduced slider width to fit better
                const sliderHeight = 20 // Slightly reduced height
                
                // Section positioning to match the renderUIKitOverlay function
                let sectionY = panelY + 0
                
                // SECTION 1: Medical Imaging Controls (Sliders)
                const section1Y = sectionY + 30 // Account for section title
                let currentY = section1Y
                
                // Create brightness slider as overlay
                uikitComponents.brightnessSlider = new UIKSlider(uikitRenderer, {
                    bounds: [panelX + 20, currentY, sliderWidth, sliderHeight],
                            value: medicalParams.brightness,
                            min: 0,
                            max: 1,
                    label: 'Brightness',
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1], // Darker track for better contrast
                            fillColor: [0.0, 0.8, 0.0, 1], // Green theme
                        thumbColor: [1.0, 1.0, 1.0, 1], // White thumb
                        textColor: [1.0, 1.0, 1.0, 1]
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.brightness = value
                                updateBrightness(value)
                                document.getElementById('brightness-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-brightness').textContent = Math.round(value * 100) + '%'
                                log(`Brightness adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += 35
                
                // Create contrast slider as overlay
                uikitComponents.contrastSlider = new UIKSlider(uikitRenderer, {
                    bounds: [panelX + 20, currentY, sliderWidth, sliderHeight],
                            value: medicalParams.contrast,
                            min: 0,
                            max: 1,
                    label: 'Contrast',
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1], // Darker track
                            fillColor: [1.0, 0.6, 0.0, 1], // Orange theme
                        thumbColor: [1.0, 1.0, 1.0, 1], // White thumb
                        textColor: [1.0, 1.0, 1.0, 1]
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.contrast = value
                                updateContrast(value)
                                document.getElementById('contrast-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-contrast').textContent = Math.round(value * 100) + '%'
                                log(`Contrast adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += 35
                
                // Create zoom slider as overlay
                uikitComponents.zoomSlider = new UIKSlider(uikitRenderer, {
                    bounds: [panelX + 20, currentY, sliderWidth, sliderHeight],
                            value: medicalParams.zoom,
                            min: 0.1,
                            max: 5.0,
                    label: 'Zoom',
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1], // Darker track
                            fillColor: [0.0, 0.6, 1.0, 1], // Blue theme
                        thumbColor: [1.0, 1.0, 1.0, 1], // White thumb
                        textColor: [1.0, 1.0, 1.0, 1]
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.zoom = value
                                updateZoom(value)
                                document.getElementById('zoom-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-zoom').textContent = Math.round(value * 100) + '%'
                                log(`Zoom adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += 35
                
                // Create opacity slider as overlay
                uikitComponents.opacitySlider = new UIKSlider(uikitRenderer, {
                    bounds: [panelX + 20, currentY, sliderWidth, sliderHeight],
                            value: medicalParams.opacity,
                            min: 0,
                            max: 1,
                    label: 'Opacity',
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1], // Darker track
                            fillColor: [0.8, 0.0, 0.8, 1], // Purple theme
                        thumbColor: [1.0, 1.0, 1.0, 1], // White thumb
                        textColor: [1.0, 1.0, 1.0, 1]
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.opacity = value
                                updateOpacity(value)
                                document.getElementById('opacity-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-opacity').textContent = Math.round(value * 100) + '%'
                                log(`Opacity adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                currentY += 35
                
                // Create slice position slider as overlay
                uikitComponents.sliceSlider = new UIKSlider(uikitRenderer, {
                    bounds: [panelX + 20, currentY, sliderWidth, sliderHeight],
                            value: medicalParams.slice,
                            min: 0,
                            max: 1,
                    label: 'Slice Position',
                    style: {
                        trackColor: [0.4, 0.4, 0.4, 1], // Darker track
                            fillColor: [1.0, 1.0, 0.0, 1], // Yellow theme
                        thumbColor: [1.0, 1.0, 1.0, 1], // White thumb
                        textColor: [1.0, 1.0, 1.0, 1]
                    },
                    font: uikitFont,
                            onValueChange: (value) => {
                                medicalParams.slice = value
                                updateSlice(value)
                                document.getElementById('slice-value').textContent = Math.round(value * 100) + '%'
                                document.getElementById('info-slice').textContent = Math.round(value * 100) + '%'
                                log(`Slice position adjusted to ${Math.round(value * 100)}%`, 'event')
                            }
                        })
                        
                // SECTION 2: View Controls (Toggles)
                sectionY += 240 + 15 // Move to next section
                const section2Y = sectionY + 30 // Account for section title
                currentY = section2Y
                
                // Create crosshair toggle as overlay
                uikitComponents.crosshairToggle = new UIKToggle(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 120, 20], // Increased width for better label visibility
                            checked: medicalParams.crosshair,
                            type: 'switch',
                    label: 'Crosshair',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.crosshair = checked
                                updateCrosshair(checked)
                                document.getElementById('crosshair-status').textContent = checked ? 'Enabled' : 'Disabled'
                                document.getElementById('info-crosshair').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Crosshair ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                currentY += 30
                
                // Create colorbar toggle as overlay
                uikitComponents.colorbarToggle = new UIKToggle(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 120, 20],
                            checked: medicalParams.colorbar,
                            type: 'switch',
                    label: 'Colorbar',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.colorbar = checked
                                updateColorbar(checked)
                                document.getElementById('colorbar-status').textContent = checked ? 'Visible' : 'Hidden'
                                document.getElementById('info-colorbar').textContent = checked ? 'Visible' : 'Hidden'
                                log(`Colorbar ${checked ? 'shown' : 'hidden'}`, 'event')
                            }
                        })
                currentY += 30
                
                // Create radiological toggle as overlay
                uikitComponents.radiologicalToggle = new UIKToggle(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 120, 20],
                            checked: medicalParams.radiological,
                            type: 'switch',
                    label: 'Radiological',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.radiological = checked
                                updateRadiological(checked)
                                document.getElementById('radiological-status').textContent = checked ? 'Enabled' : 'Disabled'
                                document.getElementById('info-radiological').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Radiological convention ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                currentY += 30
                
                // Create interpolation toggle as overlay
                uikitComponents.interpolationToggle = new UIKToggle(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 120, 20],
                            checked: medicalParams.interpolation,
                            type: 'switch',
                    label: 'Interpolation',
                    font: uikitFont,
                            onToggle: (checked) => {
                                medicalParams.interpolation = checked
                                updateInterpolation(checked)
                                document.getElementById('interpolation-status').textContent = checked ? 'Enabled' : 'Disabled'
                                log(`Interpolation ${checked ? 'enabled' : 'disabled'}`, 'event')
                            }
                        })
                        
                // SECTION 3: Advanced Controls
                sectionY += 160 + 15 // Move to next section
                const section3Y = sectionY + 30 // Account for section title
                currentY = section3Y
                
                // Create colormap selector as overlay
                uikitComponents.colormapSelector = new UIKColormapSelector(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 280, 60], // Reduced height to fit better
                        selectedColormap: medicalParams.colormap,
                        colormaps: ['gray', 'plasma', 'viridis', 'inferno', 'hot', 'cool'],
                    font: uikitFont,
                        onColormapChange: updateColormap
                    })
                currentY += 80
                
                // Create view mode selector as overlay
                uikitComponents.viewModeSelector = new UIKViewModeSelector(uikitRenderer, {
                    bounds: [panelX + 20, currentY, 280, 50], // Reduced height to fit better
                        selectedMode: medicalParams.viewMode,
                        modes: ['Axial', 'Sagittal', 'Coronal', 'MultiPlanar'],
                    font: uikitFont,
                        onModeChange: updateViewMode
                    })
                    
                // SECTION 4: Action Buttons
                sectionY += 180 + 15 // Move to next section
                const section4Y = sectionY + 30 // Account for section title
                currentY = section4Y
                
                // Create action buttons in 2x2 grid layout
                const buttonWidth = 120 // Button width
                const buttonHeight = 35 // Increased height for better appearance
                const buttonGap = 10 // Gap between buttons
                const buttonsPerRow = 2
                
                // Calculate grid positions
                const gridStartX = panelX + 20
                const gridStartY = currentY
                
                // Row 1: Screenshot and Background buttons
                // Screenshot Button (top-left)
                uikitComponents.screenshotButton = new UIKButton(uikitRenderer, {
                    bounds: [gridStartX, gridStartY, buttonWidth, buttonHeight],
                    text: 'üì∑ Save',
                    font: uikitFont,
                    onClick: () => {
                        if (nv) {
                            // Force a complete render cycle to ensure UIKit overlay is visible
                            nv.drawScene()
                            renderUIKitOverlay()
                            
                            // Force WebGL to finish all operations
                            nv.gl.finish()
                            
                            // Take screenshot directly using canvas.toBlob for better control
                            const canvas = document.getElementById('gl1')
                            canvas.toBlob((blob) => {
                                if (!blob) {
                                    log('Failed to create screenshot', 'error')
                                    return
                                }
                                
                                const filename = 'MedicalImage_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png'
                                const a = document.createElement('a')
                                document.body.appendChild(a)
                                a.style.display = 'none'
                                const url = window.URL.createObjectURL(blob)
                                a.href = url
                                a.download = filename
                                a.click()
                                a.remove()
                                window.URL.revokeObjectURL(url)
                                
                                log('Screenshot saved with UIKit overlay', 'info')
                            })
                            }
                        },
                        style: {
                            backgroundColor: [0.15, 0.6, 0.95, 1.0],
                            hoverColor: [0.2, 0.7, 1.0, 1.0],
                            activeColor: [0.1, 0.5, 0.85, 1.0],
                            borderColor: [0.3, 0.8, 1.0, 1.0],
                            textColor: [1, 1, 1, 1],
                            borderWidth: 1,
                            borderRadius: 3,
                        padding: [12, 6],
                            shadowColor: [0, 0, 0, 0.3],
                            shadowOffset: [0, 2]
                        }
                    })
                    
                // Background Toggle Button (top-right)
                uikitComponents.backgroundButton = new UIKButton(uikitRenderer, {
                    bounds: [gridStartX + buttonWidth + buttonGap, gridStartY, buttonWidth, buttonHeight],
                        text: 'üåô Dark',
                    font: uikitFont,
                        onClick: () => {
                            if (nv) {
                                if (currentBackground === 'dark') {
                                    nv.opts.backColor = [1, 1, 1, 1] // White background
                                    currentBackground = 'light'
                                    uikitComponents.backgroundButton.setText('‚òÄÔ∏è Light')
                                } else {
                                    nv.opts.backColor = [0.1, 0.1, 0.1, 1] // Dark background
                                    currentBackground = 'dark'
                                    uikitComponents.backgroundButton.setText('üåô Dark')
                                }
                                nv.drawScene()
                                log(`Background changed to ${currentBackground}`, 'event')
                            }
                        },
                        style: {
                            backgroundColor: [0.6, 0.3, 0.9, 1.0],
                            hoverColor: [0.7, 0.4, 1.0, 1.0],
                            activeColor: [0.5, 0.2, 0.8, 1.0],
                            borderColor: [0.8, 0.5, 1.0, 1.0],
                            textColor: [1, 1, 1, 1],
                            borderWidth: 1,
                            borderRadius: 3,
                        padding: [12, 6],
                            shadowColor: [0, 0, 0, 0.3],
                            shadowOffset: [0, 2]
                        }
                    })
                    
                // Row 2: Logs and Reset buttons
                // Logs Button (bottom-left)
                uikitComponents.logsButton = new UIKButton(uikitRenderer, {
                    bounds: [gridStartX, gridStartY + buttonHeight + buttonGap, buttonWidth, buttonHeight],
                        text: 'üìã Logs',
                    font: uikitFont,
                        onClick: () => {
                            toggleLogs()
                        },
                        style: {
                            backgroundColor: [0.95, 0.6, 0.2, 1.0],
                            hoverColor: [1.0, 0.7, 0.3, 1.0],
                            activeColor: [0.85, 0.5, 0.15, 1.0],
                            borderColor: [1.0, 0.8, 0.4, 1.0],
                            textColor: [1, 1, 1, 1],
                            borderWidth: 1,
                            borderRadius: 3,
                        padding: [12, 6],
                            shadowColor: [0, 0, 0, 0.3],
                            shadowOffset: [0, 2]
                        }
                    })
                    
                // Reset All Button (bottom-right)
                uikitComponents.resetButton = new UIKButton(uikitRenderer, {
                    bounds: [gridStartX + buttonWidth + buttonGap, gridStartY + buttonHeight + buttonGap, buttonWidth, buttonHeight],
                        text: 'üîÑ Reset',
                    font: uikitFont,
                        onClick: () => {
                            document.getElementById('reset-btn').click()
                        },
                        style: {
                            backgroundColor: [0.9, 0.3, 0.3, 1.0],
                            hoverColor: [1.0, 0.4, 0.4, 1.0],
                            activeColor: [0.8, 0.2, 0.2, 1.0],
                            borderColor: [1.0, 0.5, 0.5, 1.0],
                            textColor: [1, 1, 1, 1],
                            borderWidth: 1,
                            borderRadius: 3,
                        padding: [12, 6],
                            shadowColor: [0, 0, 0, 0.3],
                            shadowOffset: [0, 2]
                        }
                    })
                    
                log('All UIKit overlay components created successfully on main canvas', 'info')
                
            } catch (error) {
                log(`Failed to create UIKit overlay components: ${error.message}`, 'error')
                throw error
            }
        }

        // Handle mouse events for UIKit overlay components on main canvas
        function handleUIKitMouseEvents(event) {
            if (!uikitRenderer) return false

            // Get canvas bounds for proper mouse coordinate calculation
            const canvas = document.getElementById('gl1')
                const rect = canvas.getBoundingClientRect()
            
            // Calculate proper mouse coordinates relative to canvas
            const mouseX = event.clientX - rect.left
            const mouseY = event.clientY - rect.top
            
            // Create a proper mouse event with correct coordinates
            const mouseEvent = {
                type: event.type,
                offsetX: mouseX,
                offsetY: mouseY,
                clientX: event.clientX,
                clientY: event.clientY,
                    target: canvas,
                preventDefault: () => event.preventDefault(),
                stopPropagation: () => event.stopPropagation()
            }

            let handled = false
            
            // Check each overlay component for mouse interaction
            for (const [name, component] of Object.entries(uikitComponents)) {
                if (component && component.handleMouseEvent) {
                    try {
                        if (component.handleMouseEvent(mouseEvent)) {
                            handled = true
                            log(`Mouse event handled by ${name}`, 'event')
                            break
                        }
                    } catch (error) {
                        log(`Error in ${name} mouse handler: ${error.message}`, 'error')
                    }
                }
            }
            
            return handled
        }

        // Medical imaging parameter update functions
        function updateBrightness(value) {
            medicalParams.brightness = value
            if (nv && nv.volumes && nv.volumes.length > 0) {
                nv.volumes[0].cal_min = (1 - value) * 100
                nv.updateGLVolume()
                nv.drawScene()
                log(`Brightness adjusted to ${Math.round(value * 100)}%`, 'event')
            }
            
            document.getElementById('brightness-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-brightness').textContent = `${Math.round(value * 100)}%`
        }

        function updateContrast(value) {
            medicalParams.contrast = value
            if (nv && nv.volumes.length > 0) {
                const baseMax = 100 + ((1 - value) * 200)
                nv.volumes[0].cal_max = baseMax
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('contrast-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-contrast').textContent = `${Math.round(value * 100)}%`
            log(`Contrast adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateZoom(value) {
            medicalParams.zoom = value
            if (nv) {
                nv.scene.volScaleMultiplier = value
                nv.drawScene()
            }
            
            document.getElementById('zoom-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-zoom').textContent = `${Math.round(value * 100)}%`
            log(`Zoom adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateOpacity(value) {
            medicalParams.opacity = value
            if (nv && nv.volumes.length > 0) {
                nv.volumes[0].opacity = value
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('opacity-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-opacity').textContent = `${Math.round(value * 100)}%`
            log(`Opacity adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateSlice(value) {
            medicalParams.slice = value
            if (nv) {
                nv.scene.sagittalPos = value
                nv.scene.coronalPos = value
                nv.scene.axialPos = value
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            document.getElementById('slice-value').textContent = `${Math.round(value * 100)}%`
            document.getElementById('info-slice').textContent = `${Math.round(value * 100)}%`
            log(`Slice position adjusted to ${Math.round(value * 100)}%`, 'event')
        }

        function updateCrosshair(checked) {
            medicalParams.crosshair = checked
            if (nv) {
                nv.opts.show3Dcrosshair = checked
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('crosshair-status').textContent = status
            document.getElementById('info-crosshair').textContent = status
            log(`Crosshair ${status.toLowerCase()}`, 'event')
        }

        function updateColorbar(checked) {
            medicalParams.colorbar = checked
            if (nv) {
                nv.opts.isColorbar = checked
                nv.drawScene()
            }
            
            const status = checked ? 'Visible' : 'Hidden'
            document.getElementById('colorbar-status').textContent = status
            document.getElementById('info-colorbar').textContent = status
            log(`Colorbar ${status.toLowerCase()}`, 'event')
        }

        function updateRadiological(checked) {
            medicalParams.radiological = checked
            if (nv) {
                nv.setRadiologicalConvention(checked)
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('radiological-status').textContent = status
            document.getElementById('info-radiological').textContent = status
            log(`Radiological ${status.toLowerCase()}`, 'event')
        }

        function updateInterpolation(checked) {
            medicalParams.interpolation = checked
            if (nv) {
                nv.setInterpolation(checked)
                nv.drawScene()
            }
            
            const status = checked ? 'Enabled' : 'Disabled'
            document.getElementById('interpolation-status').textContent = status
            document.getElementById('info-interpolation').textContent = status
            log(`Interpolation ${status.toLowerCase()}`, 'event')
        }

        function updateColormap(colormap) {
            medicalParams.colormap = colormap
            if (nv) {
                nv.volumes[0].colormap = colormap
                nv.updateGLVolume()
                nv.drawScene()
            }
            log(`Colormap changed to ${colormap}`, 'event')
        }

        function updateViewMode(mode) {
            medicalParams.viewMode = mode
            if (nv) {
                let sliceType
                switch (mode) {
                    case 'Axial':
                        sliceType = nv.sliceTypeAxial
                        break
                    case 'Coronal':
                        sliceType = nv.sliceTypeCoronal
                        break
                    case 'Sagittal':
                        sliceType = nv.sliceTypeSagittal
                        break
                    case 'Render':
                        sliceType = nv.sliceTypeRender
                        break
                    case 'MultiPlanar':
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.NEVER
                        break
                    case 'MultiPlanarRender':
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                        break
                    default:
                        sliceType = nv.sliceTypeMultiplanar
                        nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                }
                
                nv.setSliceType(sliceType)
                nv.drawScene()
                log(`View mode applied: ${mode}`, 'debug')
            }
            log(`View mode changed to ${mode}`, 'event')
        }

        // Updated render loop for UIKit overlay components with proper styling
        function renderUIKitOverlay() {
            if (!uikitRenderer || !uikitFont) return
            
            // Get WebGL context and save current state
            const gl = nv.gl
            const canvas = document.getElementById('gl1')
            const state = saveGLState(gl)
            
            // Set UIKit rendering state
            gl.viewport(0, 0, canvas.width, canvas.height)
            gl.disable(gl.DEPTH_TEST)
            gl.enable(gl.BLEND)
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
            
            // Define UI panel dimensions and position
            const panelX = canvas.width - 350
            const panelY = 20
            const panelWidth = 330
            const panelHeight = canvas.height - 40
            
            // Draw main panel background with gradient effect
            const backgroundColor = [0.12, 0.12, 0.12, 0.95]
            const gradientEnd = [0.16, 0.16, 0.16, 0.95]
            
            for (let i = 0; i < panelHeight; i++) {
                const gradientFactor = i / panelHeight
                const bgColor = [
                    backgroundColor[0] + (gradientEnd[0] - backgroundColor[0]) * gradientFactor,
                    backgroundColor[1] + (gradientEnd[1] - backgroundColor[1]) * gradientFactor,
                    backgroundColor[2] + (gradientEnd[2] - backgroundColor[2]) * gradientFactor,
                    backgroundColor[3]
                ]
                uikitRenderer.drawLine({
                    startEnd: [panelX - 10, panelY - 10 + i, panelX - 10 + panelWidth + 20, panelY - 10 + i],
                    thickness: 1,
                    color: bgColor
                })
            }
            
            // Draw panel shadow effect
            for (let i = 1; i <= 5; i++) {
                const shadowAlpha = 0.5 * (1 - (i - 1) / 4)
                uikitRenderer.drawLine({
                    startEnd: [panelX - 10 - i, panelY - 10, panelX - 10 - i, panelY - 10 + panelHeight],
                    thickness: 1,
                    color: [0, 0, 0, shadowAlpha]
                })
            }
            
            // Draw panel border
            uikitRenderer.drawLine({
                startEnd: [panelX - 10, panelY - 10, panelX - 10, panelY - 10 + panelHeight],
                thickness: 1,
                color: [0.27, 0.27, 0.27, 1.0]
            })
            
            // Section styling
            const sectionBgColor = [0.18, 0.22, 0.28, 0.9]
            const sectionBorderColor = [0.29, 0.33, 0.41, 1.0]
            const titleColor = [0.41, 0.83, 0.57, 1.0]
            
            // SECTION 1: Medical Imaging Controls
            const section1Y = panelY
            const section1Height = 240
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section1Y, panelWidth - 10, section1Height],
                fillColor: sectionBgColor,
                outlineColor: sectionBorderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 2: View Controls
            const section2Y = section1Y + section1Height + 15
            const section2Height = 160
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section2Y, panelWidth - 10, section2Height],
                fillColor: sectionBgColor,
                outlineColor: sectionBorderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 3: Advanced Controls
            const section3Y = section2Y + section2Height + 15
            const section3Height = 180
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section3Y, panelWidth - 10, section3Height],
                fillColor: sectionBgColor,
                outlineColor: sectionBorderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // SECTION 4: Actions
            const section4Y = section3Y + section3Height + 15
            const section4Height = 200
            uikitRenderer.drawRoundedRect({
                bounds: [panelX + 5, section4Y, panelWidth - 10, section4Height],
                fillColor: sectionBgColor,
                outlineColor: sectionBorderColor,
                cornerRadius: 8,
                thickness: 1
            })
            
            // Draw section titles
            if (uikitFont && uikitFont.isFontLoaded) {
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelX + 15, section1Y + 18],
                    str: '‚ö° MEDICAL IMAGING CONTROLS',
                    scale: 0.7,
                    color: titleColor
                })
                
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelX + 15, section2Y + 18],
                    str: 'üëÅ VIEW CONTROLS',
                    scale: 0.7,
                    color: titleColor
                })
                
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelX + 15, section3Y + 18],
                    str: 'üîß ADVANCED CONTROLS',
                    scale: 0.7,
                    color: titleColor
                })
                
                uikitRenderer.drawRotatedText({
                    font: uikitFont,
                    xy: [panelX + 15, section4Y + 18],
                    str: '‚öôÔ∏è ACTIONS',
                    scale: 0.7,
                    color: titleColor
                })
            }
            
            // Render all components
            Object.values(uikitComponents).forEach(component => {
                if (component && component.render) {
                if (typeof component.update === 'function') {
                    component.update()
                }
                component.render()
                }
            })
            
            // Restore WebGL state
            restoreGLState(gl, state)
        }

        // Main render loop
        function renderLoop() {
            if (nv) {
                // Render Niivue scene first
                nv.drawScene()
                
                // Render UIKit overlay components on the main canvas
                renderUIKitOverlay()
            }
            
            requestAnimationFrame(renderLoop)
        }

        // Button event handlers
        document.getElementById('reset-btn').addEventListener('click', () => {
            const initialParams = {
                brightness: 0.5,
                contrast: 0.5,
                zoom: 1.0,
                opacity: 1.0,
                slice: 0.5,
                crosshair: true,
                colorbar: true,
                radiological: false,
                interpolation: true,
                colormap: 'gray',
                viewMode: 'MultiPlanar'
            }
            
            Object.assign(medicalParams, initialParams)
            
            if (nv) {
                nv.setSliceType(nv.sliceTypeMultiplanar)
                nv.opts.multiplanarShowRender = niivue.SHOW_RENDER.ALWAYS
                
                if (nv.volumes.length > 0) {
                    nv.volumes[0].cal_min = (1 - initialParams.brightness) * 100
                    nv.volumes[0].cal_max = 100 + ((1 - initialParams.contrast) * 200)
                    nv.volumes[0].opacity = initialParams.opacity
                    nv.volumes[0].colormap = initialParams.colormap
                }
                
                nv.scene.volScaleMultiplier = initialParams.zoom
                nv.scene.sagittalPos = initialParams.slice
                nv.scene.coronalPos = initialParams.slice
                nv.scene.axialPos = initialParams.slice
                
                nv.opts.show3Dcrosshair = initialParams.crosshair
                nv.opts.isColorbar = initialParams.colorbar
                nv.setRadiologicalConvention(initialParams.radiological)
                nv.setInterpolation(initialParams.interpolation)
                
                nv.updateGLVolume()
                nv.drawScene()
            }
            
            if (uikitComponents.brightnessSlider) uikitComponents.brightnessSlider.setValue(initialParams.brightness)
            if (uikitComponents.contrastSlider) uikitComponents.contrastSlider.setValue(initialParams.contrast)
            if (uikitComponents.zoomSlider) uikitComponents.zoomSlider.setValue(initialParams.zoom)
            if (uikitComponents.opacitySlider) uikitComponents.opacitySlider.setValue(initialParams.opacity)
            if (uikitComponents.sliceSlider) uikitComponents.sliceSlider.setValue(initialParams.slice)
            if (uikitComponents.crosshairToggle) uikitComponents.crosshairToggle.setChecked(initialParams.crosshair)
            if (uikitComponents.colorbarToggle) uikitComponents.colorbarToggle.setChecked(initialParams.colorbar)
            if (uikitComponents.radiologicalToggle) uikitComponents.radiologicalToggle.setChecked(initialParams.radiological)
            if (uikitComponents.interpolationToggle) uikitComponents.interpolationToggle.setChecked(initialParams.interpolation)
            if (uikitComponents.viewModeSelector) uikitComponents.viewModeSelector.setSelectedMode(initialParams.viewMode)
            
            document.getElementById('brightness-value').textContent = Math.round(initialParams.brightness * 100) + '%'
            document.getElementById('contrast-value').textContent = Math.round(initialParams.contrast * 100) + '%'
            document.getElementById('zoom-value').textContent = Math.round(initialParams.zoom * 100) + '%'
            document.getElementById('opacity-value').textContent = Math.round(initialParams.opacity * 100) + '%'
            document.getElementById('slice-value').textContent = Math.round(initialParams.slice * 100) + '%'
            document.getElementById('crosshair-status').textContent = initialParams.crosshair ? 'Enabled' : 'Disabled'
            document.getElementById('colorbar-status').textContent = initialParams.colorbar ? 'Visible' : 'Hidden'
            document.getElementById('radiological-status').textContent = initialParams.radiological ? 'Enabled' : 'Disabled'
            document.getElementById('interpolation-status').textContent = initialParams.interpolation ? 'Enabled' : 'Disabled'
            
            document.getElementById('info-brightness').textContent = Math.round(initialParams.brightness * 100) + '%'
            document.getElementById('info-contrast').textContent = Math.round(initialParams.contrast * 100) + '%'
            document.getElementById('info-zoom').textContent = Math.round(initialParams.zoom * 100) + '%'
            document.getElementById('info-opacity').textContent = Math.round(initialParams.opacity * 100) + '%'
            document.getElementById('info-slice').textContent = Math.round(initialParams.slice * 100) + '%'
            document.getElementById('info-crosshair').textContent = initialParams.crosshair ? 'Enabled' : 'Disabled'
            document.getElementById('info-colorbar').textContent = initialParams.colorbar ? 'Visible' : 'Hidden'
            document.getElementById('info-radiological').textContent = initialParams.radiological ? 'Enabled' : 'Disabled'
            document.getElementById('info-interpolation').textContent = initialParams.interpolation ? 'Enabled' : 'Disabled'
            
            log('All parameters reset to initial defaults', 'info')
        })

        document.getElementById('save-btn').addEventListener('click', () => {
            localStorage.setItem('medicalImagingPreset', JSON.stringify(medicalParams))
            log('Preset saved to local storage', 'info')
        })

        document.getElementById('load-btn').addEventListener('click', () => {
            const saved = localStorage.getItem('medicalImagingPreset')
            if (saved) {
                const params = JSON.parse(saved)
                Object.assign(medicalParams, params)
                
                if (uikitComponents.brightnessSlider) uikitComponents.brightnessSlider.setValue(params.brightness)
                if (uikitComponents.contrastSlider) uikitComponents.contrastSlider.setValue(params.contrast)
                if (uikitComponents.zoomSlider) uikitComponents.zoomSlider.setValue(params.zoom)
                if (uikitComponents.opacitySlider) uikitComponents.opacitySlider.setValue(params.opacity)
                if (uikitComponents.sliceSlider) uikitComponents.sliceSlider.setValue(params.slice)
                if (uikitComponents.crosshairToggle) uikitComponents.crosshairToggle.setChecked(params.crosshair)
                if (uikitComponents.colorbarToggle) uikitComponents.colorbarToggle.setChecked(params.colorbar)
                if (uikitComponents.radiologicalToggle) uikitComponents.radiologicalToggle.setChecked(params.radiological)
                if (uikitComponents.interpolationToggle) uikitComponents.interpolationToggle.setChecked(params.interpolation)
                if (uikitComponents.colormapSelector) uikitComponents.colormapSelector.setSelectedColormap(params.colormap)
                if (uikitComponents.viewModeSelector) uikitComponents.viewModeSelector.setSelectedMode(params.viewMode)
                
                log('Preset loaded from local storage', 'info')
            } else {
                log('No saved preset found', 'warn')
            }
        })

        // Set up mouse event handling for UIKit components
        function setupMouseEventHandling() {
            const canvas = document.getElementById('gl1')
            
            canvas.addEventListener('mousedown', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('mousemove', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('mouseup', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
            
            canvas.addEventListener('click', (event) => {
                const handled = handleUIKitMouseEvents(event)
                if (handled) {
                    event.preventDefault()
                    event.stopPropagation()
                }
            })
        }

        // Initialize everything
        window.addEventListener('load', async () => {
            log('Page loaded, starting initialization...', 'info')
            await initializeNiivue()
            setupMouseEventHandling()
            renderLoop()
        })

        // Handle window resize
        window.addEventListener('resize', () => {
            if (nv) {
                nv.resizeListener()
                log('Window resized, adjusting layout', 'info')
            }
        })

    </script>
</body>
</html> 