<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>NiiVue Clip Mode Demo</title>
    <link rel="stylesheet" href="niivue.css" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
    <style>
      body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
      header { padding: 8px; display:flex; gap:10px; align-items:center; background:#1b415f; color:white; }
      #controls { display:flex; gap:10px; align-items:center; }
      #controls button { padding:6px 10px; font-size:14px; }
      main { width:100vw; height:calc(100vh - 56px); }
      canvas { width:100%; height:100%; display:block; }
    </style>
  </head>
  <body>
    <header>
      <button id="openBtn">Open NIfTI</button>
      <div id="controls">
        <button id="toggleModeBtn">Mode: corner</button>
        <button id="setBoxBtn" style="display:none">Set Box (example)</button>
      </div>
      <div style="margin-left:auto; color:#cfe8ff; font-size:0.9rem">Simple demo: AND vs CORNER modes</div>
    </header>

    <main id="canvas-container">
      <canvas id="gl1"></canvas>
    </main>

    <script type="module">
      import { Niivue, SHOW_RENDER, DRAG_MODE } from './niivue/index.ts'

     





      /**
     * Set six axis-aligned clip planes forming a box from min..max in sample space.
     * min, max: numbers in sample space (0..1)
     * nv1: your Niivue instance
     */
    function setBoxClipPlanes(nv1, min = 0.0, max = 1.0) {
      // compute depth distances from center (0.5)
      const depthLeft   = 0.5 - min; // +X face (keep X >= min)
      const depthRight  = max - 0.5; // -X face (keep X <= max)
      const depthBack   = 0.5 - min; // +Y face (keep Y >= min / posterior)
      const depthFront  = max - 0.5; // -Y face (keep Y <= max / anterior)
      const depthBottom = 0.5 - min; // +Z face (keep Z >= min / inferior)
      const depthTop    = max - 0.5; // -Z face (keep Z <= max / superior)

      const boxPlanes = [
        // Y axis (posterior ↔ anterior)
        [0.25, 270,  0], // Y−  normal −Y (posterior)
        [0.15,  90,  0], // Y+  normal +Y (anterior)

        // X axis (left ↔ right)
        [0.15,   0,  0], // X−  normal −X (left)
        [0.20, 180,  0], // X+  normal +X (right)

        // Z axis (inferior ↔ superior)
        [0.40,   0, -90], // Z−  normal −Z (bottom)
        [0.20,   0,  90]  // Z+  normal +Z (top)
      ];

      nv1.setClipPlaneMode('slides');     // opts-only update
      nv1.setClipPlanes(boxPlanes);    // replaces scene.clipPlanes etc.
      



      nv1.drawScene();
    }

    function planeCoord(p) {
      const [nx,ny,nz,w] = p;
      if (Math.abs(nx) > 0.9) return { axis:'X', coord: 0.5 - w / nx };
      if (Math.abs(ny) > 0.9) return { axis:'Y', coord: 0.5 - w / ny };
      if (Math.abs(nz) > 0.9) return { axis:'Z', coord: 0.5 - w / nz };
      return { axis:'?', coord: NaN };
    }

    function sanitizePlanesAndReport(nv1, eps = 1e-6) {
      let planes = (nv1.scene.clipPlanes || []).map(p => p.map(v => (Math.abs(v) < eps ? 0 : v)));
      // flip any with w > 0 so center is inside
      planes = planes.map(p => (p[3] > 0 ? p.map(v => -v) : p));
      // assign to axes
      const axisMap = { X: [], Y: [], Z: [], OTHER: [] };
      planes.forEach((p,i) => {
        const [nx,ny,nz] = p;
        if (Math.abs(nx) > 0.9) axisMap.X.push({i,p});
        else if (Math.abs(ny) > 0.9) axisMap.Y.push({i,p});
        else if (Math.abs(nz) > 0.9) axisMap.Z.push({i,p});
        else axisMap.OTHER.push({i,p});
      });
      console.log('axisMap', axisMap);
      // compute coords
      function coords(list) {
        return list.map(o => ({ idx:o.i, ...planeCoord(o.p) }));
      }
      console.log('X coords', coords(axisMap.X));
      console.log('Y coords', coords(axisMap.Y));
      console.log('Z coords', coords(axisMap.Z));
      // report if any axis lacks two opposing planes
      ['X','Y','Z'].forEach(a=>{
        if (axisMap[a].length !== 2) console.warn(`axis ${a} has ${axisMap[a].length} planes (expected 2).`);
      });

      // install flipped planes back
      nv1.scene.clipPlanes = planes;
      nv1.scene.clipPlaneCount = planes.length;
      nv1.drawScene();
      return { planes, axisMap };
    }
        


      // basic defaults (no mesh/fiber code)
      const defaults = {
        backColor: [0, 0.2, 0.4, 1],
        show3Dcrosshair: true,
        loglevel: 'debug',
        isRuler: true,
        dragMode: DRAG_MODE.measurement,
        isColorbar: true,
        // start in 'corner' as your earlier default
        clipPlaneMode: 'corner'
      };

      const nv1 = new Niivue(defaults);
      await nv1.attachToCanvas(gl1);
      nv1.opts.multiplanarShowRender = SHOW_RENDER.AUTO;
      nv1.opts.yoke3Dto2DZoom = true;

      // load a demo volume
      await nv1.loadVolumes([{ url: '../demos/images/mni152.nii.gz' }]);
      nv1.setSliceType(nv1.sliceTypeRender);
      nv1.setClipPlaneThick(1.0);
      // example planes (depth/azimuth/elevation triplets) — you can replace these
      const depthAziElevs = [
        [0.2, 270, 0],  // X min (left)
        [0.2,   0, 0],  // Y min (posterior)
        [0.2,   0, 90]  // Z max (superior)
      ];
      nv1.setClipPlanes(depthAziElevs);

      // ensure UI reflects starting mode
      const toggleModeBtn = document.getElementById('toggleModeBtn');
      function updateModeButtonText() {
        toggleModeBtn.textContent = `Mode: ${nv1.opts.clipPlaneMode}`;
      }
      updateModeButtonText();

      // open file dialog
      openBtn.onclick = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.nii,.nii.gz';
        input.onchange = (e) => {
          if (e.target.files && e.target.files[0]) nv1.loadFromFile(e.target.files[0]);
        };
        input.click();
      };

      // toggle between 'corner', 'and', and 'slides'
      toggleModeBtn.onclick = () => {
        const cur = nv1.opts.clipPlaneMode || 'corner';
        let next = 'corner';
        if (cur === 'corner') next = 'and';
        else if (cur === 'and') next = 'slides';
        else next = 'corner';

        if (next === 'corner') {
          // restore simple triplet set (3 planes)
          const depthAziElevs = [
            [0.2, 270, 0],
            [0.2,   0, 0],
            [0.2,   0, 90]
          ];
          nv1.setClipPlanes(depthAziElevs);
        } else if (next === 'and' || next === 'slides') {
          // install full 6-plane box
          const min = 0.2, max = 0.8;
          const dLeft = 0.5 - min, dRight = max - 0.5,
                dBack = 0.5 - min, dFront = max - 0.5,
                dBottom = 0.5 - min, dTop = max - 0.5;
          const boxPlanes = [
            [dBack, 270,  0],
            [dFront, 90,  0],
            [dLeft, 180,  0],
            [dRight, 0,  0],
            [dBottom, 0, -90],
            [dTop, 0, 90]
          ];
          nv1.setClipPlanes(boxPlanes);
        }

        nv1.setClipPlaneMode(next);
        updateModeButtonText();
        // updatePlaneVisualization(nv1);
        nv1.drawScene();
      };


      // quick "set box" helper: sets 6 axis-aligned planes for AND mode (example)
      setBoxBtn.onclick = () => {
        // updates this.opts only per your design
        setBoxClipPlanes(nv1, 0.2, 0.8);
        nv1.drawScene();
      };


      // initial draw
      nv1.drawScene();
    </script>
  </body>
</html>

