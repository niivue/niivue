<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>nvdocument.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="NVController.html">NVController</a><ul class='methods'><li data-type='method'><a href="NVController.html#connectToSession">connectToSession</a></li><li data-type='method'><a href="NVController.html#onAzimuthElevationChangeHandler">onAzimuthElevationChangeHandler</a></li><li data-type='method'><a href="NVController.html#onClipPlaneChangeHandler">onClipPlaneChangeHandler</a></li><li data-type='method'><a href="NVController.html#onColormapChangeHandler">onColormapChangeHandler</a></li><li data-type='method'><a href="NVController.html#onCustomMeshShaderAddedHandler">onCustomMeshShaderAddedHandler</a></li><li data-type='method'><a href="NVController.html#onFrameChangeHandler">onFrameChangeHandler</a></li><li data-type='method'><a href="NVController.html#onImageLoadedHandler">onImageLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshAddedFromUrlHandler">onMeshAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onMeshLoadedHandler">onMeshLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshPropertyChanged">onMeshPropertyChanged</a></li><li data-type='method'><a href="NVController.html#onMeshShaderChanged">onMeshShaderChanged</a></li><li data-type='method'><a href="NVController.html#onOpacityChangeHandler">onOpacityChangeHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeAddedFromUrlHandler">onVolumeAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeWithUrlRemovedHandler">onVolumeWithUrlRemovedHandler</a></li><li data-type='method'><a href="NVController.html#onZoom3DChangeHandler">onZoom3DChangeHandler</a></li></ul></li><li><a href="NVDocument.html">NVDocument</a><ul class='methods'><li data-type='method'><a href="NVDocument.html#addImageOptions">addImageOptions</a></li><li data-type='method'><a href="NVDocument.html#download">download</a></li><li data-type='method'><a href="NVDocument.html#getImageOptions">getImageOptions</a></li><li data-type='method'><a href="NVDocument.html#hasImage">hasImage</a></li><li data-type='method'><a href="NVDocument.html#hasImageFromUrl">hasImageFromUrl</a></li><li data-type='method'><a href="NVDocument.html#json">json</a></li><li data-type='method'><a href="NVDocument.html#removeImage">removeImage</a></li><li data-type='method'><a href="NVDocument.html#.deserializeMeshDataObjects">deserializeMeshDataObjects</a></li><li data-type='method'><a href="NVDocument.html#.loadFromJSON">loadFromJSON</a></li></ul></li><li></li><li></li><li><a href="NVImage.html">NVImage</a><ul class='methods'><li data-type='method'><a href="NVImage.html#applyOptionsUpdate">applyOptionsUpdate</a></li><li data-type='method'><a href="NVImage.html#clone">clone</a></li><li data-type='method'><a href="NVImage.html#getImageMetadata">getImageMetadata</a></li><li data-type='method'><a href="NVImage.html#toNiivueObject3D">toNiivueObject3D</a></li><li data-type='method'><a href="NVImage.html#toUint8Array">toUint8Array</a></li><li data-type='method'><a href="NVImage.html#zeroImage">zeroImage</a></li><li data-type='method'><a href="NVImage.html#.zerosLike">zerosLike</a></li></ul></li><li></li><li></li><li></li><li><a href="global.html#NVImageFromUrlOptions">NVImageFromUrlOptions</a></li><li><a href="NVMesh.html">NVMesh</a><ul class='methods'><li data-type='method'><a href="NVMesh.html#.loadFromBase64">loadFromBase64</a></li><li data-type='method'><a href="NVMesh.html#.loadFromFile">loadFromFile</a></li><li data-type='method'><a href="NVMesh.html#.loadFromUrl">loadFromUrl</a></li></ul></li><li><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li><a href="NVMessage.html">NVMessage</a></li><li><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li><a href="NVUtilities.html">NVUtilities</a></li><li><a href="Niivue.html">Niivue</a><ul class='methods'><li data-type='method'><a href="Niivue.html#addColormap">addColormap</a></li><li data-type='method'><a href="Niivue.html#addMesh">addMesh</a></li><li data-type='method'><a href="Niivue.html#addMeshFromUrl">addMeshFromUrl</a></li><li data-type='method'><a href="Niivue.html#addVolume">addVolume</a></li><li data-type='method'><a href="Niivue.html#addVolumeFromUrl">addVolumeFromUrl</a></li><li data-type='method'><a href="Niivue.html#attachTo">attachTo</a></li><li data-type='method'><a href="Niivue.html#attachToCanvas">attachToCanvas</a></li><li data-type='method'><a href="Niivue.html#calculateMinMaxVoxIdx">calculateMinMaxVoxIdx</a></li><li data-type='method'><a href="Niivue.html#cloneVolume">cloneVolume</a></li><li data-type='method'><a href="Niivue.html#closeDrawing">closeDrawing</a></li><li data-type='method'><a href="Niivue.html#colormaps">colormaps</a></li><li data-type='method'><a href="Niivue.html#createCustomMeshShader">createCustomMeshShader</a></li><li data-type='method'><a href="Niivue.html#createEmptyDrawing">createEmptyDrawing</a></li><li data-type='method'><a href="Niivue.html#drawGrowCut">drawGrowCut</a></li><li data-type='method'><a href="Niivue.html#drawMosaic">drawMosaic</a></li><li data-type='method'><a href="Niivue.html#drawOtsu">drawOtsu</a></li><li data-type='method'><a href="Niivue.html#drawUndo">drawUndo</a></li><li data-type='method'><a href="Niivue.html#getDescriptives">getDescriptives</a></li><li data-type='method'><a href="Niivue.html#getFrame4D">getFrame4D</a></li><li data-type='method'><a href="Niivue.html#getMediaByUrl">getMediaByUrl</a></li><li data-type='method'><a href="Niivue.html#getOverlayIndexByID">getOverlayIndexByID</a></li><li data-type='method'><a href="Niivue.html#getRadiologicalConvention">getRadiologicalConvention</a></li><li data-type='method'><a href="Niivue.html#getVolumeIndexByID">getVolumeIndexByID</a></li><li data-type='method'><a href="Niivue.html#isMeshExt">isMeshExt</a></li><li data-type='method'><a href="Niivue.html#loadConnectome">loadConnectome</a></li><li data-type='method'><a href="Niivue.html#loadDeferred4DVolumes">loadDeferred4DVolumes</a></li><li data-type='method'><a href="Niivue.html#loadDocument">loadDocument</a></li><li data-type='method'><a href="Niivue.html#loadDocumentFromUrl">loadDocumentFromUrl</a></li><li data-type='method'><a href="Niivue.html#loadDrawingFromUrl">loadDrawingFromUrl</a></li><li data-type='method'><a href="Niivue.html#loadFont">loadFont</a></li><li data-type='method'><a href="Niivue.html#loadMatCapTexture">loadMatCapTexture</a></li><li data-type='method'><a href="Niivue.html#loadMeshes">loadMeshes</a></li><li data-type='method'><a href="Niivue.html#loadVolumes">loadVolumes</a></li><li data-type='method'><a href="Niivue.html#meshShaderNames">meshShaderNames</a></li><li data-type='method'><a href="Niivue.html#moveCrosshairInVox">moveCrosshairInVox</a></li><li data-type='method'><a href="Niivue.html#moveVolumeDown">moveVolumeDown</a></li><li data-type='method'><a href="Niivue.html#moveVolumeToBottom">moveVolumeToBottom</a></li><li data-type='method'><a href="Niivue.html#moveVolumeToTop">moveVolumeToTop</a></li><li data-type='method'><a href="Niivue.html#moveVolumeUp">moveVolumeUp</a></li><li data-type='method'><a href="Niivue.html#off">off</a></li><li data-type='method'><a href="Niivue.html#on">on</a></li><li data-type='method'><a href="Niivue.html#onAzimuthElevationChange">onAzimuthElevationChange</a></li><li data-type='method'><a href="Niivue.html#onClipPlaneChange">onClipPlaneChange</a></li><li data-type='method'><a href="Niivue.html#onDebug">onDebug</a></li><li data-type='method'><a href="Niivue.html#onDocumentLoaded">onDocumentLoaded</a></li><li data-type='method'><a href="Niivue.html#onDragRelease">onDragRelease</a></li><li data-type='method'><a href="Niivue.html#onError">onError</a></li><li data-type='method'><a href="Niivue.html#onFrameChange">onFrameChange</a></li><li data-type='method'><a href="Niivue.html#onImageLoaded">onImageLoaded</a></li><li data-type='method'><a href="Niivue.html#onInfo">onInfo</a></li><li data-type='method'><a href="Niivue.html#onIntensityChange">onIntensityChange</a></li><li data-type='method'><a href="Niivue.html#onLocationChange">onLocationChange</a></li><li data-type='method'><a href="Niivue.html#onMeshAddedFromUrl">onMeshAddedFromUrl</a></li><li data-type='method'><a href="Niivue.html#onMeshLoaded">onMeshLoaded</a></li><li data-type='method'><a href="Niivue.html#onMouseUp">onMouseUp</a></li><li data-type='method'><a href="Niivue.html#onVolumeAddedFromUrl">onVolumeAddedFromUrl</a></li><li data-type='method'><a href="Niivue.html#onVolumeUpdated">onVolumeUpdated</a></li><li data-type='method'><a href="Niivue.html#onWarn">onWarn</a></li><li data-type='method'><a href="Niivue.html#refreshDrawing">refreshDrawing</a></li><li data-type='method'><a href="Niivue.html#removeHaze">removeHaze</a></li><li data-type='method'><a href="Niivue.html#removeMesh">removeMesh</a></li><li data-type='method'><a href="Niivue.html#removeMeshByUrl">removeMeshByUrl</a></li><li data-type='method'><a href="Niivue.html#removeVolume">removeVolume</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByIndex">removeVolumeByIndex</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByUrl">removeVolumeByUrl</a></li><li data-type='method'><a href="Niivue.html#reverseFaces">reverseFaces</a></li><li data-type='method'><a href="Niivue.html#saveDocument">saveDocument</a></li><li data-type='method'><a href="Niivue.html#saveImage">saveImage</a></li><li data-type='method'><a href="Niivue.html#saveScene">saveScene</a></li><li data-type='method'><a href="Niivue.html#setAdditiveBlend">setAdditiveBlend</a></li><li data-type='method'><a href="Niivue.html#setClipPlane">setClipPlane</a></li><li data-type='method'><a href="Niivue.html#setClipPlaneColor">setClipPlaneColor</a></li><li data-type='method'><a href="Niivue.html#setColormap">setColormap</a></li><li data-type='method'><a href="Niivue.html#setColormapNegative">setColormapNegative</a></li><li data-type='method'><a href="Niivue.html#setCornerOrientationText">setCornerOrientationText</a></li><li data-type='method'><a href="Niivue.html#setCrosshairColor">setCrosshairColor</a></li><li data-type='method'><a href="Niivue.html#setCrosshairWidth">setCrosshairWidth</a></li><li data-type='method'><a href="Niivue.html#setCustomMeshShader">setCustomMeshShader</a></li><li data-type='method'><a href="Niivue.html#setDefaults">setDefaults</a></li><li data-type='method'><a href="Niivue.html#setDrawOpacity">setDrawOpacity</a></li><li data-type='method'><a href="Niivue.html#setDrawingEnabled">setDrawingEnabled</a></li><li data-type='method'><a href="Niivue.html#setFrame4D">setFrame4D</a></li><li data-type='method'><a href="Niivue.html#setGamma">setGamma</a></li><li data-type='method'><a href="Niivue.html#setHighResolutionCapable">setHighResolutionCapable</a></li><li data-type='method'><a href="Niivue.html#setInterpolation">setInterpolation</a></li><li data-type='method'><a href="Niivue.html#setMeshLayerProperty">setMeshLayerProperty</a></li><li data-type='method'><a href="Niivue.html#setMeshProperty">setMeshProperty</a></li><li data-type='method'><a href="Niivue.html#setMeshShader">setMeshShader</a></li><li data-type='method'><a href="Niivue.html#setMeshThicknessOn2D">setMeshThicknessOn2D</a></li><li data-type='method'><a href="Niivue.html#setModulationImage">setModulationImage</a></li><li data-type='method'><a href="Niivue.html#setMultiplanarPadPixels">setMultiplanarPadPixels</a></li><li data-type='method'><a href="Niivue.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Niivue.html#setPan2Dxyzmm">setPan2Dxyzmm</a></li><li data-type='method'><a href="Niivue.html#setPenValue">setPenValue</a></li><li data-type='method'><a href="Niivue.html#setRadiologicalConvention">setRadiologicalConvention</a></li><li data-type='method'><a href="Niivue.html#setRenderAzimuthElevation">setRenderAzimuthElevation</a></li><li data-type='method'><a href="Niivue.html#setRenderDrawAmbientOcclusion">setRenderDrawAmbientOcclusion</a></li><li data-type='method'><a href="Niivue.html#setScale">setScale</a></li><li data-type='method'><a href="Niivue.html#setSelectionBoxColor">setSelectionBoxColor</a></li><li data-type='method'><a href="Niivue.html#setSliceMM">setSliceMM</a></li><li data-type='method'><a href="Niivue.html#setSliceMosaicString">setSliceMosaicString</a></li><li data-type='method'><a href="Niivue.html#setSliceType">setSliceType</a></li><li data-type='method'><a href="Niivue.html#setVolume">setVolume</a></li><li data-type='method'><a href="Niivue.html#setVolumeRenderIllumination">setVolumeRenderIllumination</a></li><li data-type='method'><a href="Niivue.html#sph2cartDeg">sph2cartDeg</a></li><li data-type='method'><a href="Niivue.html#syncWith">syncWith</a></li><li data-type='method'><a href="Niivue.html#updateGLVolume">updateGLVolume</a></li></ul></li><li><a href="NiivueObject3D.html">NiivueObject3D</a></li><li><a href="SessionBus.html">SessionBus</a></li><li><a href="SessionUser.html">SessionUser</a></li><li><a href="Shader.html">Shader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAG_MODE">DRAG_MODE</a></li><li><a href="global.html#MESH_EXTENSIONS">MESH_EXTENSIONS</a></li><li><a href="global.html#NVIMAGE_TYPE">NVIMAGE_TYPE</a></li><li><a href="global.html#NVMESSAGE">NVMESSAGE</a></li><li><a href="global.html#SLICE_TYPE">SLICE_TYPE</a></li><li><a href="global.html#getExtents">getExtents</a></li><li><a href="global.html#storageAvailable">storageAvailable</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">nvdocument.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { NVUtilities } from "./nvutilities";
// Disabled warnings because of issue with JSDoc https://github.com/microsoft/TypeScript/issues/14377
// eslint-disable-next-line no-unused-vars
import { NVImageFromUrlOptions, NVIMAGE_TYPE } from "./nvimage";
import { serialize, deserialize } from "@ungap/structured-clone";

/**
 * Slice Type
 * @enum
 * @readonly
 */
export const SLICE_TYPE = Object.freeze({
  AXIAL: 0,
  CORONAL: 1,
  SAGITTAL: 2,
  MULTIPLANAR: 3,
  RENDER: 4,
});

/**
 * @enum
 * @readonly
 */
export const DRAG_MODE = Object.freeze({
  none: 0,
  contrast: 1,
  measurement: 2,
  pan: 3,
  slicer3D: 4,
  callbackOnly: 5,
});

/**
 * @typedef {Object} NVConfigOptions
 * @property {number} textHeight
 * @property {number} colorbarHeight
 * @property {number} crosshairWidth
 * @property {number} rulerWidth
 * @property {boolean} show3Dcrosshair
 * @property {number[]} backColor
 * @property {number[]} crosshairColor
 * @property {number[]} fontColor
 * @property {number[]} selectionBoxColor
 * @property {number[]} clipPlaneColor
 * @property {number[]} rulerColor
 * @property {number} colorbarMargin
 * @property {boolean} trustCalMinMax
 * @property {string} clipPlaneHotKey
 * @property {string} viewModeHotKey
 * @property {number} doubleTouchTimeout
 * @property {number} longTouchTimeout
 * @property {number} keyDebounceTime
 * @property {boolean} isNearestInterpolation
 * @property {boolean} isAtlasOutline
 * @property {boolean} isRuler
 * @property {boolean} isColorbar
 * @property {boolean} isOrientCube
 * @property {number} multiplanarPadPixels
 * @property {boolean} multiplanarForceRender
 * @property {boolean} isRadiologicalConvention
 * @property {number} meshThicknessOn2D
 * @property {DRAG_MODE} dragMode
 * @property {boolean} isDepthPickMesh
 * @property {boolean} isCornerOrientationText
 * @property {boolean} sagittalNoseLeft
 * @property {boolean} isSliceMM
 * @property {boolean} isHighResolutionCapable
 * @property {boolean} logging
 * @property {string} loadingText
 * @property {boolean} dragAndDropEnabled
 * @property {boolean} drawingEnabled
 * @property {number} penValue
 * @property {number} floodFillNeighbors
 * @property {boolean} isFilledPen
 * @property {string} thumbnail
 * @property {number} maxDrawUndoBitmaps
 * @property {SLICE_TYPE} sliceType
 * @property {boolean} isAntiAlias
 * @property {boolean} isAdditiveBlend
 */
export const DEFAULT_OPTIONS = {
  textHeight: 0.06, // 0 for no text, fraction of canvas min(height,width)
  colorbarHeight: 0.05, // 0 for no colorbars, fraction of Nifti j dimension
  crosshairWidth: 1, // 0 for no crosshairs
  rulerWidth: 4,
  show3Dcrosshair: false,
  backColor: [0, 0, 0, 1],
  crosshairColor: [1, 0, 0, 1],
  fontColor: [0.5, 0.5, 0.5, 1],
  selectionBoxColor: [1, 1, 1, 0.5],
  clipPlaneColor: [0.7, 0, 0.7, 0.5],
  rulerColor: [1, 0, 0, 0.8],
  colorbarMargin: 0.05, // x axis margin around color bar, clip space coordinates
  trustCalMinMax: true, // trustCalMinMax: if true do not calculate cal_min or cal_max if set in image header. If false, always calculate display intensity range.
  clipPlaneHotKey: "KeyC", // keyboard short cut to activate the clip plane
  viewModeHotKey: "KeyV", // keyboard shortcut to switch view modes
  doubleTouchTimeout: 500,
  longTouchTimeout: 1000,
  keyDebounceTime: 50, // default debounce time used in keyup listeners
  isNearestInterpolation: false,
  isResizeCanvas: true, //Allow canvas width ahd height to resize (false for fixed size)
  isAtlasOutline: false,
  isRuler: false,
  isColorbar: false,
  isOrientCube: false,
  multiplanarPadPixels: 0,
  multiplanarForceRender: false,
  isRadiologicalConvention: false,
  meshThicknessOn2D: Infinity,
  dragMode: DRAG_MODE.contrast,
  isDepthPickMesh: false,
  isCornerOrientationText: false,
  sagittalNoseLeft: false, //sagittal slices can have Y+ going left or right
  isSliceMM: false,
  isHighResolutionCapable: true,
  logging: false,
  loadingText: "waiting for images...",
  dragAndDropEnabled: true,
  drawingEnabled: false, // drawing disabled by default
  penValue: 1, // sets drawing color. see "drawPt"
  floodFillNeighbors: 6, //does a voxel have 6 (face), 18 (edge) or 26 (corner) neighbors
  isFilledPen: false,
  thumbnail: "",
  maxDrawUndoBitmaps: 8,
  sliceType: SLICE_TYPE.MULTIPLANAR,
  meshXRay: 0.0,
  isAntiAlias: null,
  limitFrames4D: NaN,
  isAdditiveBlend: false,
};

/**Creates and instance of NVDocument
 * @class NVDocument
 * @type NVDocument
 * @constructor
 */
export class NVDocument {
  constructor() {
    this.data = {};
    this.data.title = "Untitled document";
    this.data.imageOptionsArray = [];
    this.data.meshOptionsArray = [];
    this.data.opts = { ...DEFAULT_OPTIONS };
    this.data.previewImageDataURL = "";

    /**
     * @typedef {Object} NVSceneData
     * @property {number} azimuth
     * @property {number} elevation
     * @property {number[]} crosshairPos
     * @property {number[]} clipPlane
     * @property {number[]} clipPlaneDepthAziElev
     * @property {number} volScaleMultiplier
     */
    this.scene = {
      onAzimuthElevationChange: () => {},
      onZoom3DChange: () => {},
      sceneData: {
        azimuth: 110,
        elevation: 10,
        crosshairPos: [0.5, 0.5, 0.5],
        clipPlane: [0, 0, 0, 0],
        clipPlaneDepthAziElev: [2, 0, 0],
        volScaleMultiplier: 1.0,
      },

      /**
       * Gets azimuth of scene
       * @returns {number}
       */
      get renderAzimuth() {
        return this.sceneData.azimuth;
      },
      /**
       * @param {number} azimuth
       */
      set renderAzimuth(azimuth) {
        this.sceneData.azimuth = azimuth;
        if (this.onAzimuthElevationChange) {
          this.onAzimuthElevationChange(
            this.sceneData.azimuth,
            this.sceneData.elevation
          );
        }
      },
      /**
       * Gets elevation of scene
       * @returns {number}
       */
      get renderElevation() {
        return this.sceneData.elevation;
      },

      /**
       * @param {number} elevation
       */
      set renderElevation(elevation) {
        this.sceneData.elevation = elevation;
        if (this.onAzimuthElevationChange) {
          this.onAzimuthElevationChange(
            this.sceneData.azimuth,
            this.sceneData.elevation
          );
        }
      },

      /**
       * Gets the scale/zoom of the scene
       * @returns {number}
       */
      get volScaleMultiplier() {
        return this.sceneData.volScaleMultiplier;
      },

      /**
       * Sets scale/zoom of the scene
       * @param {number} scale
       */
      set volScaleMultiplier(scale) {
        this.sceneData.volScaleMultiplier = scale;
        this.onZoom3DChange(scale);
      },

      /**
       * Gets current crosshairs position
       * @returns {number[]}
       */
      get crosshairPos() {
        return this.sceneData.crosshairPos;
      },

      /**
       * sets current crosshairs position
       * @param {number[]} crosshairPos
       */
      set crosshairPos(crosshairPos) {
        this.sceneData.crosshairPos = crosshairPos;
      },

      /**
       * Gets the current clip plane
       * @returns {number[]}
       */
      get clipPlane() {
        return this.sceneData.clipPlane;
      },

      /**
       * Gets the current clip plane
       * @param {number[]} clipPlane
       */
      set clipPlane(clipPlane) {
        this.sceneData.clipPlane = clipPlane;
      },

      /**
       * Gets current Plane Depth
       * @returns {number[]}
       */
      get clipPlaneDepthAziElev() {
        return this.sceneData.clipPlaneDepthAziElev;
      },

      /**
       * Sets current depth, azimuth and elevation of clip plane
       * @param {number[]} clipPlaneDepthAziElev
       */
      set clipPlaneDepthAziElev(clipPlaneDepthAziElev) {
        this.sceneData.clipPlaneDepthAziElev = clipPlaneDepthAziElev;
      },
    };
    this.volumes = [];
    this.meshes = [];
    this.drawBitmap = null;
    this.imageOptionsMap = new Map();
    this.meshOptionsMap = new Map();
  }

  /**
   * Title of the document
   * @returns {string}
   */
  get title() {
    return this.data.title;
  }

  /**
   * Gets preview image blob
   * @returns {string} dataURL of preview image
   */
  get previewImageDataURL() {
    return this.data.previewImageDataURL;
  }

  /**
   * Sets preview image blob
   * @param {string} dataURL encoded preview image
   */
  set previewImageDataURL(dataURL) {
    this.data.previewImageDataURL = dataURL;
  }

  /**
   * @param {string} title title of document
   */
  set title(title) {
    this.data.title = title;
  }

  /**
   * @returns {NVImageFromUrlOptions[]}
   */
  get imageOptionsArray() {
    return this.data.imageOptionsArray;
  }

  /**
   * Gets the base 64 encoded blobs of associated images
   * @returns {string[]}
   */
  get encodedImageBlobs() {
    return this.data.encodedImageBlobs;
  }

  /**
   * Gets the base 64 encoded blob of the associated drawing
   * @returns {string[]}
   */
  get encodedDrawingBlob() {
    return this.data.encodedDrawingBlob;
  }

  /**
   * Gets the options of the {@link Niivue} instance
   * @returns {Object}
   */
  get opts() {
    return this.data.opts;
  }

  /**
   * Sets the options of the {@link Niivue} instance
   */
  set opts(opts) {
    this.data.opts = { ...opts };
  }

  /**
   * Checks if document has an image by id
   * @param {NVImage} image
   * @returns {boolean}
   */
  hasImage(image) {
    return this.volumes.find((i) => i.id === image.id);
  }

  /**
   * Checks if document has an image by url
   * @param {string} url
   * @returns {boolean}
   */
  hasImageFromUrl(url) {
    return this.data.imageOptionsArray.find((i) => i.url === url);
  }

  /**
   * Adds an image and the options an image was created with
   * @param {NVImage} image
   * @param {NVImageFromUrlOptions} imageOptions
   */
  addImageOptions(image, imageOptions) {
    if (!this.hasImage(image)) {
      if (!imageOptions.name) {
        if (imageOptions.url) {
          let absoluteUrlRE = new RegExp("^(?:[a-z+]+:)?//", "i");
          let url = absoluteUrlRE.test(imageOptions.url)
            ? new URL(imageOptions.url)
            : new URL(imageOptions.url, window.location.href);

          imageOptions.name = url.pathname.split("/").pop();
          if (imageOptions.name.toLowerCase().endsWith(".gz")) {
            imageOptions.name = imageOptions.name.slice(0, -3);
          }

          if (!imageOptions.name.toLowerCase().endsWith(".nii")) {
            imageOptions.name += ".nii";
          }
        } else {
          imageOptions.name = "untitled.nii";
        }
      }
      imageOptions.imageType = NVIMAGE_TYPE.NII;

      this.data.imageOptionsArray.push(imageOptions);
      this.imageOptionsMap.set(
        image.id,
        this.data.imageOptionsArray.length - 1
      );
    }
  }

  /**
   * Removes image from the document as well as its options
   * @param {NVImage} image
   */
  removeImage(image) {
    if (this.imageOptionsMap.has(image.id)) {
      let index = this.imageOptionsMap.get(image.id);
      if (this.data.imageOptionsArray.length > index) {
        this.data.imageOptionsArray.splice(index, 1);
      }
      this.imageOptionsMap.delete(image.id);
    }
    this.volumes = this.volumes.filter((i) => i.id != image.id);
  }

  /**
   * Returns the options for the image if it was added by url
   * @param {NVImage} image
   * @returns {NVImageFromUrlOptions}
   */
  getImageOptions(image) {
    return this.imageOptionsMap.has(image.id)
      ? this.data.imageOptionsArray[this.imageOptionsMap.get(image.id)]
      : null;
  }

  /**
   * @typedef {Object} NVDocumentData
   * @property {string[]} encodedImageBlobs base64 encoded images
   * @property {string} encodedDrawingBlob base64 encoded drawing
   * @property {string} previewImageDataURL dataURL of the preview image
   * @property {Map&lt;string, number>} imageOptionsMap map of image ids to image options
   * @property {NVImageFromUrlOptions} imageOptionsArray array of image options to recreate images
   * @property {NVSceneData} sceneData data to recreate a scene
   * @property {NVConfigOptions} opts configuration options of {@link Niivue} instance
   * @property {string} meshesString encoded meshes
   */

  /**
   * Converts NVDocument to JSON
   * @returns {NVDocumentData}
   */
  json() {
    let data = {};
    data.encodedImageBlobs = [];
    data.encodedDrawingBlob = null;
    data.previewImageDataURL = this.data.previewImageDataURL;
    data.imageOptionsMap = [];
    let imageOptionsArray = [];
    // save our scene object
    data.sceneData = { ...this.scene.sceneData };

    // save our options
    data.opts = { ...this.opts };

    // volumes
    if (this.volumes.length) {
      let imageOptions = this.imageOptionsArray[0];
      if (imageOptions) {
        imageOptionsArray.push(imageOptions);
        let encodedImageBlob = NVUtilities.uint8tob64(
          this.volumes[0].toUint8Array()
        );
        data.encodedImageBlobs.push(encodedImageBlob);
        if (this.drawBitmap) {
          data.encodedDrawingBlob = NVUtilities.uint8tob64(
            this.volumes[0].toUint8Array(this.drawBitmap)
          );
        }

        data.imageOptionsMap.push([this.volumes[0].id, 0]);
      } else {
        throw new Error("image options for base layer not found");
      }

      for (let i = 1; i &lt; this.volumes.length; i++) {
        const volume = this.volumes[i];
        let imageOptions = this.getImageOptions(volume);
        if (!imageOptions) {
          imageOptions = {
            name: "",
            colormap: "gray",
            opacity: 1.0,
            pairedImgData: null,
            cal_min: NaN,
            cal_max: NaN,
            trustCalMinMax: true,
            percentileFrac: 0.02,
            ignoreZeroVoxels: false,
            visible: true,
            useQFormNotSForm: false,
            colormapNegative: "",
            colormapLabel: [],
            imageType: NVIMAGE_TYPE.NII,
            frame4D: 0,
            limitFrames4D: NaN,
          };
        }
        // update image options on current image settings
        imageOptions.colormap = volume.colormap;
        imageOptions.opacity = volume.opacity;

        imageOptionsArray.push(imageOptions);

        let encodedImageBlob = NVUtilities.uint8tob64(volume.toUint8Array());
        data.encodedImageBlobs.push(encodedImageBlob);
        data.imageOptionsMap.push([volume.id, i]);
      }
    }
    // Add it even if it's empty
    data.imageOptionsArray = imageOptionsArray;

    // meshes
    const meshes = [];
    for (const mesh of this.meshes) {
      const copyMesh = {};
      copyMesh.pts = mesh.pts;
      copyMesh.tris = mesh.tris;
      copyMesh.name = mesh.name;
      copyMesh.rgba255 = mesh.rgba255;
      copyMesh.opacity = mesh.opacity;
      copyMesh.connectome = mesh.connectome;
      copyMesh.dpg = mesh.dpg;
      copyMesh.dps = mesh.dps;
      copyMesh.dpv = mesh.dpv;
      copyMesh.meshShaderIndex = mesh.meshShaderIndex;
      copyMesh.layers = [];

      for (const layer of mesh.layers) {
        const copyLayer = {};
        copyLayer.values = layer.values;
        copyLayer.nFrame4D = layer.nFrame4D;
        copyLayer.frame4D = 0;
        copyLayer.isOutlineBorder = layer.isOutlineBorder;
        copyLayer.global_min = layer.global_min;
        copyLayer.global_max = layer.global_max;
        copyLayer.cal_min = layer.cal_min;
        copyLayer.cal_max = layer.cal_max;
        copyLayer.opacity = layer.opacity;
        copyLayer.colormap = layer.colormap;
        copyLayer.colormapNegative = layer.colormapNegative;
        copyLayer.colormapLabel = layer.colormapLabel;
        copyLayer.useNegativeCmap = layer.useNegativeCmap;
        copyMesh.layers.push(copyLayer);
      }

      meshes.push(copyMesh);
    }
    data.meshesString = JSON.stringify(serialize(meshes));
    return data;
  }

  /**
   * Downloads a JSON file with options, scene, images, meshes and drawing of {@link Niivue} instance
   * @param {string} fileName
   */
  download(fileName) {
    let data = this.json();
    NVUtilities.download(JSON.stringify(data), fileName, "application/json");
  }

  /**
   * Deserialize mesh data objects
   * @param {NVDocument} document
   */
  static deserializeMeshDataObjects(document) {
    if (document.data.meshesString) {
      document.meshDataObjects = deserialize(
        JSON.parse(document.data.meshesString)
      );
      delete document.data["meshesString"];
    }
  }

  /**
   * Factory method to return an instance of NVDocument from a URL
   * @param {string} url
   * @constructs NVDocument
   */
  static async loadFromUrl(url) {
    let response = await fetch(url);
    let data = await response.json();
    return NVDocument.loadFromJSON(data);
  }

  /**
   * Factory method to return an instance of NVDocument from a File object
   * @param {File} file
   * @constructs NVDocument
   */
  static async loadFromFile(file) {
    let arrayBuffer = await NVUtilities.readFileAsync(file);
    let document = new NVDocument();
    let utf8decoder = new TextDecoder();
    let dataString = utf8decoder.decode(arrayBuffer);
    document.data = JSON.parse(dataString);
    document.scene.sceneData = document.data.sceneData;
    delete document.data["sceneData"];
    NVDocument.deserializeMeshDataObjects(document);

    return document;
  }

  /**
   * Factory method to return an instance of NVDocument from JSON
   */
  static loadFromJSON(data) {
    let document = new NVDocument();
    document.data = data;
    document.scene.sceneData = data.sceneData;
    delete document.data["sceneData"];
    NVDocument.deserializeMeshDataObjects(document);
    return document;
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Mon Sep 04 2023 14:06:35 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
