<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      nvimage.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="3332307" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Log.html">Log</a></li><li class="accordion collapsed child" id=5801647><div class="accordion-heading child"><a href="Niivue.html">Niivue</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Niivue.html#addMesh">addMesh</a></li><li data-type='method'><a href="Niivue.html#addMeshFromUrl">addMeshFromUrl</a></li><li data-type='method'><a href="Niivue.html#addVolume">addVolume</a></li><li data-type='method'><a href="Niivue.html#addVolumeFromUrl">addVolumeFromUrl</a></li><li data-type='method'><a href="Niivue.html#attachTo">attachTo</a></li><li data-type='method'><a href="Niivue.html#attachToCanvas">attachToCanvas</a></li><li data-type='method'><a href="Niivue.html#cloneVolume">cloneVolume</a></li><li data-type='method'><a href="Niivue.html#closeSession">closeSession</a></li><li data-type='method'><a href="Niivue.html#colorMaps">colorMaps</a></li><li data-type='method'><a href="Niivue.html#createEmptyDrawing">createEmptyDrawing</a></li><li data-type='method'><a href="Niivue.html#createSession">createSession</a></li><li data-type='method'><a href="Niivue.html#drawGrowCut">drawGrowCut</a></li><li data-type='method'><a href="Niivue.html#drawMosaic">drawMosaic</a></li><li data-type='method'><a href="Niivue.html#drawUndo">drawUndo</a></li><li data-type='method'><a href="Niivue.html#getDescriptives">getDescriptives</a></li><li data-type='method'><a href="Niivue.html#getFrame4D">getFrame4D</a></li><li data-type='method'><a href="Niivue.html#getMediaByUrl">getMediaByUrl</a></li><li data-type='method'><a href="Niivue.html#getOverlayIndexByID">getOverlayIndexByID</a></li><li data-type='method'><a href="Niivue.html#getRadiologicalConvention">getRadiologicalConvention</a></li><li data-type='method'><a href="Niivue.html#getVolumeIndexByID">getVolumeIndexByID</a></li><li data-type='method'><a href="Niivue.html#joinSession">joinSession</a></li><li data-type='method'><a href="Niivue.html#loadConnectome">loadConnectome</a></li><li data-type='method'><a href="Niivue.html#loadDrawing">loadDrawing</a></li><li data-type='method'><a href="Niivue.html#loadMeshes">loadMeshes</a></li><li data-type='method'><a href="Niivue.html#loadMeshFromUrl">loadMeshFromUrl</a></li><li data-type='method'><a href="Niivue.html#loadVolumeFromUrl">loadVolumeFromUrl</a></li><li data-type='method'><a href="Niivue.html#loadVolumes">loadVolumes</a></li><li data-type='method'><a href="Niivue.html#meshShaderNames">meshShaderNames</a></li><li data-type='method'><a href="Niivue.html#moveVolumeDown">moveVolumeDown</a></li><li data-type='method'><a href="Niivue.html#moveVolumeToBottom">moveVolumeToBottom</a></li><li data-type='method'><a href="Niivue.html#moveVolumeToTop">moveVolumeToTop</a></li><li data-type='method'><a href="Niivue.html#moveVolumeUp">moveVolumeUp</a></li><li data-type='method'><a href="Niivue.html#notifySubscribersOfOptionChange">notifySubscribersOfOptionChange</a></li><li data-type='method'><a href="Niivue.html#off">off</a></li><li data-type='method'><a href="Niivue.html#on">on</a></li><li data-type='method'><a href="Niivue.html#removeMesh">removeMesh</a></li><li data-type='method'><a href="Niivue.html#removeVolume">removeVolume</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByIndex">removeVolumeByIndex</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByIndex">removeVolumeByIndex</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByIndex">removeVolumeByIndex</a></li><li data-type='method'><a href="Niivue.html#removeVolumeByUrl">removeVolumeByUrl</a></li><li data-type='method'><a href="Niivue.html#reverseFaces">reverseFaces</a></li><li data-type='method'><a href="Niivue.html#saveImage">saveImage</a></li><li data-type='method'><a href="Niivue.html#saveScene">saveScene</a></li><li data-type='method'><a href="Niivue.html#setClipPlane">setClipPlane</a></li><li data-type='method'><a href="Niivue.html#setClipPlaneColor">setClipPlaneColor</a></li><li data-type='method'><a href="Niivue.html#setColorMap">setColorMap</a></li><li data-type='method'><a href="Niivue.html#setColorMapNegative">setColorMapNegative</a></li><li data-type='method'><a href="Niivue.html#setCornerOrientationText">setCornerOrientationText</a></li><li data-type='method'><a href="Niivue.html#setCrosshairColor">setCrosshairColor</a></li><li data-type='method'><a href="Niivue.html#setCrosshairWidth">setCrosshairWidth</a></li><li data-type='method'><a href="Niivue.html#setCustomMeshShader">setCustomMeshShader</a></li><li data-type='method'><a href="Niivue.html#setDrawingEnabled">setDrawingEnabled</a></li><li data-type='method'><a href="Niivue.html#setDrawOpacity">setDrawOpacity</a></li><li data-type='method'><a href="Niivue.html#setFrame4D">setFrame4D</a></li><li data-type='method'><a href="Niivue.html#setHighResolutionCapable">setHighResolutionCapable</a></li><li data-type='method'><a href="Niivue.html#setInterpolation">setInterpolation</a></li><li data-type='method'><a href="Niivue.html#setMeshLayerProperty">setMeshLayerProperty</a></li><li data-type='method'><a href="Niivue.html#setMeshProperty">setMeshProperty</a></li><li data-type='method'><a href="Niivue.html#setMeshShader">setMeshShader</a></li><li data-type='method'><a href="Niivue.html#setMeshThicknessOn2D">setMeshThicknessOn2D</a></li><li data-type='method'><a href="Niivue.html#setModulationImage">setModulationImage</a></li><li data-type='method'><a href="Niivue.html#setOpacity">setOpacity</a></li><li data-type='method'><a href="Niivue.html#setPan2Dxyzmm">setPan2Dxyzmm</a></li><li data-type='method'><a href="Niivue.html#setPenValue">setPenValue</a></li><li data-type='method'><a href="Niivue.html#setRadiologicalConvention">setRadiologicalConvention</a></li><li data-type='method'><a href="Niivue.html#setRenderAzimuthElevation">setRenderAzimuthElevation</a></li><li data-type='method'><a href="Niivue.html#setScale">setScale</a></li><li data-type='method'><a href="Niivue.html#setSelectionBoxColor">setSelectionBoxColor</a></li><li data-type='method'><a href="Niivue.html#setSliceMM">setSliceMM</a></li><li data-type='method'><a href="Niivue.html#setSliceMosaicString">setSliceMosaicString</a></li><li data-type='method'><a href="Niivue.html#setSliceType">setSliceType</a></li><li data-type='method'><a href="Niivue.html#setVolume">setVolume</a></li><li data-type='method'><a href="Niivue.html#sph2cartDeg">sph2cartDeg</a></li><li data-type='method'><a href="Niivue.html#syncWith">syncWith</a></li><li data-type='method'><a href="Niivue.html#updateGLVolume">updateGLVolume</a></li></ul></li><li class="accordion-list" id=""><a href="NiivueObject3D.html">NiivueObject3D</a></li><li class="accordion collapsed child" id=5064112><div class="accordion-heading child"><a href="NVImage.html">NVImage</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="NVImage.html#.zerosLike">zerosLike</a></li><li data-type='method'><a href="NVImage.html#applyOptionsUpdate">applyOptionsUpdate</a></li><li data-type='method'><a href="NVImage.html#clone">clone</a></li><li data-type='method'><a href="NVImage.html#colorMaps">colorMaps</a></li><li data-type='method'><a href="NVImage.html#getImageMetadata">getImageMetadata</a></li><li data-type='method'><a href="NVImage.html#toNiivueObject3D">toNiivueObject3D</a></li><li data-type='method'><a href="NVImage.html#zeroImage">zeroImage</a></li></ul></li><li class="accordion-list" id=""><a href="global.html#NVImageFromUrlOptions">NVImageFromUrlOptions</a></li><li class="accordion collapsed child" id=4199630><div class="accordion-heading child"><a href="NVMesh.html">NVMesh</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="NVMesh.html#.loadFromBase64">loadFromBase64</a></li><li data-type='method'><a href="NVMesh.html#.loadFromFile">loadFromFile</a></li><li data-type='method'><a href="NVMesh.html#.loadFromUrl">loadFromUrl</a></li></ul></li><li class="accordion-list" id=""><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li class="accordion-list" id=""><a href="NVMessage.html">NVMessage</a></li><li class="accordion-list" id=""><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li class="accordion-list" id=""><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li class="accordion-list" id=""><a href="Shader.html">Shader</a></li></ul> </div><div class="accordion collapsed" id="4409685" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#getExtents">getExtents</a></li><li class="accordion-list" id=""><a href="global.html#NiivueOptions">NiivueOptions</a></li><li class="accordion-list" id=""><a href="global.html#NVImageFromUrlOptions">NVImageFromUrlOptions</a></li><li class="accordion-list" id=""><a href="global.html#NVImageMetadata">NVImageMetadata</a></li><li class="accordion-list" id=""><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li class="accordion-list" id=""><a href="global.html#NVMeshLayer">NVMeshLayer</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        nvimage.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import nifti from "nifti-reader-js";
import daikon from "daikon";
import { v4 as uuidv4 } from "uuid";
import { mat3, mat4, vec3, vec4 } from "gl-matrix";
import * as cmaps from "./cmaps";
import * as fflate from "fflate";
import { NiivueObject3D } from "./niivue-object3D";
import { Log } from "./logger";
const log = new Log();

// not included in public docs
function isPlatformLittleEndian() {
  //inspired by https://github.com/rii-mango/Papaya
  var buffer = new ArrayBuffer(2);
  new DataView(buffer).setInt16(0, 256, true);
  return new Int16Array(buffer)[0] === 256;
}

/**
 * query all available color maps that can be applied to volumes
 * @param {boolean} [sort=true] whether or not to sort the returned array
 * @returns {array} an array of colormap strings
 * @example
 * niivue = new Niivue()
 * colormaps = niivue.colorMaps()
 */

/**
 * NVImageFromUrlOptions
 * @typedef  NVImageFromUrlOptions
 * @type {object}
 * @property {string} url - the resolvable URL pointing to a nifti image to load
 * @property {string} [urlImgData=""] Allows loading formats where header and image are separate files (e.g. nifti.hdr, nifti.img)
 * @property {string} [name=''] a name for this image. Default is an empty string
 * @property {string} [colorMap='gray'] a color map to use. default is gray
 * @property {number} [opacity=1.0] the opacity for this image. default is 1
 * @property {number} [cal_min=NaN] minimum intensity for color brightness/contrast
 * @property {number} [cal_max=NaN] maximum intensity for color brightness/contrast
 * @property {boolean} [trustCalMinMax=true] whether or not to trust cal_min and cal_max from the nifti header (trusting results in faster loading)
 * @property {number} [percentileFrac=0.02] the percentile to use for setting the robust range of the display values (smart intensity setting for images with large ranges)
 * @property {boolean} [visible=true] whether or not this image is to be visible
 * @property {string} [colorMapNegative=''] a color map to use for symmetrical negative intensities
 */

/**
 *
 * @constructor
 * @returns {NVImageFromUrlOptions}
 */
export function NVImageFromUrlOptions(
  url,
  urlImageData = "",
  name = "",
  colorMap = "gray",
  opacity = 1.0,
  cal_min = NaN,
  cal_max = NaN,
  trustCalMinMax = true,
  percentileFrac = 0.02,
  ignoreZeroVoxels = false,
  visible = true,
  colorMapNegative = ""
) {
  return {
    url,
    urlImageData,
    name,
    colorMap,
    opacity,
    cal_min,
    cal_max,
    trustCalMinMax,
    percentileFrac,
    ignoreZeroVoxels,
    visible,
    colorMapNegative,
  };
}

/**
 * @class NVImage
 * @type NVImage
 * @description
 * a NVImage encapsulates some images data and provides methods to query and operate on images
 * @constructor
 * @param {array} dataBuffer an array buffer of image data to load (there are also methods that abstract this more. See loadFromUrl, and loadFromFile)
 * @param {string} [name=''] a name for this image. Default is an empty string
 * @param {string} [colorMap='gray'] a color map to use. default is gray
 * @param {number} [opacity=1.0] the opacity for this image. default is 1
 * @param {string} [pairedImgData=null] Allows loading formats where header and image are separate files (e.g. nifti.hdr, nifti.img)
 * @param {number} [cal_min=NaN] minimum intensity for color brightness/contrast
 * @param {number} [cal_max=NaN] maximum intensity for color brightness/contrast
 * @param {boolean} [trustCalMinMax=true] whether or not to trust cal_min and cal_max from the nifti header (trusting results in faster loading)
 * @param {number} [percentileFrac=0.02] the percentile to use for setting the robust range of the display values (smart intensity setting for images with large ranges)
 * @param {boolean} [ignoreZeroVoxels=false] whether or not to ignore zero voxels in setting the robust range of display values
 * @param {boolean} [visible=true] whether or not this image is to be visible
 * @param {boolean} [isDICOMDIR=true] input is DICOM folder, not a single file
 * @param {boolean} [useQFormNotSForm=true] give precedence to QForm (Quaternion) or SForm (Matrix)
 * @param {string} [colorMapNegative=''] a color map to use for symmetrical negative intensities
 */
export function NVImage(
  dataBuffer, // can be an array of Typed arrays or just a typed array. If an array of Typed arrays then it is assumed you are loading DICOM (perhaps the only real use case?)
  name = "",
  colorMap = "gray",
  opacity = 1.0,
  pairedImgData = null,
  cal_min = NaN,
  cal_max = NaN,
  trustCalMinMax = true,
  percentileFrac = 0.02,
  ignoreZeroVoxels = false,
  visible = true,
  isDICOMDIR = false,
  useQFormNotSForm = false,
  colorMapNegative = ""
) {
  // https://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
  this.DT_NONE = 0;
  this.DT_UNKNOWN = 0; /* what it says, dude           */
  this.DT_BINARY = 1; /* binary (1 bit/voxel)         */
  this.DT_UNSIGNED_CHAR = 2; /* unsigned char (8 bits/voxel) */
  this.DT_SIGNED_SHORT = 4; /* signed short (16 bits/voxel) */
  this.DT_SIGNED_INT = 8; /* signed int (32 bits/voxel)   */
  this.DT_FLOAT = 16; /* float (32 bits/voxel)        */
  this.DT_COMPLEX = 32; /* complex (64 bits/voxel)      */
  this.DT_DOUBLE = 64; /* double (64 bits/voxel)       */
  this.DT_RGB = 128; /* RGB triple (24 bits/voxel)   */
  this.DT_ALL = 255; /* not very useful (?)          */
  this.DT_INT8 = 256; /* signed char (8 bits)         */
  this.DT_UINT16 = 512; /* unsigned short (16 bits)     */
  this.DT_UINT32 = 768; /* unsigned int (32 bits)       */
  this.DT_INT64 = 1024; /* long long (64 bits)          */
  this.DT_UINT64 = 1280; /* unsigned long long (64 bits) */
  this.DT_FLOAT128 = 1536; /* long double (128 bits)       */
  this.DT_COMPLEX128 = 1792; /* double pair (128 bits)       */
  this.DT_COMPLEX256 = 2048; /* long double pair (256 bits)  */
  this.DT_RGBA32 = 2304; /* 4 byte RGBA (32 bits/voxel)  */

  this.name = name;
  this.id = uuidv4();
  this.colorMap = colorMap;
  this.frame4D = 0; //indexed from 0!
  this.opacity = opacity > 1.0 ? 1.0 : opacity; //make sure opacity can't be initialized greater than 1 see: #107 and #117 on github
  this.percentileFrac = percentileFrac;
  this.ignoreZeroVoxels = ignoreZeroVoxels;
  this.trustCalMinMax = trustCalMinMax;
  this.colorMapNegative = colorMapNegative;
  this.visible = visible;
  this.modulationImage = null;
  this.series = []; // for concatenating dicom images

  // Added to support zerosLike
  if (!dataBuffer) {
    return;
  }
  var re = /(?:\.([^.]+))?$/;
  let ext = re.exec(name)[1] || "";
  ext = ext.toUpperCase();
  if (ext === "GZ") {
    ext = re.exec(name.slice(0, -3))[1]; //img.trk.gz -> img.trk
    ext = ext.toUpperCase();
  }
  let imgRaw = null;
  this.hdr = null;
  if (ext === "" &amp;&amp; isDICOMDIR &amp;&amp; Array.isArray(dataBuffer)) {
    imgRaw = this.readDICOM(dataBuffer);
  } else if (ext === "MIH" || ext === "MIF") {
    imgRaw = this.readMIF(dataBuffer, pairedImgData); //detached
  } else if (ext === "NHDR" || ext === "NRRD") {
    imgRaw = this.readNRRD(dataBuffer, pairedImgData); //detached
  } else if (ext === "MHD" || ext === "MHA") {
    imgRaw = this.readMHA(dataBuffer); //to do: pairedImgData
  } else if (ext === "MGH" || ext === "MGZ") {
    imgRaw = this.readMGH(dataBuffer);
  } else if (ext === "V") {
    imgRaw = this.readECAT(dataBuffer);
  } else if (ext === "V16") {
    imgRaw = this.readV16(dataBuffer);
  } else if (ext === "VMR") {
    imgRaw = this.readVMR(dataBuffer);
  } else if (ext === "HEAD") {
    imgRaw = this.readHEAD(dataBuffer, pairedImgData); //paired = .BRIK
  } else if (ext === "NII") {
    this.hdr = nifti.readHeader(dataBuffer);
    if (this.hdr.cal_min === 0 &amp;&amp; this.hdr.cal_max === 255)
      this.hdr.cal_max = 0.0;
    if (nifti.isCompressed(dataBuffer)) {
      imgRaw = nifti.readImage(this.hdr, nifti.decompress(dataBuffer));
    } else {
      imgRaw = nifti.readImage(this.hdr, dataBuffer);
    }
  } else {
    //DICOMs do not always end .dcm, so DICOM is our format of last resort
    imgRaw = this.readDICOM(dataBuffer);
  }
  this.nFrame4D = 1;
  for (let i = 4; i &lt; 7; i++)
    if (this.hdr.dims[i] > 1) this.nFrame4D *= this.hdr.dims[i];
  this.nVox3D = this.hdr.dims[1] * this.hdr.dims[2] * this.hdr.dims[3];
  let nVol4D = imgRaw.byteLength / this.nVox3D / (this.hdr.numBitsPerVoxel / 8);
  if (nVol4D !== this.nFrame4D)
    console.log(
      "This header does not match voxel data",
      this.hdr,
      imgRaw.byteLength
    );
  //1007 = NIFTI_INTENT_VECTOR; 2003 = NIFTI_INTENT_RGB_VECTOR
  // n.b. NIfTI standard says "NIFTI_INTENT_RGB_VECTOR" should be RGBA, but FSL only stores RGB
  if (
    (this.hdr.intent_code === 1007 || this.hdr.intent_code === 2003) &amp;&amp;
    this.nFrame4D === 3 &amp;&amp;
    this.hdr.datatypeCode === this.DT_FLOAT
  ) {
    let tmp = new Float32Array(imgRaw);
    let f32 = tmp.slice();
    this.hdr.datatypeCode = this.DT_RGB;
    this.nFrame4D = 1;
    for (let i = 4; i &lt; 7; i++) this.hdr.dims[i] = 1;
    this.hdr.dims[0] = 3; //3D
    imgRaw = new Uint8Array(this.nVox3D * 3); //*3 for RGB
    let mx = Math.abs(f32[0]);
    for (let i = 0; i &lt; this.nVox3D * 3; i++)
      mx = Math.max(mx, Math.abs(f32[i]));
    let slope = 1.0;
    if (mx > 0) slope = 1.0 / mx;

    let nVox3D2 = this.nVox3D * 2;
    let j = 0;
    for (let i = 0; i &lt; this.nVox3D; i++) {
      imgRaw[j] = 255.0 * Math.abs(f32[i] * slope);
      imgRaw[j + 1] = 255.0 * Math.abs(f32[i + this.nVox3D] * slope);
      imgRaw[j + 2] = 255.0 * Math.abs(f32[i + nVox3D2] * slope);
      j += 3;
    }
  } //NIFTI_INTENT_VECTOR: this is a RGB tensor
  if (
    this.hdr.pixDims[1] === 0.0 ||
    this.hdr.pixDims[2] === 0.0 ||
    this.hdr.pixDims[3] === 0.0
  )
    console.log("pixDims not plausible", this.hdr);
  function isAffineOK(mtx) {
    //A good matrix should not have any components that are not a number
    //A good spatial transformation matrix should not have a row or column that is all zeros
    let iOK = [false, false, false, false];
    let jOK = [false, false, false, false];
    for (let i = 0; i &lt; 4; i++) {
      for (let j = 0; j &lt; 4; j++) {
        if (isNaN(mtx[i][j])) return false;
      }
    }
    for (let i = 0; i &lt; 3; i++) {
      for (let j = 0; j &lt; 3; j++) {
        if (mtx[i][j] === 0.0) continue;
        iOK[i] = true;
        jOK[j] = true;
      }
    }
    for (let i = 0; i &lt; 3; i++) {
      if (!iOK[i]) return false;
      if (!jOK[i]) return false;
    }
    return true;
  } //
  if (isNaN(this.hdr.scl_slope) || this.hdr.scl_slope === 0.0)
    this.hdr.scl_slope = 1.0; //https://github.com/nipreps/fmriprep/issues/2507
  if (isNaN(this.hdr.scl_inter)) this.hdr.scl_inter = 0.0;
  let affineOK = isAffineOK(this.hdr.affine);
  if (
    useQFormNotSForm ||
    !affineOK ||
    this.hdr.qform_code > this.hdr.sform_code
  ) {
    log.debug("spatial transform based on QForm");
    //https://github.com/rii-mango/NIFTI-Reader-JS/blob/6908287bf99eb3bc4795c1591d3e80129da1e2f6/src/nifti1.js#L238
    // Define a, b, c, d for coding covenience
    const b = this.hdr.quatern_b;
    const c = this.hdr.quatern_c;
    const d = this.hdr.quatern_d;
    // quatern_a is a parameter in quaternion [a, b, c, d], which is required in affine calculation (METHOD 2)
    // mentioned in the nifti1.h file
    // It can be calculated by a = sqrt(1.0-(b*b+c*c+d*d))
    const a = Math.sqrt(
      1.0 - (Math.pow(b, 2) + Math.pow(c, 2) + Math.pow(d, 2))
    );
    const qfac = this.hdr.pixDims[0] === 0 ? 1 : this.hdr.pixDims[0];
    const quatern_R = [
      [
        a * a + b * b - c * c - d * d,
        2 * b * c - 2 * a * d,
        2 * b * d + 2 * a * c,
      ],
      [
        2 * b * c + 2 * a * d,
        a * a + c * c - b * b - d * d,
        2 * c * d - 2 * a * b,
      ],
      [
        2 * b * d - 2 * a * c,
        2 * c * d + 2 * a * b,
        a * a + d * d - c * c - b * b,
      ],
    ];
    const affine = this.hdr.affine;
    for (let ctrOut = 0; ctrOut &lt; 3; ctrOut += 1) {
      for (let ctrIn = 0; ctrIn &lt; 3; ctrIn += 1) {
        affine[ctrOut][ctrIn] =
          quatern_R[ctrOut][ctrIn] * this.hdr.pixDims[ctrIn + 1];
        if (ctrIn === 2) {
          affine[ctrOut][ctrIn] *= qfac;
        }
      }
    }
    // The last row of affine matrix is the offset vector
    affine[0][3] = this.hdr.qoffset_x;
    affine[1][3] = this.hdr.qoffset_y;
    affine[2][3] = this.hdr.qoffset_z;
    this.hdr.affine = affine;
  }
  affineOK = isAffineOK(this.hdr.affine);
  if (!affineOK) {
    log.debug("Defective NIfTI: spatial transform does not make sense");
    let x = this.hdr.pixDims[1];
    let y = this.hdr.pixDims[2];
    let z = this.hdr.pixDims[3];
    if (isNaN(x) || x === 0.0) x = 1.0;
    if (isNaN(y) || y === 0.0) y = 1.0;
    if (isNaN(z) || z === 0.0) z = 1.0;
    this.hdr.pixDims[1] = x;
    this.hdr.pixDims[2] = y;
    this.hdr.pixDims[3] = z;
    const affine = [
      [x, 0, 0, 0],
      [0, y, 0, 0],
      [0, 0, z, 0],
      [0, 0, 0, 1],
    ];
    this.hdr.affine = affine;
  } //defective affine
  //swap data if foreign endian:
  if (
    this.hdr.datatypeCode !== this.DT_RGB &amp;&amp;
    this.hdr.datatypeCode !== this.DT_RGBA32 &amp;&amp;
    this.hdr.littleEndian !== isPlatformLittleEndian() &amp;&amp;
    this.hdr.numBitsPerVoxel > 8
  ) {
    if (this.hdr.numBitsPerVoxel === 16) {
      //inspired by https://github.com/rii-mango/Papaya
      var u16 = new Uint16Array(imgRaw);
      for (let i = 0; i &lt; u16.length; i++) {
        let val = u16[i];
        u16[i] = ((((val &amp; 0xff) &lt;&lt; 8) | ((val >> 8) &amp; 0xff)) &lt;&lt; 16) >> 16; // since JS uses 32-bit  when bit shifting
      }
    } else if (this.hdr.numBitsPerVoxel === 32) {
      //inspired by https://github.com/rii-mango/Papaya
      var u32 = new Uint32Array(imgRaw);
      for (let i = 0; i &lt; u32.length; i++) {
        let val = u32[i];
        u32[i] =
          ((val &amp; 0xff) &lt;&lt; 24) |
          ((val &amp; 0xff00) &lt;&lt; 8) |
          ((val >> 8) &amp; 0xff00) |
          ((val >> 24) &amp; 0xff);
      }
    } else if (this.hdr.numBitsPerVoxel === 64) {
      //inspired by MIT licensed code: https://github.com/rochars/endianness
      let numBytesPerVoxel = this.hdr.numBitsPerVoxel / 8;
      var u8 = new Uint8Array(imgRaw);
      for (let index = 0; index &lt; u8.length; index += numBytesPerVoxel) {
        let offset = bytesPer - 1;
        for (let x = 0; x &lt; offset; x++) {
          let theByte = u8[index + x];
          u8[index + x] = u8[index + offset];
          u8[index + offset] = theByte;
          offset--;
        }
      }
    } //if 64-bits
  } //swap byte order
  switch (this.hdr.datatypeCode) {
    case this.DT_UNSIGNED_CHAR:
      this.img = new Uint8Array(imgRaw);
      break;
    case this.DT_SIGNED_SHORT:
      this.img = new Int16Array(imgRaw);

      break;
    case this.DT_FLOAT:
      this.img = new Float32Array(imgRaw);
      break;
    case this.DT_DOUBLE:
      this.img = new Float64Array(imgRaw);
      break;
    case this.DT_RGB:
      this.img = new Uint8Array(imgRaw);
      break;
    case this.DT_UINT16:
      this.img = new Uint16Array(imgRaw);
      break;
    case this.DT_RGBA32:
      this.img = new Uint8Array(imgRaw);
      break;
    case this.DT_INT8: {
      let i8 = new Int8Array(imgRaw);
      var vx8 = i8.length;
      this.img = new Int16Array(vx8);
      for (let i = 0; i &lt; vx8 - 1; i++) this.img[i] = i8[i];
      this.hdr.datatypeCode = this.DT_SIGNED_SHORT;
      break;
    }
    case this.DT_UINT32: {
      let u32 = new Uint32Array(imgRaw);
      var vx32 = u32.length;
      this.img = new Float64Array(vx32);
      for (let i = 0; i &lt; vx32 - 1; i++) this.img[i] = u32[i];
      this.hdr.datatypeCode = this.DT_DOUBLE;
      break;
    }
    case this.DT_SIGNED_INT: {
      let i32 = new Int32Array(imgRaw);
      var vxi32 = i32.length;
      this.img = new Float64Array(vxi32);
      for (let i = 0; i &lt; vxi32 - 1; i++) this.img[i] = i32[i];
      this.hdr.datatypeCode = this.DT_DOUBLE;
      break;
    }
    case this.DT_INT64: {
      // eslint-disable-next-line no-undef
      let i64 = new BigInt64Array(imgRaw);
      let vx = i64.length;
      this.img = new Float64Array(vx);
      for (let i = 0; i &lt; vx - 1; i++) this.img[i] = Number(i64[i]);
      this.hdr.datatypeCode = this.DT_DOUBLE;
      break;
    }
    default:
      throw "datatype " + this.hdr.datatypeCode + " not supported";
  }
  this.calculateRAS();
  if (!isNaN(cal_min)) this.hdr.cal_min = cal_min;
  if (!isNaN(cal_max)) this.hdr.cal_max = cal_max;
  this.calMinMax();
}

// not included in public docs
// detect difference between voxel grid and world space
// https://github.com/afni/afni/blob/25e77d564f2c67ff480fa99a7b8e48ec2d9a89fc/src/thd_coords.c#L717
NVImage.prototype.computeObliqueAngle = function (mtx44) {
  let mtx = mat4.clone(mtx44);
  mat4.transpose(mtx, mtx44);
  let dxtmp = Math.sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1] + mtx[2] * mtx[2]);
  let xmax =
    Math.max(Math.max(Math.abs(mtx[0]), Math.abs(mtx[1])), Math.abs(mtx[2])) /
    dxtmp;
  let dytmp = Math.sqrt(mtx[4] * mtx[4] + mtx[5] * mtx[5] + mtx[6] * mtx[6]);
  let ymax =
    Math.max(Math.max(Math.abs(mtx[4]), Math.abs(mtx[5])), Math.abs(mtx[6])) /
    dytmp;
  let dztmp = Math.sqrt(mtx[8] * mtx[8] + mtx[9] * mtx[9] + mtx[10] * mtx[10]);
  let zmax =
    Math.max(Math.max(Math.abs(mtx[8]), Math.abs(mtx[9])), Math.abs(mtx[10])) /
    dztmp;
  let fig_merit = Math.min(Math.min(xmax, ymax), zmax);
  let oblique_angle = Math.abs((Math.acos(fig_merit) * 180.0) / 3.141592653);
  if (oblique_angle > 0.01)
    console.log(
      "Warning voxels not aligned with world space: " +
        oblique_angle +
        " degrees from plumb.\n"
    );
  else oblique_angle = 0.0;
  return oblique_angle;
};

// not included in public docs
// detect difference between voxel grid and world space
NVImage.prototype.calculateOblique = function () {
  this.oblique_angle = this.computeObliqueAngle(this.matRAS);
  let LPI = this.vox2mm([0.0, 0.0, 0.0], this.matRAS);
  let X1mm = this.vox2mm([1.0 / this.pixDimsRAS[1], 0.0, 0.0], this.matRAS);
  let Y1mm = this.vox2mm([0.0, 1.0 / this.pixDimsRAS[2], 0.0], this.matRAS);
  let Z1mm = this.vox2mm([0.0, 0.0, 1.0 / this.pixDimsRAS[3]], this.matRAS);
  vec3.subtract(X1mm, X1mm, LPI);
  vec3.subtract(Y1mm, Y1mm, LPI);
  vec3.subtract(Z1mm, Z1mm, LPI);
  let oblique = mat4.fromValues(
    X1mm[0],
    X1mm[1],
    X1mm[2],
    0,
    Y1mm[0],
    Y1mm[1],
    Y1mm[2],
    0,
    Z1mm[0],
    Z1mm[1],
    Z1mm[2],
    0,
    0,
    0,
    0,
    1
  );
  this.obliqueRAS = mat4.clone(oblique);
  let XY = Math.abs(90 - vec3.angle(X1mm, Y1mm) * (180 / Math.PI));
  let XZ = Math.abs(90 - vec3.angle(X1mm, Z1mm) * (180 / Math.PI));
  let YZ = Math.abs(90 - vec3.angle(Y1mm, Z1mm) * (180 / Math.PI));
  this.maxShearDeg = Math.max(Math.max(XY, XZ), YZ);
  if (this.maxShearDeg > 0.1)
    console.log(
      "Warning: voxels are rhomboidal, maximum shear is %f degrees.",
      this.maxShearDeg
    );
  //compute a matrix to transform vectors from factional space to mm:
  let dim = vec4.fromValues(
    this.dimsRAS[1],
    this.dimsRAS[2],
    this.dimsRAS[3],
    1
  );
  let sform = mat4.clone(this.matRAS);
  mat4.transpose(sform, sform);
  let shim = vec4.fromValues(-0.5, -0.5, -0.5, 0); //bitmap with 5 voxels scaled 0..1, voxel centers are 0.1,0.3,0.5,0.7,0.9
  mat4.translate(sform, sform, shim);
  //mat.mat4.scale(sform, sform, dim);
  sform[0] *= dim[0];
  sform[1] *= dim[0];
  sform[2] *= dim[0];
  sform[4] *= dim[1];
  sform[5] *= dim[1];
  sform[6] *= dim[1];
  sform[8] *= dim[2];
  sform[9] *= dim[2];
  sform[10] *= dim[2];
  this.frac2mm = mat4.clone(sform);
};

// not included in public docs
// convert AFNI head/brik space to NIfTI format
// https://github.com/afni/afni/blob/d6997e71f2b625ac1199460576d48f3136dac62c/src/thd_niftiwrite.c#L315
NVImage.prototype.THD_daxes_to_NIFTI = function (
  xyzDelta,
  xyzOrigin,
  orientSpecific
) {
  let hdr = this.hdr;
  hdr.sform_code = 2;
  const ORIENT_xyz = "xxyyzzg"; //note strings indexed from 0!
  let nif_x_axnum = -1;
  let nif_y_axnum = -1;
  let nif_z_axnum = -1;
  let axcode = ["x", "y", "z"];
  axcode[0] = ORIENT_xyz[orientSpecific[0]];
  axcode[1] = ORIENT_xyz[orientSpecific[1]];
  axcode[2] = ORIENT_xyz[orientSpecific[2]];
  let axstep = xyzDelta.slice(0, 3);
  let axstart = xyzOrigin.slice(0, 3);
  for (var ii = 0; ii &lt; 3; ii++) {
    if (axcode[ii] === "x") nif_x_axnum = ii;
    else if (axcode[ii] === "y") nif_y_axnum = ii;
    else nif_z_axnum = ii;
  }
  if (nif_x_axnum &lt; 0 || nif_y_axnum &lt; 0 || nif_z_axnum &lt; 0) return; //not assigned
  if (
    nif_x_axnum === nif_y_axnum ||
    nif_x_axnum === nif_z_axnum ||
    nif_y_axnum === nif_z_axnum
  )
    return; //not assigned
  hdr.pixDims[1] = Math.abs(axstep[0]);
  hdr.pixDims[2] = Math.abs(axstep[1]);
  hdr.pixDims[3] = Math.abs(axstep[2]);
  hdr.affine = [
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
  ];
  hdr.affine[0][nif_x_axnum] = -axstep[nif_x_axnum];
  hdr.affine[1][nif_y_axnum] = -axstep[nif_y_axnum];
  hdr.affine[2][nif_z_axnum] = axstep[nif_z_axnum];
  hdr.affine[0][3] = -axstart[nif_x_axnum];
  hdr.affine[1][3] = -axstart[nif_y_axnum];
  hdr.affine[2][3] = axstart[nif_z_axnum];
};

// not included in public docs
// determine spacing voxel centers (rows, columns, slices)
NVImage.prototype.SetPixDimFromSForm = function () {
  let m = this.hdr.affine;
  let mat = mat4.fromValues(
    m[0][0],
    m[0][1],
    m[0][2],
    m[0][3],
    m[1][0],
    m[1][1],
    m[1][2],
    m[1][3],
    m[2][0],
    m[2][1],
    m[2][2],
    m[2][3],
    m[3][0],
    m[3][1],
    m[3][2],
    m[3][3]
  );
  let mm000 = this.vox2mm([0, 0, 0], mat);
  let mm100 = this.vox2mm([1, 0, 0], mat);
  vec3.subtract(mm100, mm100, mm000);
  let mm010 = this.vox2mm([0, 1, 0], mat);
  vec3.subtract(mm010, mm010, mm000);
  let mm001 = this.vox2mm([0, 0, 1], mat);
  vec3.subtract(mm001, mm001, mm000);
  this.hdr.pixDims[1] = vec3.length(mm100);
  this.hdr.pixDims[2] = vec3.length(mm010);
  this.hdr.pixDims[3] = vec3.length(mm001);
};

// not included in public docs
// create NIfTI format SForm from DICOM frame of reference
function getBestTransform(imageDirections, voxelDimensions, imagePosition) {
  //https://github.com/rii-mango/Papaya/blob/782a19341af77a510d674c777b6da46afb8c65f1/src/js/volume/dicom/header-dicom.js#L605
  /*Copyright (c) 2012-2015, RII-UTHSCSA
All rights reserved.

THIS PRODUCT IS NOT FOR CLINICAL USE.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
following conditions are met:

 - Redistributions of source code must retain the above copyright notice, this list of conditions and the following
   disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
   disclaimer in the documentation and/or other materials provided with the distribution.

 - Neither the name of the RII-UTHSCSA nor the names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
  var cosines = imageDirections,
    m = null;
  if (cosines) {
    var vs = {
      colSize: voxelDimensions[0],
      rowSize: voxelDimensions[1],
      sliceSize: voxelDimensions[2],
    };
    var coord = imagePosition;
    var cosx = [cosines[0], cosines[1], cosines[2]];
    var cosy = [cosines[3], cosines[4], cosines[5]];
    var cosz = [
      cosx[1] * cosy[2] - cosx[2] * cosy[1],
      cosx[2] * cosy[0] - cosx[0] * cosy[2],
      cosx[0] * cosy[1] - cosx[1] * cosy[0],
    ];
    m = [
      [
        cosx[0] * vs.colSize * -1,
        cosy[0] * vs.rowSize * -1,
        cosz[0] * vs.sliceSize * -1,
        -1 * coord[0],
      ],
      [
        cosx[1] * vs.colSize * -1,
        cosy[1] * vs.rowSize * -1,
        cosz[1] * vs.sliceSize * -1,
        -1 * coord[1],
      ],
      [
        cosx[2] * vs.colSize,
        cosy[2] * vs.rowSize,
        cosz[2] * vs.sliceSize,
        coord[2],
      ],
      [0, 0, 0, 1],
    ];
  }
  return m;
} // getBestTransform()

// not included in public docs
// read DICOM format image and treat it like a NIfTI
NVImage.prototype.readDICOM = function (buf) {
  this.series = new daikon.Series();
  // parse DICOM file
  if (Array.isArray(buf)) {
    for (let i = 0; i &lt; buf.length; i++) {
      const dataview = new DataView(buf[i]);
      let image = daikon.Series.parseImage(dataview);
      if (image === null) {
        console.error(daikon.Series.parserError);
      } else if (image.hasPixelData()) {
        // if it's part of the same series, add it
        if (
          this.series.images.length === 0 ||
          image.getSeriesId() === this.series.images[0].getSeriesId()
        ) {
          this.series.addImage(image);
        }
      } // if hasPixelData
    } // for i
  } else {
    // not a dicom folder drop
    var image = daikon.Series.parseImage(new DataView(buf));
    if (image === null) {
      console.error(daikon.Series.parserError);
    } else if (image.hasPixelData()) {
      // if it's part of the same series, add it
      if (
        this.series.images.length === 0 ||
        image.getSeriesId() === this.series.images[0].getSeriesId()
      ) {
        this.series.addImage(image);
      }
    }
  }
  // order the image files, determines number of frames, etc.
  this.series.buildSeries();
  // output some header info
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.scl_inter = 0;
  hdr.scl_slope = 1;
  if (this.series.images[0].getDataScaleIntercept())
    hdr.scl_inter = this.series.images[0].getDataScaleIntercept();
  if (this.series.images[0].getDataScaleSlope())
    hdr.scl_slope = this.series.images[0].getDataScaleSlope();
  if (hdr.scl_slope === 0) hdr.scl_slope;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  hdr.dims[1] = this.series.images[0].getCols();
  hdr.dims[2] = this.series.images[0].getRows();
  hdr.dims[3] = this.series.images[0].getNumberOfFrames();
  if (this.series.images.length > 1) {
    if (hdr.dims[3] > 1)
      console.log(
        "To Do: multiple slices per file and multiple files (XA30 DWI)"
      );
    hdr.dims[3] = this.series.images.length;
  }
  let rc = this.series.images[0].getPixelSpacing(); //TODO: order?
  hdr.pixDims[1] = rc[0];
  hdr.pixDims[2] = rc[1];
  hdr.pixDims[3] = Math.max(
    this.series.images[0].getSliceGap(),
    this.series.images[0].getSliceThickness()
  );
  hdr.pixDims[4] = this.series.images[0].getTR() / 1000.0; //msec -> sec
  let dt = this.series.images[0].getDataType(); //2=int,3=uint,4=float,
  let bpv = this.series.images[0].getBitsAllocated();
  hdr.numBitsPerVoxel = bpv;
  this.hdr.littleEndian = this.series.images[0].littleEndian;
  if (bpv === 8 &amp;&amp; dt === 2) hdr.datatypeCode = this.DT_INT8;
  else if (bpv === 8 &amp;&amp; dt === 3) hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
  else if (bpv === 16 &amp;&amp; dt === 2) hdr.datatypeCode = this.DT_SIGNED_SHORT;
  else if (bpv === 16 &amp;&amp; dt === 3) hdr.datatypeCode = this.DT_UINT16;
  else if (bpv === 32 &amp;&amp; dt === 2) hdr.datatypeCode = this.DT_SIGNED_INT;
  else if (bpv === 32 &amp;&amp; dt === 3) hdr.datatypeCode = this.DT_UINT32;
  else if (bpv === 32 &amp;&amp; dt === 4) hdr.datatypeCode = this.DT_FLOAT;
  else if (bpv === 64 &amp;&amp; dt === 4) hdr.datatypeCode = this.DT_DOUBLE;
  else console.log("Unsupported DICOM format: " + dt + " " + bpv);
  let voxelDimensions = hdr.pixDims.slice(1, 4);
  //console.log("dir", this.series.images[0].getImageDirections());
  //console.log("pos", this.series.images[0].getImagePosition());
  //console.log("dims", voxelDimensions);
  let m = getBestTransform(
    this.series.images[0].getImageDirections(),
    voxelDimensions,
    this.series.images[0].getImagePosition()
  );
  if (m) {
    hdr.sform_code = 1;
    hdr.affine = [
      [m[0][0], m[0][1], m[0][2], m[0][3]],
      [m[1][0], m[1][1], m[1][2], m[1][3]],
      [m[2][0], m[2][1], m[2][2], m[2][3]],
      [0, 0, 0, 1],
    ];
  }
  //console.log("DICOM", this.series.images[0]);
  //console.log("NIfTI", hdr);
  let imgRaw = [];
  //let byteLength = hdr.dims[1] * hdr.dims[2] * hdr.dims[3] * (bpv / 8);
  let data;
  let length = this.series.validatePixelDataLength(this.series.images[0]);
  let buffer = new Uint8Array(
    new ArrayBuffer(length * this.series.images.length)
  );
  // implementation copied from:
  // https://github.com/rii-mango/Daikon/blob/bbe08bad9758dfbdf31ca22fb79048c7bad85706/src/series.js#L496
  for (let i = 0; i &lt; this.series.images.length; i++) {
    if (this.series.isMosaic) {
      data = this.series.getMosaicData(
        this.series.images[i],
        this.series.images[i].getPixelDataBytes()
      );
    } else {
      data = this.series.images[i].getPixelDataBytes();
    }
    length = this.series.validatePixelDataLength(this.series.images[i]);
    this.series.images[i].clearPixelData();
    buffer.set(new Uint8Array(data, 0, length), length * i);
  } // for images.length
  imgRaw = buffer.buffer;
  return imgRaw;
}; // readDICOM()

// not included in public docs
// read ECAT7 format image
// https://github.com/openneuropet/PET2BIDS/tree/28aae3fab22309047d36d867c624cd629c921ca6/ecat_validation/ecat_info
NVImage.prototype.readECAT = function (buffer) {
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  var reader = new DataView(buffer);

  let signature = reader.getInt32(0, false); //"MATR"
  let filetype = reader.getInt16(50, false);
  if (signature !== 1296127058 || filetype &lt; 1 || filetype > 14) {
    console.log("Not a valid ECAT file");
    return;
  }
  //list header, starts at 512 bytes: int32_t hdr[4], r[31][4];
  let pos = 512; //512=main header, 4*32-bit hdr
  let vols = 0;
  let frame_duration = [];
  let rawImg = [];
  while (true) {
    //read 512 block lists
    let hdr0 = reader.getInt32(pos, false);
    let hdr3 = reader.getInt32(pos + 12, false);
    if (hdr0 + hdr3 !== 31) break;
    let lpos = pos + 20; //skip hdr and read slice offset (r[0][1])
    let r = 0;
    let voloffset = 0;
    while (r &lt; 31) {
      //r[0][1]...r[30][1]
      voloffset = reader.getInt32(lpos, false);
      lpos += 16; //e.g. r[0][1] to r[1][1]
      if (voloffset === 0) break;
      r++;
      let ipos = voloffset * 512; //image start position
      let spos = ipos - 512; //subheader for matrix image, immediately before image
      let data_type = reader.getUint16(spos, false);
      hdr.dims[1] = reader.getUint16(spos + 4, false);
      hdr.dims[2] = reader.getUint16(spos + 6, false);
      hdr.dims[3] = reader.getUint16(spos + 8, false);
      let scale_factor = reader.getFloat32(spos + 26, false);
      hdr.pixDims[1] = reader.getFloat32(spos + 34, false) * 10.0; //cm -> mm
      hdr.pixDims[2] = reader.getFloat32(spos + 38, false) * 10.0; //cm -> mm
      hdr.pixDims[3] = reader.getFloat32(spos + 42, false) * 10.0; //cm -> mm
      hdr.pixDims[4] = reader.getUint32(spos + 46, false) / 1000.0; //ms -> sec
      frame_duration.push(hdr.pixDims[4]);
      let nvox3D = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
      var newImg = new Float32Array(nvox3D); //convert to float32 as scale varies
      if (data_type == 1)
        //uint8
        for (var i = 0; i &lt; nvox3D; i++) {
          newImg[i] = reader.getUint8(ipos) * scale_factor;
          ipos++;
        }
      else if (data_type == 6) {
        //uint16
        for (var i = 0; i &lt; nvox3D; i++) {
          newImg[i] = reader.getUint16(ipos, false) * scale_factor;
          ipos += 2;
        }
      } else if (ihdr.data_type == 7) {
        //uint32
        for (var i = 0; i &lt; nvox3D; i++) {
          newImg[i] = reader.getUint32(ipos, false) * scale_factor;
          ipos += 4;
        }
      } else console.log("Unknown ECAT data type " + data_type);
      let prevImg = rawImg.slice();
      rawImg = new Float32Array(prevImg.length + newImg.length);
      rawImg.set(prevImg);
      rawImg.set(newImg, prevImg.length);
      vols++;
    }
    if (voloffset === 0) break;
    pos += 512; //possible to have multiple 512-byte lists of images
  }
  hdr.dims[4] = vols;
  hdr.pixDims[4] = frame_duration[0];
  if (vols > 1) {
    hdr.dims[0] = 4;
    let isFDvaries = false;
    for (var i = 0; i &lt; vols; i++)
      if (frame_duration[i] !== frame_duration[0]) isFDvaries = true;
    if (isFDvaries) console.log("Frame durations vary");
  }
  hdr.sform_code = 1;
  hdr.affine = [
    [-hdr.pixDims[1], 0, 0, (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
    [0, -hdr.pixDims[2], 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
    [0, 0, -hdr.pixDims[3], (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
    [0, 0, 0, 1],
  ];
  hdr.numBitsPerVoxel = 32;
  hdr.datatypeCode = this.DT_FLOAT;
  return rawImg;
}; // readECAT()

NVImage.prototype.readV16 = function (buffer) {
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  var reader = new DataView(buffer);
  hdr.dims[1] = reader.getUint16(0, true);
  hdr.dims[2] = reader.getUint16(2, true);
  hdr.dims[3] = reader.getUint16(4, true);
  let nBytes = 2 * hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
  if (nBytes + 6 !== buffer.byteLength)
    console.log("This does not look like a valid BrainVoyager V16 file");
  hdr.numBitsPerVoxel = 16;
  hdr.datatypeCode = this.DT_UINT16;
  console.log("Warning: V16 files have no spatial transforms");
  hdr.affine = [
    [0, 0, -hdr.pixDims[1], (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
    [-hdr.pixDims[2], 0, 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
    [0, -hdr.pixDims[3], 0, (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
    [0, 0, 0, 1],
  ];
  hdr.littleEndian = true;
  return buffer.slice(6);
}; // readV16()

// not included in public docs
// read brainvoyager format VMR image
// https://support.brainvoyager.com/brainvoyager/automation-development/84-file-formats/343-developer-guide-2-6-the-format-of-vmr-files
NVImage.prototype.readVMR = function (buffer) {
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  var reader = new DataView(buffer);
  let version = reader.getUint16(0, true);
  if (version !== 4) console.log("Not a valid version 4 VMR image");
  hdr.dims[1] = reader.getUint16(2, true);
  hdr.dims[2] = reader.getUint16(4, true);
  hdr.dims[3] = reader.getUint16(6, true);
  let nBytes = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
  if (version >= 4) {
    let pos = 8 + nBytes; //offset to post header
    //let xoff = reader.getUint16(pos, true);
    //let yoff = reader.getUint16(pos + 2, true);
    //let zoff = reader.getUint16(pos + 4, true);
    //let framingCube = reader.getUint16(pos + 6, true);
    //let posInfo = reader.getUint32(pos + 8, true);
    //let coordSys = reader.getUint32(pos + 12, true);
    //let XmmStart = reader.getFloat32(pos + 16, true);
    //let YmmStart = reader.getFloat32(pos + 20, true);
    //let ZmmStart = reader.getFloat32(pos + 24, true);
    //let XmmEnd = reader.getFloat32(pos + 28, true);
    //let YmmEnd = reader.getFloat32(pos + 32, true);
    //let ZmmEnd = reader.getFloat32(pos + 36, true);
    //let Xsl = reader.getFloat32(pos + 40, true);
    //let Ysl = reader.getFloat32(pos + 44, true);
    //let Zsl = reader.getFloat32(pos + 48, true);
    //let colDirX = reader.getFloat32(pos + 52, true);
    //let colDirY = reader.getFloat32(pos + 56, true);
    //let colDirZ = reader.getFloat32(pos + 60, true);
    //let nRow = reader.getUint32(pos + 64, true);
    //let nCol = reader.getUint32(pos + 68, true);
    //let FOVrow = reader.getFloat32(pos + 72, true);
    //let FOVcol = reader.getFloat32(pos + 76, true);
    //let sliceThickness = reader.getFloat32(pos + 80, true);
    //let gapThickness = reader.getFloat32(pos + 84, true);
    let nSpatialTransforms = reader.getUint32(pos + 88, true);
    pos = pos + 92;
    if (nSpatialTransforms > 0) {
      let len = buffer.byteLength;
      for (let i = 0; i &lt; nSpatialTransforms; i++) {
        //read variable length name name...
        while (pos &lt; len &amp;&amp; reader.getUint8(pos) !== 0) pos++;
        pos++;
        //let typ = reader.getUint32(pos, true);
        pos += 4;
        //read variable length name name...
        while (pos &lt; len &amp;&amp; reader.getUint8(pos) !== 0) pos++;
        pos++;
        let nValues = reader.getUint32(pos, true);
        pos += 4;
        for (let j = 0; j &lt; nValues; j++) pos += 4;
      }
    }
    //let LRconv = reader.getUint8(pos);
    //let ref = reader.getUint8(pos + 1);
    hdr.pixDims[1] = reader.getFloat32(pos + 2, true);
    hdr.pixDims[2] = reader.getFloat32(pos + 6, true);
    hdr.pixDims[3] = reader.getFloat32(pos + 10, true);
    //let isVer = reader.getUint8(pos + 14);
    //let isTal = reader.getUint8(pos + 15);
    //let minInten = reader.getInt32(pos + 16, true);
    //let meanInten = reader.getInt32(pos + 20, true);
    //let maxInten = reader.getInt32(pos + 24, true);
  }
  console.log("Warning: VMR spatial transform not implemented");
  //if (XmmStart === XmmEnd) { // https://brainvoyager.com/bv/sampledata/index.html??
  hdr.affine = [
    [0, 0, -hdr.pixDims[1], (hdr.dims[1] - 2) * 0.5 * hdr.pixDims[1]],
    [-hdr.pixDims[2], 0, 0, (hdr.dims[2] - 2) * 0.5 * hdr.pixDims[2]],
    [0, -hdr.pixDims[3], 0, (hdr.dims[3] - 2) * 0.5 * hdr.pixDims[3]],
    [0, 0, 0, 1],
  ];
  //}
  console.log(hdr);
  hdr.numBitsPerVoxel = 8;
  hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
  return buffer.slice(8, 8 + nBytes);
}; // readVMR()

// not included in public docs
// read FreeSurfer MGH format image
NVImage.prototype.readMGH = function (buffer) {
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.dims = [3, 1, 1, 1, 0, 0, 0, 0];
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  var raw = buffer;
  var reader = new DataView(raw);
  if (reader.getUint8(0) === 31 &amp;&amp; reader.getUint8(1) === 139) {
    let raw8 = fflate.decompressSync(new Uint8Array(buffer));
    raw = raw8.buffer;
    reader = new DataView(raw);
  }
  let version = reader.getInt32(0, false);
  let width = reader.getInt32(4, false);
  let height = reader.getInt32(8, false);
  let depth = reader.getInt32(12, false);
  let nframes = reader.getInt32(16, false);
  let mtype = reader.getInt32(20, false);
  //let dof = reader.getInt32(24, false);
  //let goodRASFlag = reader.getInt16(28, false);
  let spacingX = reader.getFloat32(30, false);
  let spacingY = reader.getFloat32(34, false);
  let spacingZ = reader.getFloat32(38, false);
  let xr = reader.getFloat32(42, false);
  let xa = reader.getFloat32(46, false);
  let xs = reader.getFloat32(50, false);
  let yr = reader.getFloat32(54, false);
  let ya = reader.getFloat32(58, false);
  let ys = reader.getFloat32(62, false);
  let zr = reader.getFloat32(66, false);
  let za = reader.getFloat32(70, false);
  let zs = reader.getFloat32(74, false);
  //let cr = reader.getFloat32(78, false);
  //let ca = reader.getFloat32(82, false);
  //let cs = reader.getFloat32(86, false);
  if (version !== 1 || mtype &lt; 0 || mtype > 4)
    console.log("Not a valid MGH file");
  if (mtype === 0) {
    hdr.numBitsPerVoxel = 8;
    hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
  } else if (mtype === 4) {
    hdr.numBitsPerVoxel = 16;
    hdr.datatypeCode = this.DT_SIGNED_SHORT;
  } else if (mtype === 1) {
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = this.DT_SIGNED_INT;
  } else if (mtype === 3) {
    hdr.numBitsPerVoxel = 32;
    hdr.datatypeCode = this.DT_FLOAT;
  }
  hdr.dims[1] = width;
  hdr.dims[2] = height;
  hdr.dims[3] = depth;
  hdr.dims[4] = nframes;
  if (nframes > 1) hdr.dims[0] = 4;
  hdr.pixDims[1] = spacingX;
  hdr.pixDims[2] = spacingY;
  hdr.pixDims[3] = spacingZ;
  hdr.vox_offset = 284;
  hdr.sform_code = 1;
  let rot44 = mat4.fromValues(
    xr * hdr.pixDims[1],
    yr * hdr.pixDims[2],
    zr * hdr.pixDims[3],
    0,
    xa * hdr.pixDims[1],
    ya * hdr.pixDims[2],
    za * hdr.pixDims[3],
    0,
    xs * hdr.pixDims[1],
    ys * hdr.pixDims[2],
    zs * hdr.pixDims[3],
    0,
    0,
    0,
    0,
    1
  );
  let base = 0.0; //0 or 1: are voxels indexed from 0 or 1?
  let Pcrs = [
    hdr.dims[1] / 2.0 + base,
    hdr.dims[2] / 2.0 + base,
    hdr.dims[3] / 2.0 + base,
    1,
  ];
  let PxyzOffset = [0, 0, 0, 0];
  for (var i = 0; i &lt; 3; i++) {
    //multiply Pcrs * m
    for (var j = 0; j &lt; 3; j++) {
      PxyzOffset[i] = PxyzOffset[i] + rot44[i + j * 4] * Pcrs[j];
    }
  }
  hdr.affine = [
    [rot44[0], rot44[1], rot44[2], PxyzOffset[0]],
    [rot44[4], rot44[5], rot44[6], PxyzOffset[1]],
    [rot44[8], rot44[9], rot44[10], PxyzOffset[2]],
    [0, 0, 0, 1],
  ];
  let nBytes =
    hdr.dims[1] *
    hdr.dims[2] *
    hdr.dims[3] *
    hdr.dims[4] *
    (hdr.numBitsPerVoxel / 8);
  return raw.slice(hdr.vox_offset, hdr.vox_offset + nBytes);
}; // readMGH()

// not included in public docs
// read AFNI head/brik format image
NVImage.prototype.readHEAD = function (dataBuffer, pairedImgData) {
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.dims[0] = 3;
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  let orientSpecific = [0, 0, 0];
  let xyzOrigin = [0, 0, 0];
  let xyzDelta = [1, 1, 1];
  let txt = new TextDecoder().decode(dataBuffer);
  var lines = txt.split("\n");
  let nlines = lines.length;
  let i = 0;
  let hasIJK_TO_DICOM_REAL = false;
  while (i &lt; nlines) {
    let line = lines[i]; //e.g. 'type = string-attribute'
    i++;
    if (!line.startsWith("type")) continue; //n.b. white space varies, "type =" vs "type  ="
    let isInt = line.includes("integer-attribute");
    let isFloat = line.includes("float-attribute");
    line = lines[i]; //e.g. 'name = IDCODE_DATE'
    i++;
    if (!line.startsWith("name")) continue;
    let items = line.split("= ");
    let key = items[1]; //e.g. 'IDCODE_DATE'
    line = lines[i]; //e.g. 'count = 5'
    i++;
    items = line.split("= ");
    let count = parseInt(items[1]); //e.g. '5'
    if (count &lt; 1) continue;
    line = lines[i]; //e.g. ''LSB_FIRST~'
    i++;
    items = line.trim().split(/\s+/);
    if (isFloat || isInt) {
      //read arrays written on multiple lines
      while (items.length &lt; count) {
        line = lines[i]; //e.g. ''LSB_FIRST~'
        i++;
        let items2 = line.trim().split(/\s+/);
        items.push(...items2);
      }
      for (var j = 0; j &lt; count; j++) items[j] = parseFloat(items[j]);
    }
    switch (key) {
      case "BYTEORDER_STRING":
        if (items[0].includes("LSB_FIRST")) hdr.littleEndian = true;
        else if (items[0].includes("MSB_FIRST")) hdr.littleEndian = false;
        break;
      case "BRICK_TYPES":
        hdr.dims[4] = count;
        let datatype = parseInt(items[0]);
        if (datatype === 0) {
          hdr.numBitsPerVoxel = 8;
          hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
        } else if (datatype === 1) {
          hdr.numBitsPerVoxel = 16;
          hdr.datatypeCode = this.DT_SIGNED_SHORT;
        } else if (datatype === 1) {
          hdr.numBitsPerVoxel = 32;
          hdr.datatypeCode = this.DT_FLOAT;
        } else console.log("Unknown BRICK_TYPES ", datatype);
        break;
      case "IJK_TO_DICOM_REAL":
        if (count &lt; 12) break;
        hasIJK_TO_DICOM_REAL = true;
        hdr.sform_code = 2;
        //note DICOM space is LPS while NIfTI is RAS
        hdr.affine = [
          [-items[0], -items[1], -items[2], -items[3]],
          [-items[4], -items[5], -items[6], -items[7]],
          [items[8], items[9], items[10], items[11]],
          [0, 0, 0, 1],
        ];
        break;
      case "DATASET_DIMENSIONS":
        count = Math.max(count, 3);
        for (var j = 0; j &lt; count; j++) hdr.dims[j + 1] = items[j];
        break;
      case "ORIENT_SPECIFIC":
        orientSpecific = items;
        break;
      case "ORIGIN":
        xyzOrigin = items;
        break;
      case "DELTA":
        xyzDelta = items;
        break;
      case "TAXIS_FLOATS":
        hdr.pixDims[4] = items[0];
        break;
      default:
      //console.log('Unknown:',key);
    } //read item
  } //read all lines
  if (!hasIJK_TO_DICOM_REAL)
    this.THD_daxes_to_NIFTI(xyzDelta, xyzOrigin, orientSpecific);
  else this.SetPixDimFromSForm();
  let nBytes =
    (hdr.numBitsPerVoxel / 8) *
    hdr.dims[1] *
    hdr.dims[2] *
    hdr.dims[3] *
    hdr.dims[4];
  if (pairedImgData.byteLength &lt; nBytes) {
    //n.b. npm run dev implicitly extracts gz, npm run demo does not!
    //assume gz compressed
    var raw = fflate.decompressSync(new Uint8Array(pairedImgData));
    return raw.buffer;
  }
  return pairedImgData.slice();
};

// not included in public docs
// read ITK MHA format image
// https://itk.org/Wiki/ITK/MetaIO/Documentation#Reading_a_Brick-of-Bytes_.28an_N-Dimensional_volume_in_a_single_file.29
NVImage.prototype.readMHA = function (buffer, pairedImgData) {
  let len = buffer.byteLength;
  if (len &lt; 20)
    throw new Error("File too small to be VTK: bytes = " + buffer.byteLength);
  var bytes = new Uint8Array(buffer);
  let pos = 0;
  function readStr() {
    while (pos &lt; len &amp;&amp; bytes[pos] === 10) pos++; //skip blank lines
    let startPos = pos;
    while (pos &lt; len &amp;&amp; bytes[pos] !== 10) pos++;
    pos++; //skip EOLN
    if (pos - startPos &lt; 1) return "";
    return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
  }
  let line = readStr(); //1st line: signature
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.littleEndian = true;
  let isGz = false;
  let isDetached = false;
  let compressedDataSize = 0;
  let mat33 = mat3.fromValues(NaN, 0, 0, 0, 1, 0, 0, 0, 1);
  let offset = vec3.fromValues(0, 0, 0);
  while (line !== "") {
    let items = line.split(" ");
    if (items.length > 2);
    items = items.slice(2);
    if (line.startsWith("BinaryDataByteOrderMSB") &amp;&amp; items[0].includes("False"))
      hdr.littleEndian = true;
    if (line.startsWith("BinaryDataByteOrderMSB") &amp;&amp; items[0].includes("True"))
      hdr.littleEndian = false;
    if (line.startsWith("CompressedData") &amp;&amp; items[0].includes("True"))
      isGz = true;
    if (line.startsWith("CompressedDataSize"))
      compressedDataSize = parseInt(items[0]);
    if (line.startsWith("TransformMatrix")) {
      for (var d = 0; d &lt; 9; d++) mat33[d] = parseFloat(items[d]);
    }
    if (line.startsWith("Offset")) {
      offset[0] = parseFloat(items[0]);
      offset[1] = parseFloat(items[1]);
      offset[2] = parseFloat(items[2]);
    }
    //if (line.startsWith("AnatomicalOrientation")) //we can ignore, tested with Slicer3D converting NIfTIspace images
    if (line.startsWith("ElementSpacing")) {
      hdr.pixDims[1] = parseFloat(items[0]);
      hdr.pixDims[2] = parseFloat(items[1]);
      hdr.pixDims[3] = parseFloat(items[2]);
      if (items.length > 3) hdr.pixDims[4] = parseFloat(items[3]);
    }
    if (line.startsWith("DimSize")) {
      hdr.dims[0] = items.length;
      for (var d = 0; d &lt; items.length; d++)
        hdr.dims[d + 1] = parseInt(items[d]);
    }
    if (line.startsWith("ElementType")) {
      switch (items[0]) {
        case "MET_UCHAR":
          hdr.numBitsPerVoxel = 8;
          hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
          break;
        case "MET_CHAR":
          hdr.numBitsPerVoxel = 8;
          hdr.datatypeCode = this.DT_INT8;
          break;
        case "MET_SHORT":
          hdr.numBitsPerVoxel = 16;
          hdr.datatypeCode = this.DT_SIGNED_SHORT;
          break;
        case "MET_USHORT":
          hdr.numBitsPerVoxel = 16;
          hdr.datatypeCode = this.DT_UINT16;
          break;
        case "MET_INT":
          hdr.numBitsPerVoxel = 32;
          hdr.datatypeCode = this.DT_SIGNED_INT;
          break;
        case "MET_UINT":
          hdr.numBitsPerVoxel = 32;
          hdr.datatypeCode = this.DT_UINT32;
          break;
        case "MET_FLOAT":
          hdr.numBitsPerVoxel = 32;
          hdr.datatypeCode = this.DT_FLOAT;
          break;
        case "MET_DOUBLE":
          hdr.numBitsPerVoxel = 64;
          hdr.datatypeCode = this.DT_DOUBLE;
          break;
        default:
          throw new Error("Unsupported NRRD data type: " + value);
      }
    }
    if (line.startsWith("ObjectType") &amp;&amp; !items[0].includes("Image"))
      console.log("Only able to read ObjectType = Image, not " + line);
    if (line.startsWith("ElementDataFile")) {
      if (items[0] !== "LOCAL") isDetached = true;
      break;
    }
    line = readStr();
  }
  let mmMat = mat3.fromValues(
    hdr.pixDims[1],
    0,
    0,
    0,
    hdr.pixDims[2],
    0,
    0,
    0,
    hdr.pixDims[3]
  );
  mat3.multiply(mat33, mmMat, mat33);
  hdr.affine = [
    [-mat33[0], -mat33[3], -mat33[6], -offset[0]],
    [-mat33[1], -mat33[4], -mat33[7], -offset[1]],
    [mat33[2], mat33[5], mat33[8], offset[2]],
    [0, 0, 0, 1],
  ];
  hdr.vox_offset = pos;
  if (isDetached &amp;&amp; pairedImgData) {
    if (isGz)
      return fflate.decompressSync(new Uint8Array(buffer.slice(hdr.vox_offset)))
        .buffer;
    return pairedImgData.slice();
  }
  if (isGz)
    return fflate.decompressSync(new Uint8Array(buffer.slice(hdr.vox_offset)))
      .buffer;
  return buffer.slice(hdr.vox_offset);
}; //readMHA()

// not included in public docs
// read mrtrix MIF format image
// https://mrtrix.readthedocs.io/en/latest/getting_started/image_data.html#mrtrix-image-formats
NVImage.prototype.readMIF = function (buffer, pairedImgData) {
  //MIF files typically 3D (e.g. anatomical), 4D (fMRI, DWI). 5D rarely seen
  //This read currently supports up to 5D. To create test: "mrcat -axis 4 a4d.mif b4d.mif out5d.mif"
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  hdr.dims = [1, 1, 1, 1, 1, 1, 1, 1];
  let len = buffer.byteLength;
  if (len &lt; 20) throw new Error("File too small to be MIF: bytes = " + len);
  var bytes = new Uint8Array(buffer);
  if (bytes[0] === 31 &amp;&amp; bytes[1] === 139) {
    console.log("MIF with GZ decompression");
    var raw = fflate.decompressSync(new Uint8Array(buffer));
    buffer = raw.buffer;
    len = buffer.byteLength;
  }
  let pos = 0;
  function readStr() {
    while (pos &lt; len &amp;&amp; bytes[pos] === 10) pos++; //skip blank lines
    let startPos = pos;
    while (pos &lt; len &amp;&amp; bytes[pos] !== 10) pos++;
    pos++; //skip EOLN
    if (pos - startPos &lt; 1) return "";
    return new TextDecoder().decode(buffer.slice(startPos, pos - 1));
  }
  let line = readStr(); //1st line: signature 'mrtrix tracks'
  if (!line.startsWith("mrtrix image")) {
    console.log("Not a valid MIF file");
    return;
  }
  let layout = [];
  let nTransform = 0;
  let TR = 0;
  let isDetached = false;
  line = readStr();
  while (pos &lt; len &amp;&amp; !line.startsWith("END")) {
    let items = line.split(":"); // "vox: 1,1,1" -> "vox", " 1,1,1"
    line = readStr();
    if (items.length &lt; 2) break; //
    let tag = items[0]; // "datatype", "dim"
    items = items[1].split(","); // " 1,1,1" -> " 1", "1", "1"
    for (let i = 0; i &lt; items.length; i++) items[i] = items[i].trim(); // " 1", "1", "1" -> "1", "1", "1"
    switch (tag) {
      case "dim":
        hdr.dims[0] = items.length;
        for (let i = 0; i &lt; items.length; i++)
          hdr.dims[i + 1] = parseInt(items[i]);
        break;
      case "vox":
        for (let i = 0; i &lt; items.length; i++) {
          hdr.pixDims[i + 1] = parseFloat(items[i]);
          if (isNaN(hdr.pixDims[i + 1])) hdr.pixDims[i + 1] = 0.0;
        }
        break;
      case "layout":
        for (let i = 0; i &lt; items.length; i++) layout.push(parseInt(items[i])); //n.b. JavaScript preserves sign for -0
        break;
      case "datatype":
        let dt = items[0];
        if (dt.startsWith("Int8")) hdr.datatypeCode = this.DT_INT8;
        else if (dt.startsWith("UInt8"))
          hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
        else if (dt.startsWith("Int16"))
          hdr.datatypeCode = this.DT_SIGNED_SHORT;
        else if (dt.startsWith("UInt16")) hdr.datatypeCode = this.DT_UINT16;
        else if (dt.startsWith("Int32")) hdr.datatypeCode = this.DT_SIGNED_INT;
        else if (dt.startsWith("UInt32")) hdr.datatypeCode = this.DT_UINT32;
        else if (dt.startsWith("Float32")) hdr.datatypeCode = this.DT_FLOAT;
        else if (dt.startsWith("Float64")) hdr.datatypeCode = this.DT_DOUBLE;
        else console.log("Unsupported datatype " + dt);
        if (dt.includes("8")) hdr.numBitsPerVoxel = 8;
        else if (dt.includes("16")) hdr.numBitsPerVoxel = 16;
        else if (dt.includes("32")) hdr.numBitsPerVoxel = 32;
        else if (dt.includes("64")) hdr.numBitsPerVoxel = 64;
        hdr.littleEndian = true; //native, to do support big endian readers
        if (dt.endsWith("LE")) hdr.littleEndian = true;
        if (dt.endsWith("BE")) hdr.littleEndian = false;
        break;
      case "transform":
        if (nTransform > 2 || items.length !== 4) break;
        hdr.affine[nTransform][0] = parseFloat(items[0]);
        hdr.affine[nTransform][1] = parseFloat(items[1]);
        hdr.affine[nTransform][2] = parseFloat(items[2]);
        hdr.affine[nTransform][3] = parseFloat(items[3]);
        nTransform++;
        break;
      case "RepetitionTime":
        TR = parseFloat(items[0]);
        break;
      case "file":
        isDetached = !items[0].startsWith(". ");
        if (!isDetached) {
          items = items[0].split(" "); //". 2336" -> ". ", "2336"
          hdr.vox_offset = parseInt(items[1]);
        }
        break;
    }
  }
  let ndim = hdr.dims[0];
  if (ndim > 5)
    console.log("reader only designed for a maximum of 5 dimensions (XYZTD)");
  let nvox = 1;
  for (let i = 0; i &lt; ndim; i++) nvox *= Math.max(hdr.dims[i + 1], 1);
  console.log(nvox);
  //let nvox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3] * hdr.dims[4];
  for (let i = 0; i &lt; 3; i++) {
    for (let j = 0; j &lt; 3; j++) {
      //hdr.affine[i][j] *= hdr.pixDims[i + 1];
      hdr.affine[i][j] *= hdr.pixDims[j + 1];
    }
  }
  console.log("mif affine:" + hdr.affine[0]);
  if (TR > 0) hdr.pixDims[4] = TR;
  if (isDetached &amp;&amp; !pairedImgData)
    console.log("MIH header provided without paired image data");
  let rawImg = [];
  if (isDetached) rawImg = pairedImgData.slice();
  //n.b. mrconvert can pad files? See dtitest_Siemens_SC 4_dti_nopf_x2_pitch
  else
    rawImg = buffer.slice(
      hdr.vox_offset,
      hdr.vox_offset + nvox * (hdr.numBitsPerVoxel / 8)
    );
  if (layout.length != hdr.dims[0]) console.log("dims does not match layout");
  //estimate strides:
  let stride = 1;
  let instride = [1, 1, 1, 1, 1];
  let inflip = [false, false, false, false, false];
  for (let i = 0; i &lt; layout.length; i++) {
    for (let j = 0; j &lt; layout.length; j++) {
      let a = Math.abs(layout[j]);
      if (a != i) continue;
      instride[j] = stride;
      //detect -0: https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114
      if (layout[j] &lt; 0 || Object.is(layout[j], -0)) inflip[j] = true;
      stride *= hdr.dims[j + 1];
    }
  }
  //lookup table for flips and stride offsets:
  const range = (start, stop, step) =>
    Array.from(
      { length: (stop - start) / step + 1 },
      (_, i) => start + i * step
    );
  let xlut = range(0, hdr.dims[1] - 1, 1);
  if (inflip[0]) xlut = range(hdr.dims[1] - 1, 0, -1);
  for (let i = 0; i &lt; hdr.dims[1]; i++) xlut[i] *= instride[0];
  let ylut = range(0, hdr.dims[2] - 1, 1);
  if (inflip[1]) ylut = range(hdr.dims[2] - 1, 0, -1);
  for (let i = 0; i &lt; hdr.dims[2]; i++) ylut[i] *= instride[1];
  let zlut = range(0, hdr.dims[3] - 1, 1);
  if (inflip[2]) zlut = range(hdr.dims[3] - 1, 0, -1);
  for (let i = 0; i &lt; hdr.dims[3]; i++) zlut[i] *= instride[2];
  let tlut = range(0, hdr.dims[4] - 1, 1);
  if (inflip[3]) tlut = range(hdr.dims[4] - 1, 0, -1);
  for (let i = 0; i &lt; hdr.dims[4]; i++) tlut[i] *= instride[3];
  let dlut = range(0, hdr.dims[5] - 1, 1);
  if (inflip[4]) dlut = range(hdr.dims[5] - 1, 0, -1);
  for (let i = 0; i &lt; hdr.dims[5]; i++) dlut[i] *= instride[4];
  //input and output arrays
  let j = 0;
  let inVs = [];
  let outVs = [];
  if (hdr.numBitsPerVoxel === 8) {
    inVs = new Uint8Array(rawImg);
    outVs = new Uint8Array(nvox);
  } //8bit
  if (hdr.numBitsPerVoxel === 16) {
    inVs = new Uint16Array(rawImg);
    outVs = new Uint16Array(nvox);
  }
  if (hdr.numBitsPerVoxel === 32) {
    inVs = new Uint32Array(rawImg);
    outVs = new Uint32Array(nvox);
  } //32bit
  if (hdr.numBitsPerVoxel === 64) {
    inVs = new BigUint64Array(rawImg);
    outVs = new BigUint64Array(nvox);
  } //64bit
  for (let d = 0; d &lt; hdr.dims[5]; d++) {
    for (let t = 0; t &lt; hdr.dims[4]; t++) {
      for (let z = 0; z &lt; hdr.dims[3]; z++) {
        for (let y = 0; y &lt; hdr.dims[2]; y++) {
          for (let x = 0; x &lt; hdr.dims[1]; x++) {
            outVs[j] = inVs[xlut[x] + ylut[y] + zlut[z] + tlut[t] + dlut[d]];
            j++;
          } //for x
        } //for y
      } //for z
    } //for t (time)
  } // for d (direction, phase/real, etc)
  return outVs;
}; // readMIF()

// not included in public docs
// read NRRD format image
// http://teem.sourceforge.net/nrrd/format.html
NVImage.prototype.readNRRD = function (dataBuffer, pairedImgData) {
  //inspired by parserNRRD.js in https://github.com/xtk
  //Copyright (c) 2012 The X Toolkit Developers &lt;dev@goXTK.com>
  // http://www.opensource.org/licenses/mit-license.php
  this.hdr = new nifti.NIFTI1();
  let hdr = this.hdr;
  hdr.pixDims = [1, 1, 1, 1, 1, 0, 0, 0];
  let len = dataBuffer.byteLength;
  //extract initial text header
  var txt = null;
  var bytes = new Uint8Array(dataBuffer);
  for (var i = 1; i &lt; len; i++) {
    if (bytes[i - 1] == 10 &amp;&amp; bytes[i] == 10) {
      let v = dataBuffer.slice(0, i - 1);
      txt = new TextDecoder().decode(v);
      hdr.vox_offset = i + 1;
      break;
    }
  }
  var lines = txt.split("\n");
  if (!lines[0].startsWith("NRRD")) alert("Invalid NRRD image");
  var n = lines.length;
  let isGz = false;
  let isMicron = false;
  let isDetached = false;
  let mat33 = mat3.fromValues(NaN, 0, 0, 0, 1, 0, 0, 0, 1);
  let offset = vec3.fromValues(0, 0, 0);
  let rot33 = mat3.create();
  for (let i = 1; i &lt; n; i++) {
    let str = lines[i];
    if (str[0] === "#") continue; //comment
    str = str.toLowerCase();
    let items = str.split(":");
    if (items.length &lt; 2) continue;
    let key = items[0].trim();
    let value = items[1].trim();
    value = value.replaceAll(")", " ");
    value = value.replaceAll("(", " ");
    value = value.trim();
    switch (key) {
      case "data file":
        isDetached = true;
        break;
      case "encoding":
        if (value.includes("raw")) isGz = false;
        else if (value.includes("gz")) isGz = true;
        else alert("Unsupported NRRD encoding");
        break;
      case "type":
        switch (value) {
          case "uchar":
          case "unsigned char":
          case "uint8":
          case "uint8_t":
            hdr.numBitsPerVoxel = 8;
            hdr.datatypeCode = this.DT_UNSIGNED_CHAR;
            break;
          case "signed char":
          case "int8":
          case "int8_t":
            hdr.numBitsPerVoxel = 8;
            hdr.datatypeCode = this.DT_INT8;
            break;
          case "short":
          case "short int":
          case "signed short":
          case "signed short int":
          case "int16":
          case "int16_t":
            hdr.numBitsPerVoxel = 16;
            hdr.datatypeCode = this.DT_SIGNED_SHORT;
            break;
          case "ushort":
          case "unsigned short":
          case "unsigned short int":
          case "uint16":
          case "uint16_t":
            hdr.numBitsPerVoxel = 16;
            hdr.datatypeCode = this.DT_UINT16;
            break;
          case "int":
          case "signed int":
          case "int32":
          case "int32_t":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = this.DT_SIGNED_INT;
            break;
          case "uint":
          case "unsigned int":
          case "uint32":
          case "uint32_t":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = this.DT_UINT32;
            break;
          case "float":
            hdr.numBitsPerVoxel = 32;
            hdr.datatypeCode = this.DT_FLOAT;
            break;
          case "double":
            hdr.numBitsPerVoxel = 64;
            hdr.datatypeCode = this.DT_DOUBLE;
            break;
          default:
            throw new Error("Unsupported NRRD data type: " + value);
        }
        break;
      case "spacings":
        let pixdims = value.split(/[ ,]+/);
        for (var d = 0; d &lt; pixdims.length; d++)
          hdr.pixDims[d + 1] = parseFloat(dims[d]);
      case "sizes":
        let dims = value.split(/[ ,]+/);
        hdr.dims[0] = dims.length;
        for (let d = 0; d &lt; dims.length; d++)
          hdr.dims[d + 1] = parseInt(dims[d]);
        break;
      case "endian":
        if (value.includes("little")) hdr.littleEndian = true;
        else if (value.includes("big")) hdr.littleEndian = false;
        break;
      case "space directions":
        let vs = value.split(/[ ,]+/);
        if (vs.length !== 9) break;
        for (var d = 0; d &lt; 9; d++) mat33[d] = parseFloat(vs[d]);
        break;
      case "space origin":
        let ts = value.split(/[ ,]+/);
        if (ts.length !== 3) break;
        offset[0] = parseFloat(ts[0]);
        offset[1] = parseFloat(ts[1]);
        offset[2] = parseFloat(ts[2]);
        break;
      case "space units":
        if (value.includes("microns")) isMicron = true;
        break;
      case "space":
        if (value.includes("right-anterior-superior") || value.includes("RAS"))
          rot33 = mat3.fromValues(
            1,
            0,
            0,

            0,
            1,
            0,

            0,
            0,
            1
          );
        else if (
          value.includes("left-anterior-superior") ||
          value.includes("LAS")
        )
          rot33 = mat3.fromValues(
            -1,
            0,
            0,

            0,
            1,
            0,

            0,
            0,
            1
          );
        else if (
          value.includes("left-posterior-superior") ||
          value.includes("LPS")
        )
          rot33 = mat3.fromValues(
            -1,
            0,
            0,

            0,
            -1,
            0,

            0,
            0,
            1
          );
        else console.log("Unsupported NRRD space value:", value);
        break;
      default:
      //console.log('Unknown:',key);
    } //read line
  } //read all lines
  if (!isNaN(mat33[0])) {
    //if spatial transform provided
    this.hdr.sform_code = 2;
    if (isMicron) {
      //convert micron to mm
      mat4.multiplyScalar(mat33, mat33, 0.001);
      offset[0] *= 0.001;
      offset[1] *= 0.001;
      offset[2] *= 0.001;
    }
    if (rot33[0] &lt; 0) offset[0] = -offset[0]; //origin L&lt;->R
    if (rot33[4] &lt; 0) offset[1] = -offset[1]; //origin A&lt;->P
    if (rot33[8] &lt; 0) offset[2] = -offset[2]; //origin S&lt;->I
    mat3.multiply(mat33, rot33, mat33);
    let mat = mat4.fromValues(
      mat33[0],
      mat33[3],
      mat33[6],
      offset[0],
      mat33[1],
      mat33[4],
      mat33[7],
      offset[1],
      mat33[2],
      mat33[5],
      mat33[8],
      offset[2],
      0,
      0,
      0,
      1
    );
    let mm000 = this.vox2mm([0, 0, 0], mat);
    let mm100 = this.vox2mm([1, 0, 0], mat);
    vec3.subtract(mm100, mm100, mm000);
    let mm010 = this.vox2mm([0, 1, 0], mat);
    vec3.subtract(mm010, mm010, mm000);
    let mm001 = this.vox2mm([0, 0, 1], mat);
    vec3.subtract(mm001, mm001, mm000);
    hdr.pixDims[1] = vec3.length(mm100);
    hdr.pixDims[2] = vec3.length(mm010);
    hdr.pixDims[3] = vec3.length(mm001);
    hdr.affine = [
      [mat[0], mat[1], mat[2], mat[3]],
      [mat[4], mat[5], mat[6], mat[7]],
      [mat[8], mat[9], mat[10], mat[11]],
      [0, 0, 0, 1],
    ];
  }

  if (isDetached &amp;&amp; pairedImgData) {
    //??? .gz files automatically decompressed?
    return pairedImgData.slice();
  }
  if (isDetached)
    console.log(
      "Missing data: NRRD header describes detached data file but only one URL provided"
    );
  if (isGz)
    return fflate.decompressSync(
      new Uint8Array(dataBuffer.slice(hdr.vox_offset))
    ).buffer;
  else return dataBuffer.slice(hdr.vox_offset);
}; //readNRRD()

// not included in public docs
// Transform to orient NIfTI image to Left->Right,Posterior->Anterior,Inferior->Superior (48 possible permutations)
NVImage.prototype.calculateRAS = function () {
  // port of Matlab reorient() https://github.com/xiangruili/dicm2nii/blob/master/nii_viewer.m
  // not elegant, as JavaScript arrays are always 1D
  let a = this.hdr.affine;
  let header = this.hdr;
  let absR = mat3.fromValues(
    Math.abs(a[0][0]),
    Math.abs(a[0][1]),
    Math.abs(a[0][2]),
    Math.abs(a[1][0]),
    Math.abs(a[1][1]),
    Math.abs(a[1][2]),
    Math.abs(a[2][0]),
    Math.abs(a[2][1]),
    Math.abs(a[2][2])
  );
  //1st column = x
  let ixyz = [1, 1, 1];
  if (absR[3] > absR[0]) {
    ixyz[0] = 2; //(absR[1][0] > absR[0][0]) ixyz[0] = 2;
  }
  if (absR[6] > absR[0] &amp;&amp; absR[6] > absR[3]) {
    ixyz[0] = 3; //((absR[2][0] > absR[0][0]) &amp;&amp; (absR[2][0]> absR[1][0])) ixyz[0] = 3;
  } //2nd column = y
  ixyz[1] = 1;
  if (ixyz[0] === 1) {
    if (absR[4] > absR[7]) {
      //(absR[1][1] > absR[2][1])
      ixyz[1] = 2;
    } else {
      ixyz[1] = 3;
    }
  } else if (ixyz[0] === 2) {
    if (absR[1] > absR[7]) {
      //(absR[0][1] > absR[2][1])
      ixyz[1] = 1;
    } else {
      ixyz[1] = 3;
    }
  } else {
    if (absR[1] > absR[4]) {
      //(absR[0][1] > absR[1][1])
      ixyz[1] = 1;
    } else {
      ixyz[1] = 2;
    }
  }
  //3rd column = z: constrained as x+y+z = 1+2+3 = 6
  ixyz[2] = 6 - ixyz[1] - ixyz[0];
  let perm = [1, 2, 3];
  perm[ixyz[0] - 1] = 1;
  perm[ixyz[1] - 1] = 2;
  perm[ixyz[2] - 1] = 3;
  let rotM = mat4.fromValues(
    a[0][0],
    a[0][1],
    a[0][2],
    a[0][3],
    a[1][0],
    a[1][1],
    a[1][2],
    a[1][3],
    a[2][0],
    a[2][1],
    a[2][2],
    a[2][3],
    0,
    0,
    0,
    1
  );
  //n.b. 0.5 in these values to account for voxel centers, e.g. a 3-pixel wide bitmap in unit space has voxel centers at 0.25, 0.5 and 0.75
  this.mm000 = this.vox2mm([-0.5, -0.5, -0.5], rotM);
  this.mm100 = this.vox2mm([header.dims[1] - 0.5, -0.5, -0.5], rotM);
  this.mm010 = this.vox2mm([-0.5, header.dims[2] - 0.5, -0.5], rotM);
  this.mm001 = this.vox2mm([-0.5, -0.5, header.dims[3] - 0.5], rotM);
  let R = mat4.create();
  mat4.copy(R, rotM);
  for (let i = 0; i &lt; 3; i++) {
    for (let j = 0; j &lt; 3; j++) {
      R[i * 4 + j] = rotM[i * 4 + perm[j] - 1]; //rotM[i+(4*(perm[j]-1))];//rotM[i],[perm[j]-1];
    }
  }
  let flip = [0, 0, 0];
  if (R[0] &lt; 0) flip[0] = 1; //R[0][0]
  if (R[5] &lt; 0) flip[1] = 1; //R[1][1]
  if (R[10] &lt; 0) flip[2] = 1; //R[2][2]
  this.dimsRAS = [
    header.dims[0],
    header.dims[perm[0]],
    header.dims[perm[1]],
    header.dims[perm[2]],
  ];
  this.pixDimsRAS = [
    header.pixDims[0],
    header.pixDims[perm[0]],
    header.pixDims[perm[1]],
    header.pixDims[perm[2]],
  ];
  this.permRAS = perm.slice();
  for (let i = 0; i &lt; 3; i++)
    if (flip[i] === 1) this.permRAS[i] = -this.permRAS[i];
  if (this.arrayEquals(perm, [1, 2, 3]) &amp;&amp; this.arrayEquals(flip, [0, 0, 0])) {
    this.toRAS = mat4.create(); //aka fromValues(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
    this.matRAS = mat4.clone(rotM);
    this.calculateOblique();
    return; //no rotation required!
  }
  mat4.identity(rotM);
  rotM[0 + 0 * 4] = 1 - flip[0] * 2;
  rotM[1 + 1 * 4] = 1 - flip[1] * 2;
  rotM[2 + 2 * 4] = 1 - flip[2] * 2;
  rotM[3 + 0 * 4] = (header.dims[perm[0]] - 1) * flip[0];
  rotM[3 + 1 * 4] = (header.dims[perm[1]] - 1) * flip[1];
  rotM[3 + 2 * 4] = (header.dims[perm[2]] - 1) * flip[2];
  let residualR = mat4.create();
  mat4.invert(residualR, rotM);
  mat4.multiply(residualR, residualR, R);
  this.matRAS = mat4.clone(residualR);
  rotM = mat4.fromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
  rotM[perm[0] - 1 + 0 * 4] = -flip[0] * 2 + 1;
  rotM[perm[1] - 1 + 1 * 4] = -flip[1] * 2 + 1;
  rotM[perm[2] - 1 + 2 * 4] = -flip[2] * 2 + 1;
  rotM[3 + 0 * 4] = flip[0];
  rotM[3 + 1 * 4] = flip[1];
  rotM[3 + 2 * 4] = flip[2];
  this.toRAS = mat4.clone(rotM);
  log.debug(this.hdr.dims);
  log.debug(this.dimsRAS);
  this.calculateOblique();
};

// not included in public docs
// convert voxel location (row, column slice, indexed from 0) to world space
NVImage.prototype.vox2mm = function (XYZ, mtx) {
  let sform = mat4.clone(mtx);
  mat4.transpose(sform, sform);
  let pos = vec4.fromValues(XYZ[0], XYZ[1], XYZ[2], 1);
  vec4.transformMat4(pos, pos, sform);
  let pos3 = vec3.fromValues(pos[0], pos[1], pos[2]);
  return pos3;
}; // vox2mm()

// not included in public docs
// convert world space to voxel location (row, column slice, indexed from 0)
NVImage.prototype.mm2vox = function (mm) {
  let sform = mat4.fromValues(...this.hdr.affine.flat());
  let out = mat4.clone(sform);
  mat4.transpose(out, sform);
  mat4.invert(out, out);
  let pos = vec4.fromValues(mm[0], mm[1], mm[2], 1);
  vec4.transformMat4(pos, pos, out);
  let pos3 = vec3.fromValues(pos[0], pos[1], pos[2]);
  return [Math.round(pos3[0]), Math.round(pos3[1]), Math.round(pos3[2])];
}; // vox2mm()

// not included in public docs
// returns boolean: are two arrays identical?
NVImage.prototype.arrayEquals = function (a, b) {
  return (
    Array.isArray(a) &amp;&amp;
    Array.isArray(b) &amp;&amp;
    a.length === b.length &amp;&amp;
    a.every((val, index) => val === b[index])
  );
};

/**
 * query all available color maps that can be applied to volumes
 * @param {boolean} [sort=true] whether or not to sort the returned array
 * @returns {array} an array of colormap strings
 * @example
 * myImage = NVImage.loadFromUrl('./someURL/someFile.nii.gz')
 * colormaps = myImage.colorMaps()
 */
NVImage.prototype.colorMaps = function (sort = true) {
  let cm = [];
  for (const [key] of Object.entries(cmaps)) {
    cm.push(key);
  }
  return sort === true ? cm.sort() : cm;
};

// not included in public docs
// base function for niivue.setColorMap()
NVImage.prototype.setColorMap = function (cm) {
  let allColorMaps = this.colorMaps();
  if (allColorMaps.indexOf(cm.toLowerCase()) !== -1) {
    this.colorMap = cm.toLowerCase();
    this.calMinMax();
  } else {
    log.warn(`color map ${cm} is not a valid color map`);
  }
};

// not included in public docs
// given an overlayItem and its img TypedArray, calculate 2% and 98% display range if needed
//clone FSL robust_range estimates https://github.com/rordenlab/niimath/blob/331758459140db59290a794350d0ff3ad4c37b67/src/core32.c#L1215
//ToDo: convert to web assembly, this is slow in JavaScript
NVImage.prototype.calMinMax = function () {
  let cm = this.colorMap;
  let allColorMaps = this.colorMaps();
  let cmMin = 0;
  let cmMax = 0;
  if (allColorMaps.indexOf(cm.toLowerCase()) !== -1) {
    cmMin = cmaps[cm.toLowerCase()].min;
    cmMax = cmaps[cm.toLowerCase()].max;
  }

  if (
    cmMin === cmMax &amp;&amp;
    this.trustCalMinMax &amp;&amp;
    isFinite(this.hdr.cal_min) &amp;&amp;
    isFinite(this.hdr.cal_max) &amp;&amp;
    this.hdr.cal_max > this.hdr.cal_min
  ) {
    this.cal_min = this.hdr.cal_min;
    this.cal_max = this.hdr.cal_max;
    this.robust_min = this.cal_min;
    this.robust_max = this.cal_max;
    this.global_min = this.hdr.cal_min;
    this.global_max = this.hdr.cal_max;
    return [
      this.hdr.cal_min,
      this.hdr.cal_max,
      this.hdr.cal_min,
      this.hdr.cal_max,
    ];
  }
  // if color map specifies non zero values for min and max then use them
  if (cmMin != cmMax) {
    this.cal_min = cmMin;
    this.cal_max = cmMax;
    this.robust_min = this.cal_min;
    this.robust_max = this.cal_max;
    return [cmMin, cmMax, cmMin, cmMax];
  }
  //determine full range: min..max
  let mn = this.img[0];
  let mx = this.img[0];
  let nZero = 0;
  let nNan = 0;
  let nVox = this.img.length;
  for (let i = 0; i &lt; nVox; i++) {
    if (isNaN(this.img[i])) {
      nNan++;
      continue;
    }
    if (this.img[i] === 0) {
      nZero++;
      if (this.ignoreZeroVoxels) {
        continue;
      }
    }
    mn = Math.min(this.img[i], mn);
    mx = Math.max(this.img[i], mx);
  }
  var mnScale = this.intensityRaw2Scaled(this.hdr, mn);
  var mxScale = this.intensityRaw2Scaled(this.hdr, mx);
  if (!this.ignoreZeroVoxels) nZero = 0;
  nZero += nNan;
  let n2pct = Math.round((nVox - nZero) * this.percentileFrac);
  if (n2pct &lt; 1 || mn === mx) {
    log.debug("no variability in image intensity?");
    this.cal_min = mnScale;
    this.cal_max = mxScale;
    this.robust_min = this.cal_min;
    this.robust_max = this.cal_max;
    this.global_min = mnScale;
    this.global_max = mxScale;
    return [mnScale, mxScale, mnScale, mxScale];
  }
  let nBins = 1001;
  let scl = (nBins - 1) / (mx - mn);
  let hist = new Array(nBins);
  for (let i = 0; i &lt; nBins; i++) {
    hist[i] = 0;
  }
  if (this.ignoreZeroVoxels) {
    for (let i = 0; i &lt;= nVox; i++) {
      if (this.img[i] === 0) continue;
      if (isNaN(this.img[i])) continue;
      hist[Math.round((this.img[i] - mn) * scl)]++;
    }
  } else {
    for (let i = 0; i &lt;= nVox; i++) {
      if (isNaN(this.img[i])) {
        continue;
      }
      hist[Math.round((this.img[i] - mn) * scl)]++;
    }
  }
  let n = 0;
  let lo = 0;
  while (n &lt; n2pct) {
    n += hist[lo];
    lo++;
  }
  lo--; //remove final increment
  n = 0;
  let hi = nBins;
  while (n &lt; n2pct) {
    hi--;
    n += hist[hi];
  }
  if (lo == hi) {
    //MAJORITY are not black or white
    let ok = -1;
    while (ok !== 0) {
      if (lo > 0) {
        lo--;
        if (hist[lo] > 0) ok = 0;
      }
      if (ok != 0 &amp;&amp; hi &lt; nBins - 1) {
        hi++;
        if (hist[hi] > 0) ok = 0;
      }
      if (lo == 0 &amp;&amp; hi == nBins - 1) ok = 0;
    } //while not ok
  } //if lo == hi
  var pct2 = this.intensityRaw2Scaled(this.hdr, lo / scl + mn);
  var pct98 = this.intensityRaw2Scaled(this.hdr, hi / scl + mn);
  if (
    this.hdr.cal_min &lt; this.hdr.cal_max &amp;&amp;
    this.hdr.cal_min >= mnScale &amp;&amp;
    this.hdr.cal_max &lt;= mxScale
  ) {
    pct2 = this.hdr.cal_min;
    pct98 = this.hdr.cal_max;
  }
  this.cal_min = pct2;
  this.cal_max = pct98;
  this.robust_min = this.cal_min;
  this.robust_max = this.cal_max;
  this.global_min = mnScale;
  this.global_max = mxScale;
  return [pct2, pct98, mnScale, mxScale];
}; //calMinMax

// not included in public docs
// convert voxel intesnity from stored value to scaled intensity
NVImage.prototype.intensityRaw2Scaled = function (hdr, raw) {
  if (hdr.scl_slope === 0) hdr.scl_slope = 1.0;
  return raw * hdr.scl_slope + hdr.scl_inter;
};

// not included in public docs
function str2Buffer(str) {
  //emulate node.js Buffer.from
  var bytes = [];
  for (var i = 0; i &lt; str.length; i++) {
    var char = str.charCodeAt(i);
    bytes.push(char &amp; 0xff);
  }
  return bytes;
}

// not included in public docs
// save NIfTI header into UINT8 array for saving to disk
function hdrToArrayBuffer(hdr, isDrawing8 = false) {
  const SHORT_SIZE = 2;
  const FLOAT32_SIZE = 4;

  let byteArray = new Uint8Array(348);
  let view = new DataView(byteArray.buffer);
  // sizeof_hdr
  view.setInt32(0, 348, hdr.littleEndian);

  // data_type, db_name, extents, session_error, regular are not used

  // dim_info
  view.setUint8(39, hdr.dim_info);

  // dims
  for (let i = 0; i &lt; 8; i++) {
    view.setUint16(40 + SHORT_SIZE * i, hdr.dims[i], hdr.littleEndian);
  }

  // intent_p1, intent_p2, intent_p3
  view.setFloat32(56, hdr.intent_p1, hdr.littleEndian);
  view.setFloat32(60, hdr.intent_p2, hdr.littleEndian);
  view.setFloat32(64, hdr.intent_p3, hdr.littleEndian);
  // intent_code, datatype, bitpix, slice_start
  view.setInt16(68, hdr.intent_code, hdr.littleEndian);
  if (isDrawing8) {
    view.setInt16(70, 2, hdr.littleEndian); //2 = DT_UNSIGNED_CHAR
    view.setInt16(72, 8, hdr.littleEndian);
  } else {
    view.setInt16(70, hdr.datatypeCode, hdr.littleEndian);
    view.setInt16(72, hdr.numBitsPerVoxel, hdr.littleEndian);
  }
  view.setInt16(74, hdr.slice_start, hdr.littleEndian);

  // pixdim[8], vox_offset, scl_slope, scl_inter
  for (let i = 0; i &lt; 8; i++) {
    view.setFloat32(76 + FLOAT32_SIZE * i, hdr.pixDims[i], hdr.littleEndian);
  }
  if (isDrawing8) {
    view.setFloat32(108, 352, hdr.littleEndian);
    view.setFloat32(112, 1.0, hdr.littleEndian);
    view.setFloat32(116, 0.0, hdr.littleEndian);
  } else {
    view.setFloat32(108, hdr.vox_offset, hdr.littleEndian);
    view.setFloat32(112, hdr.scl_slope, hdr.littleEndian);
    view.setFloat32(116, hdr.scl_inter, hdr.littleEndian);
  }
  // slice_end
  view.setInt16(120, hdr.slice_end, hdr.littleEndian);

  // slice_code, xyzt_units
  view.setUint8(122, hdr.slice_code);
  view.setUint8(123, hdr.xyzt_units);

  // cal_max, cal_min, slice_duration, toffset
  if (isDrawing8) {
    view.setFloat32(124, 0, hdr.littleEndian);
    view.setFloat32(128, 0, hdr.littleEndian);
  } else {
    view.setFloat32(124, hdr.cal_max, hdr.littleEndian);
    view.setFloat32(128, hdr.cal_min, hdr.littleEndian);
  }
  view.setFloat32(132, hdr.slice_duration, hdr.littleEndian);
  view.setFloat32(136, hdr.toffset, hdr.littleEndian);

  // glmax, glmin are unused

  // descrip and aux_file
  //node.js byteArray.set(Buffer.from(hdr.description), 148);
  byteArray.set(str2Buffer(hdr.description), 148);
  //node.js: byteArray.set(Buffer.from(hdr.aux_file), 228);
  byteArray.set(str2Buffer(hdr.aux_file), 228);
  // qform_code, sform_code
  view.setInt16(252, hdr.qform_code, hdr.littleEndian);
  view.setInt16(254, hdr.sform_code, hdr.littleEndian);

  // quatern_b, quatern_c, quatern_d, qoffset_x, qoffset_y, qoffset_z, srow_x[4], srow_y[4], and srow_z[4]
  view.setFloat32(256, hdr.quatern_b, hdr.littleEndian);
  view.setFloat32(260, hdr.quatern_c, hdr.littleEndian);
  view.setFloat32(264, hdr.quatern_d, hdr.littleEndian);
  view.setFloat32(268, hdr.qoffset_x, hdr.littleEndian);
  view.setFloat32(272, hdr.qoffset_y, hdr.littleEndian);
  view.setFloat32(276, hdr.qoffset_z, hdr.littleEndian);
  const flattened = hdr.affine.flat();
  // we only want the first three rows
  for (let i = 0; i &lt; 12; i++) {
    view.setFloat32(280 + FLOAT32_SIZE * i, flattened[i], hdr.littleEndian);
  }
  //node.js https://www.w3schools.com/nodejs/met_buffer_from.asp
  // intent_name and magic
  //node.js byteArray.set(Buffer.from(hdr.intent_name), 328);
  byteArray.set(str2Buffer(hdr.intent_name), 328);
  //node.js byteArray.set(Buffer.from(hdr.magic), 344);
  byteArray.set(str2Buffer(hdr.magic), 344);
  return byteArray;
  //return byteArray.buffer;
} // hdrToArrayBuffer()

// not included in public docs
// see niivue.saveImage() for wrapper of this function
NVImage.prototype.saveToDisk = async function (fnm, drawing8 = null) {
  let isDrawing8 = !(drawing8 == null);
  let hdrBytes = hdrToArrayBuffer(this.hdr, isDrawing8);
  let opad = new Uint8Array(4);
  let img8 = new Uint8Array(this.img.buffer);
  if (isDrawing8) img8 = new Uint8Array(drawing8.buffer);
  var odata = new Uint8Array(hdrBytes.length + opad.length + img8.length);
  odata.set(hdrBytes);
  odata.set(opad, hdrBytes.length);

  odata.set(img8, hdrBytes.length + opad.length);
  let saveData = null;
  let compress = fnm.endsWith(".gz"); // true if name ends with .gz
  if (compress) {
    saveData = fflate.gzipSync(odata, {
      // GZIP-specific: the filename to use when decompressed
      filename: fnm,
      // GZIP-specific: the modification time. Can be a Date, date string,
      // or Unix timestamp
      mtime: Date.now(),
      level: 6, // the default
    });
  } else {
    saveData = odata;
  }
  let blob = new Blob([saveData.buffer], { type: "application/octet-stream" });
  let blobUrl = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.setAttribute("href", blobUrl);
  link.setAttribute("download", fnm);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}; // saveToDisk()

/**
 * factory function to load and return a new NVImage instance from a given URL
 * @constructs NVImage
 * @param {NVImageOptions} options
 * @returns {NVImage} returns a NVImage intance
 * @example
 * myImage = NVImage.loadFromUrl('./someURL/image.nii.gz') // must be served from a server (local or remote)
 */
NVImage.loadFromUrl = async function ({
  url = "",
  urlImgData = "",
  name = "",
  colorMap = "gray",
  opacity = 1.0,
  cal_min = NaN,
  cal_max = NaN,
  trustCalMinMax = true,
  percentileFrac = 0.02,
  ignoreZeroVoxels = false,
  visible = true,
  colorMapNegative = "",
} = {}) {
  if (url === "") {
    throw Error("url must not be empty");
  }
  let response = await fetch(url);
  let nvimage = null;
  if (!response.ok) {
    throw Error(response.statusText);
  }
  var re = /(?:\.([^.]+))?$/;
  let ext = "";
  if (name === "") {
    ext = re.exec(url)[1];
  } else {
    ext = re.exec(name)[1];
  }
  if (ext.toUpperCase() === "NHDR") {
    if (urlImgData === "") {
    }
  } else if (ext.toUpperCase() === "HEAD") {
    if (urlImgData === "") {
      urlImgData = url.substring(0, url.lastIndexOf("HEAD")) + "BRIK";
    }
  }
  let urlParts;
  if (name === "") {
    try {
      // if a full url like https://domain/path/file.nii.gz?query=filter
      // parse the url and get the pathname component without the query
      urlParts = new URL(url).pathname.split("/");
    } catch (e) {
      // if a relative url then parse the path (assuming no query)
      urlParts = url.split("/");
    }
    name = urlParts.slice(-1)[0]; // name will be last part of url (e.g. some/url/image.nii.gz --> image.nii.gz
    if (name.indexOf("?") > -1) {
      name = name.slice(0, name.indexOf("?")); //remove query string if any
    }
  }

  let dataBuffer = await response.arrayBuffer();
  let pairedImgData = null;
  if (urlImgData.length > 0) {
    let resp = await fetch(urlImgData);
    if (resp.status === 404) {
      if (urlImgData.lastIndexOf("BRIK") !== -1) {
        resp = await fetch(urlImgData + ".gz");
      }
    }
    pairedImgData = await resp.arrayBuffer();
  }

  if (dataBuffer) {
    nvimage = new NVImage(
      dataBuffer,
      name,
      colorMap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      visible,
      false,
      false,
      colorMapNegative
    );
  } else {
    alert("Unable to load buffer properly from volume");
  }

  return nvimage;
};

// not included in public docs
// loading Nifti files
NVImage.readFileAsync = function (file) {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = () => {
      if (file.name.lastIndexOf("gz") !== -1) {
        resolve(nifti.decompress(reader.result));
      } else {
        resolve(reader.result);
      }
    };

    reader.onerror = reject;

    reader.readAsArrayBuffer(file);
  });
};

/**
 * factory function to load and return a new NVImage instance from a file in the browser
 * @constructs NVImage
 * @param {string} file the file object
 * @param {string} [name=''] a name for this image. Default is an empty string
 * @param {string} [colorMap='gray'] a color map to use. default is gray
 * @param {number} [opacity=1.0] the opacity for this image. default is 1
 * @param {string} [urlImgData=null] Allows loading formats where header and image are separate files (e.g. nifti.hdr, nifti.img)
 * @param {number} [cal_min=NaN] minimum intensity for color brightness/contrast
 * @param {number} [cal_max=NaN] maximum intensity for color brightness/contrast
 * @param {boolean} [trustCalMinMax=true] whether or not to trust cal_min and cal_max from the nifti header (trusting results in faster loading)
 * @param {number} [percentileFrac=0.02] the percentile to use for setting the robust range of the display values (smart intensity setting for images with large ranges)
 * @param {boolean} [ignoreZeroVoxels=false] whether or not to ignore zero voxels in setting the robust range of display values
 * @param {boolean} [visible=true] whether or not this image is to be visible
 * @param {boolean} [isDICOMDIR=true] input is DICOM folder, not a single file
 * @returns {NVImage} returns a NVImage intance
 * @example
 * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
 */
NVImage.loadFromFile = async function ({
  file = null, // file can be an array of file objects or a single file object
  name = "",
  colorMap = "gray",
  opacity = 1.0,
  urlImgData = null,
  cal_min = NaN,
  cal_max = NaN,
  trustCalMinMax = true,
  percentileFrac = 0.02,
  ignoreZeroVoxels = false,
  visible = true,
  isDICOMDIR = false,
} = {}) {
  let nvimage = null;
  let dataBuffer = [];
  try {
    if (Array.isArray(file)) {
      for (let i = 0; i &lt; file.length; i++) {
        dataBuffer.push(await this.readFileAsync(file[i]));
      }
    } else {
      dataBuffer = await this.readFileAsync(file);
      name = file.name;
    }
    let pairedImgData = null;
    if (urlImgData) {
      pairedImgData = await this.readFileAsync(urlImgData);
    }
    nvimage = new NVImage(
      dataBuffer,
      name,
      colorMap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      visible,
      isDICOMDIR
    );
  } catch (err) {
    console.log(err);
    log.debug(err);
  }
  return nvimage;
};

// not included in public docs
NVImage.loadFromBase64 = async function ({
  base64 = null,
  name = "",
  colorMap = "gray",
  opacity = 1.0,
  cal_min = NaN,
  cal_max = NaN,
  trustCalMinMax = true,
  percentileFrac = 0.02,
  ignoreZeroVoxels = false,
  visible = true,
} = {}) {
  //https://stackoverflow.com/questions/21797299/convert-base64-string-to-arraybuffer
  function base64ToArrayBuffer(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i &lt; len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
  }

  let nvimage = null;
  try {
    let dataBuffer = base64ToArrayBuffer(base64);
    let pairedImgData = null;
    nvimage = new NVImage(
      dataBuffer,
      name,
      colorMap,
      opacity,
      pairedImgData,
      cal_min,
      cal_max,
      trustCalMinMax,
      percentileFrac,
      ignoreZeroVoxels,
      visible
    );
  } catch (err) {
    log.debug(err);
  }
  return nvimage;
};

/**
 * make a clone of a NVImage instance and return a new NVImage
 * @returns {NVImage} returns a NVImage intance
 * @example
 * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
 * clonedImage = myImage.clone()
 */
NVImage.prototype.clone = function () {
  let clonedImage = new NVImage();
  clonedImage.id = this.id;
  clonedImage.hdr = Object.assign({}, this.hdr);
  clonedImage.img = this.img.slice();
  clonedImage.calculateRAS();
  clonedImage.calMinMax();
  return clonedImage;
};

/**
 * fill a NVImage instance with zeros for the image data
 * @example
 * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
 * clonedImageWithZeros = myImage.clone().zeroImage()
 */
NVImage.prototype.zeroImage = function () {
  this.img.fill(0);
};

/**
 * Image M.
 * @typedef {Object} NVImageMetadata
 * @property {string} id - unique if of image
 * @property {number} datatypeCode - data type
 * @property {number} nx - number of columns
 * @property {number} ny - number of rows
 * @property {number} nz - number of slices
 * @property {number} nt - number of volumes
 * @property {number} dx - space between columns
 * @property {number} dy - space between rows
 * @property {number} dz - space between slices
 * @property {number} dt - time between volumes
 * @property {number} bpx - bits per voxel
 */

/**
 * get nifti specific metadata about the image
 * @returns {NVImageMetadata} - {@link NVImageMetadata}
 */
NVImage.prototype.getImageMetadata = function () {
  const id = this.id;
  const datatypeCode = this.hdr.datatypeCode;
  const dims = this.hdr.dims;
  const nx = dims[1];
  const ny = dims[2];
  const nz = dims[3];
  const nt = Math.max(1, dims[4]);
  const pixDims = this.hdr.pixDims;
  const dx = pixDims[1];
  const dy = pixDims[2];
  const dz = pixDims[3];
  const dt = pixDims[4];
  const bpv = Math.floor(this.hdr.numBitsPerVoxel / 8);

  return {
    id,
    datatypeCode,
    nx,
    ny,
    nz,
    nt,
    dx,
    dy,
    dz,
    dt,
    bpv,
  };
};

/**
 * a factory function to make a zero filled image given a NVImage as a reference
 * @param {NVImage} nvImage an existing NVImage as a reference
 * @param {dataType} string the output data type. Options: 'same', 'uint8'
 * @returns {NVImage} returns a new NVImage filled with zeros for the image data
 * @example
 * myImage = NVImage.loadFromFile(SomeFileObject) // files can be from dialogs or drag and drop
 * newZeroImage = NVImage.zerosLike(myImage)
 */
NVImage.zerosLike = function (nvImage, dataType = "same") {
  // dataType can be: 'same', 'uint8'
  // 'same' means that the zeroed image data type is the same as the input image
  let zeroClone = nvImage.clone();
  zeroClone.zeroImage();
  if (dataType === "uint8") {
    zeroClone.img = Uint8Array.from(zeroClone.img);
    zeroClone.hdr.datatypeCode = zeroClone.DT_UNSIGNED_CHAR;
    zeroClone.hdr.numBitsPerVoxel = 8;
  }
  return zeroClone;
};

// not included in public docs
String.prototype.getBytes = function () {
  //CR??? What does this do?
  let bytes = [];
  for (var i = 0; i &lt; this.length; i++) {
    bytes.push(this.charCodeAt(i));
  }

  return bytes;
};

// not included in public docs
// return voxel intensity at specific coordinates (xyz are zero indexed column row, slice)
NVImage.prototype.getValue = function (x, y, z, frame4D = 0) {
  const { nx, ny, nz } = this.getImageMetadata();
  if (this.hdr.datatypeCode === this.DT_RGBA32) {
    let vx = 4 * (x + y * nx + z * nx * ny);
    //convert rgb to luminance
    return Math.round(
      this.img[vx] * 0.21 + this.img[vx + 1] * 0.72 + this.img[vx + 2] * 0.07
    );
  }
  if (this.hdr.datatypeCode === this.DT_RGB) {
    let vx = 3 * (x + y * nx + z * nx * ny);
    //convert rgb to luminance
    return Math.round(
      this.img[vx] * 0.21 + this.img[vx + 1] * 0.72 + this.img[vx + 2] * 0.07
    );
  }
  let vol = frame4D * nx * ny * nz;
  let i = this.img[x + y * nx + z * nx * ny + vol];
  return this.hdr.scl_slope * i + this.hdr.scl_inter;
};

/**
 * @typedef {Object} NVImage~Extents
 * @property {number[]} min - min bounding point
 * @property {number[]} max - max bounding point
 * @property {number} furthestVertexFromOrigin - point furthest from origin
 */

/**
 *
 * @param {number[]} positions
 * @returns {NVImage~Extents}
 */
function getExtents(positions, forceOriginInVolume = true) {
  let nV = (positions.length / 3).toFixed(); //each vertex has 3 components: XYZ
  let origin = vec3.fromValues(0, 0, 0); //default center of rotation
  let mn = vec3.create();
  let mx = vec3.create();
  let mxDx = 0.0;
  let nLoops = 1;
  if (forceOriginInVolume) nLoops = 2; //second pass to reposition origin
  for (let loop = 0; loop &lt; nLoops; loop++) {
    mxDx = 0.0;
    for (let i = 0; i &lt; nV; i++) {
      let v = vec3.fromValues(
        positions[i * 3],
        positions[i * 3 + 1],
        positions[i * 3 + 2]
      );
      if (i === 0) {
        vec3.copy(mn, v);
        vec3.copy(mx, v);
      }
      vec3.min(mn, mn, v);
      vec3.max(mx, mx, v);
      vec3.subtract(v, v, origin);
      let dx = vec3.len(v);
      mxDx = Math.max(mxDx, dx);
    }
    if (loop + 1 >= nLoops) break;
    let ok = true;
    for (let j = 0; j &lt; 3; ++j) {
      if (mn[j] > origin[j]) ok = false;
      if (mx[j] &lt; origin[j]) ok = false;
    }
    if (ok) break;
    vec3.lerp(origin, mn, mx, 0.5);
    log.debug("origin moved inside volume: ", origin);
  }
  let min = [mn[0], mn[1], mn[2]];
  let max = [mx[0], mx[1], mx[2]];
  let furthestVertexFromOrigin = mxDx;
  return { min, max, furthestVertexFromOrigin, origin };
}

// returns the left, right, up, down, front and back via pixdims, qform or sform
// +x = Right  +y = Anterior  +z = Superior.
// https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/qsform.html

/**
 * calculate cuboid extents via pixdims * dims
 * @returns {number[]}
 */

/**
 * @param {number} id - id of 3D Object (is this the base volume or an overlay?)
 * @param {WebGLRenderingContext} gl - WebGL rendering context
 * @returns {NiivueObject3D} returns a new 3D object in model space
 */
NVImage.prototype.toNiivueObject3D = function (id, gl) {
  //cube has 8 vertices: left/right, posterior/anterior, inferior/superior
  //n.b. voxel coordinates are from VOXEL centers
  // add/subtract 0.5 to get full image field of view
  let L = -0.5;
  let P = -0.5;
  let I = -0.5;
  let R = this.dimsRAS[1] - 1 + 0.5;
  let A = this.dimsRAS[2] - 1 + 0.5;
  let S = this.dimsRAS[3] - 1 + 0.5;

  let LPI = this.vox2mm([L, P, I], this.matRAS);
  let LAI = this.vox2mm([L, A, I], this.matRAS);
  let LPS = this.vox2mm([L, P, S], this.matRAS);
  let LAS = this.vox2mm([L, A, S], this.matRAS);
  let RPI = this.vox2mm([R, P, I], this.matRAS);
  let RAI = this.vox2mm([R, A, I], this.matRAS);
  let RPS = this.vox2mm([R, P, S], this.matRAS);
  let RAS = this.vox2mm([R, A, S], this.matRAS);

  let posTex = [
    //spatial position (XYZ), texture coordinates UVW
    // Superior face
    ...LPS,
    ...[0.0, 0.0, 1.0],
    ...RPS,
    ...[1.0, 0.0, 1.0],
    ...RAS,
    ...[1.0, 1.0, 1.0],
    ...LAS,
    ...[0.0, 1.0, 1.0],

    // Inferior face
    ...LPI,
    ...[0.0, 0.0, 0.0],
    ...LAI,
    ...[0.0, 1.0, 0.0],
    ...RAI,
    ...[1.0, 1.0, 0.0],
    ...RPI,
    ...[1.0, 0.0, 0.0],
  ];

  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

  // This array defines each face as two triangles, using the
  // indices into the vertex array to specify each triangle's
  // position.

  const indices = [
    //six faces of cube: each has 2 triangles (6 indices)
    0,
    3,
    2,
    2,
    1,
    0, // Top
    4,
    7,
    6,
    6,
    5,
    4, // Bottom
    5,
    6,
    2,
    2,
    3,
    5, // Front
    4,
    0,
    1,
    1,
    7,
    4, // Back
    7,
    1,
    2,
    2,
    6,
    7, // Right
    4,
    5,
    3,
    3,
    0,
    4, // Left
  ];
  // Now send the element array to GL

  gl.bufferData(
    gl.ELEMENT_ARRAY_BUFFER,
    new Uint16Array(indices),
    gl.STATIC_DRAW
  );

  const posTexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posTexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posTex), gl.STATIC_DRAW);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bindBuffer(gl.ARRAY_BUFFER, posTexBuffer);
  //vertex spatial position: 3 floats X,Y,Z
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
  //UVW texCoord: (also three floats)
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);
  gl.bindVertexArray(null);

  const obj3D = new NiivueObject3D(
    id,
    posTexBuffer,
    gl.TRIANGLES,
    indices.length,
    indexBuffer,
    vao
  );
  const extents = getExtents([
    ...LPS,
    ...RPS,
    ...RAS,
    ...LAS,
    ...LPI,
    ...LAI,
    ...RAI,
    ...RPI,
  ]);
  obj3D.extentsMin = extents.min.slice();
  obj3D.extentsMax = extents.max.slice();

  obj3D.furthestVertexFromOrigin = extents.furthestVertexFromOrigin;
  obj3D.originNegate = vec3.clone(extents.origin);
  vec3.negate(obj3D.originNegate, obj3D.originNegate);
  obj3D.fieldOfViewDeObliqueMM = [
    this.dimsRAS[1] * this.pixDimsRAS[1],
    this.dimsRAS[2] * this.pixDimsRAS[2],
    this.dimsRAS[3] * this.pixDimsRAS[3],
  ];
  return obj3D;
};

/**
 * Update options for image
 * @param {NVImageFromUrlOptions} options
 */
NVImage.prototype.applyOptionsUpdate = function (options) {
  this.hdr.cal_min = options.cal_min;
  this.hdr.cal_max = options.cal_max;
  delete options["url"];
  delete options["urlImageData"];
  delete options["cal_min"];
  delete options["cal_max"];
  Object.assign(this, options);
};

NVImage.prototype.getImageOptions = function () {
  let options = null;
  try {
    options = new NVImageFromUrlOptions(
      "", // url,
      "", // urlImageData
      this.name, // name
      this.colorMap, // colorMap
      this.opacity, // opacity
      this.hdr.cal_min, // cal_min
      this.hdr.cal_max, // cal_max
      this.trustCalMinMax, // trustCalMinMax,
      this.percentileFrac, // percentileFrac
      this.ignoreZeroVoxels, // ignoreZeroVoxels
      this.visible, // visible
      this.colorMapNegative // colorMapNegative
    );
  } catch (e) {
    console.log(e);
  }
  return options;
};
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Log","link":"<a href=\"Log.html\">Log</a>"},{"title":"Niivue","link":"<a href=\"Niivue.html\">Niivue</a>"},{"title":"Niivue#addMesh","link":"<a href=\"Niivue.html#addMesh\">Niivue &rtrif; addMesh</a>"},{"title":"Niivue#addMeshFromUrl","link":"<a href=\"Niivue.html#addMeshFromUrl\">Niivue &rtrif; addMeshFromUrl</a>"},{"title":"Niivue#addVolume","link":"<a href=\"Niivue.html#addVolume\">Niivue &rtrif; addVolume</a>"},{"title":"Niivue#addVolumeFromUrl","link":"<a href=\"Niivue.html#addVolumeFromUrl\">Niivue &rtrif; addVolumeFromUrl</a>"},{"title":"Niivue#attachTo","link":"<a href=\"Niivue.html#attachTo\">Niivue &rtrif; attachTo</a>"},{"title":"Niivue#attachToCanvas","link":"<a href=\"Niivue.html#attachToCanvas\">Niivue &rtrif; attachToCanvas</a>"},{"title":"Niivue#cloneVolume","link":"<a href=\"Niivue.html#cloneVolume\">Niivue &rtrif; cloneVolume</a>"},{"title":"Niivue#closeSession","link":"<a href=\"Niivue.html#closeSession\">Niivue &rtrif; closeSession</a>"},{"title":"Niivue#colorMaps","link":"<a href=\"Niivue.html#colorMaps\">Niivue &rtrif; colorMaps</a>"},{"title":"Niivue#createEmptyDrawing","link":"<a href=\"Niivue.html#createEmptyDrawing\">Niivue &rtrif; createEmptyDrawing</a>"},{"title":"Niivue#createSession","link":"<a href=\"Niivue.html#createSession\">Niivue &rtrif; createSession</a>"},{"title":"Niivue#drawGrowCut","link":"<a href=\"Niivue.html#drawGrowCut\">Niivue &rtrif; drawGrowCut</a>"},{"title":"Niivue#drawMosaic","link":"<a href=\"Niivue.html#drawMosaic\">Niivue &rtrif; drawMosaic</a>"},{"title":"Niivue#drawUndo","link":"<a href=\"Niivue.html#drawUndo\">Niivue &rtrif; drawUndo</a>"},{"title":"Niivue#getDescriptives","link":"<a href=\"Niivue.html#getDescriptives\">Niivue &rtrif; getDescriptives</a>"},{"title":"Niivue#getFrame4D","link":"<a href=\"Niivue.html#getFrame4D\">Niivue &rtrif; getFrame4D</a>"},{"title":"Niivue#getMediaByUrl","link":"<a href=\"Niivue.html#getMediaByUrl\">Niivue &rtrif; getMediaByUrl</a>"},{"title":"Niivue#getOverlayIndexByID","link":"<a href=\"Niivue.html#getOverlayIndexByID\">Niivue &rtrif; getOverlayIndexByID</a>"},{"title":"Niivue#getRadiologicalConvention","link":"<a href=\"Niivue.html#getRadiologicalConvention\">Niivue &rtrif; getRadiologicalConvention</a>"},{"title":"Niivue#getVolumeIndexByID","link":"<a href=\"Niivue.html#getVolumeIndexByID\">Niivue &rtrif; getVolumeIndexByID</a>"},{"title":"Niivue#joinSession","link":"<a href=\"Niivue.html#joinSession\">Niivue &rtrif; joinSession</a>"},{"title":"Niivue#loadConnectome","link":"<a href=\"Niivue.html#loadConnectome\">Niivue &rtrif; loadConnectome</a>"},{"title":"Niivue#loadDrawing","link":"<a href=\"Niivue.html#loadDrawing\">Niivue &rtrif; loadDrawing</a>"},{"title":"Niivue#loadMeshes","link":"<a href=\"Niivue.html#loadMeshes\">Niivue &rtrif; loadMeshes</a>"},{"title":"Niivue#loadMeshFromUrl","link":"<a href=\"Niivue.html#loadMeshFromUrl\">Niivue &rtrif; loadMeshFromUrl</a>"},{"title":"Niivue#loadVolumeFromUrl","link":"<a href=\"Niivue.html#loadVolumeFromUrl\">Niivue &rtrif; loadVolumeFromUrl</a>"},{"title":"Niivue#loadVolumes","link":"<a href=\"Niivue.html#loadVolumes\">Niivue &rtrif; loadVolumes</a>"},{"title":"Niivue#meshShaderNames","link":"<a href=\"Niivue.html#meshShaderNames\">Niivue &rtrif; meshShaderNames</a>"},{"title":"Niivue#moveVolumeDown","link":"<a href=\"Niivue.html#moveVolumeDown\">Niivue &rtrif; moveVolumeDown</a>"},{"title":"Niivue#moveVolumeToBottom","link":"<a href=\"Niivue.html#moveVolumeToBottom\">Niivue &rtrif; moveVolumeToBottom</a>"},{"title":"Niivue#moveVolumeToTop","link":"<a href=\"Niivue.html#moveVolumeToTop\">Niivue &rtrif; moveVolumeToTop</a>"},{"title":"Niivue#moveVolumeUp","link":"<a href=\"Niivue.html#moveVolumeUp\">Niivue &rtrif; moveVolumeUp</a>"},{"title":"Niivue#notifySubscribersOfOptionChange","link":"<a href=\"Niivue.html#notifySubscribersOfOptionChange\">Niivue &rtrif; notifySubscribersOfOptionChange</a>"},{"title":"Niivue#off","link":"<a href=\"Niivue.html#off\">Niivue &rtrif; off</a>"},{"title":"Niivue#on","link":"<a href=\"Niivue.html#on\">Niivue &rtrif; on</a>"},{"title":"Niivue#removeMesh","link":"<a href=\"Niivue.html#removeMesh\">Niivue &rtrif; removeMesh</a>"},{"title":"Niivue#removeVolume","link":"<a href=\"Niivue.html#removeVolume\">Niivue &rtrif; removeVolume</a>"},{"title":"Niivue#removeVolumeByIndex","link":"<a href=\"Niivue.html#removeVolumeByIndex\">Niivue &rtrif; removeVolumeByIndex</a>"},{"title":"Niivue#removeVolumeByIndex","link":"<a href=\"Niivue.html#removeVolumeByIndex\">Niivue &rtrif; removeVolumeByIndex</a>"},{"title":"Niivue#removeVolumeByIndex","link":"<a href=\"Niivue.html#removeVolumeByIndex\">Niivue &rtrif; removeVolumeByIndex</a>"},{"title":"Niivue#removeVolumeByUrl","link":"<a href=\"Niivue.html#removeVolumeByUrl\">Niivue &rtrif; removeVolumeByUrl</a>"},{"title":"Niivue#reverseFaces","link":"<a href=\"Niivue.html#reverseFaces\">Niivue &rtrif; reverseFaces</a>"},{"title":"Niivue#saveImage","link":"<a href=\"Niivue.html#saveImage\">Niivue &rtrif; saveImage</a>"},{"title":"Niivue#saveScene","link":"<a href=\"Niivue.html#saveScene\">Niivue &rtrif; saveScene</a>"},{"title":"Niivue#setClipPlane","link":"<a href=\"Niivue.html#setClipPlane\">Niivue &rtrif; setClipPlane</a>"},{"title":"Niivue#setClipPlaneColor","link":"<a href=\"Niivue.html#setClipPlaneColor\">Niivue &rtrif; setClipPlaneColor</a>"},{"title":"Niivue#setColorMap","link":"<a href=\"Niivue.html#setColorMap\">Niivue &rtrif; setColorMap</a>"},{"title":"Niivue#setColorMapNegative","link":"<a href=\"Niivue.html#setColorMapNegative\">Niivue &rtrif; setColorMapNegative</a>"},{"title":"Niivue#setCornerOrientationText","link":"<a href=\"Niivue.html#setCornerOrientationText\">Niivue &rtrif; setCornerOrientationText</a>"},{"title":"Niivue#setCrosshairColor","link":"<a href=\"Niivue.html#setCrosshairColor\">Niivue &rtrif; setCrosshairColor</a>"},{"title":"Niivue#setCrosshairWidth","link":"<a href=\"Niivue.html#setCrosshairWidth\">Niivue &rtrif; setCrosshairWidth</a>"},{"title":"Niivue#setCustomMeshShader","link":"<a href=\"Niivue.html#setCustomMeshShader\">Niivue &rtrif; setCustomMeshShader</a>"},{"title":"Niivue#setDrawingEnabled","link":"<a href=\"Niivue.html#setDrawingEnabled\">Niivue &rtrif; setDrawingEnabled</a>"},{"title":"Niivue#setDrawOpacity","link":"<a href=\"Niivue.html#setDrawOpacity\">Niivue &rtrif; setDrawOpacity</a>"},{"title":"Niivue#setFrame4D","link":"<a href=\"Niivue.html#setFrame4D\">Niivue &rtrif; setFrame4D</a>"},{"title":"Niivue#setHighResolutionCapable","link":"<a href=\"Niivue.html#setHighResolutionCapable\">Niivue &rtrif; setHighResolutionCapable</a>"},{"title":"Niivue#setInterpolation","link":"<a href=\"Niivue.html#setInterpolation\">Niivue &rtrif; setInterpolation</a>"},{"title":"Niivue#setMeshLayerProperty","link":"<a href=\"Niivue.html#setMeshLayerProperty\">Niivue &rtrif; setMeshLayerProperty</a>"},{"title":"Niivue#setMeshProperty","link":"<a href=\"Niivue.html#setMeshProperty\">Niivue &rtrif; setMeshProperty</a>"},{"title":"Niivue#setMeshShader","link":"<a href=\"Niivue.html#setMeshShader\">Niivue &rtrif; setMeshShader</a>"},{"title":"Niivue#setMeshThicknessOn2D","link":"<a href=\"Niivue.html#setMeshThicknessOn2D\">Niivue &rtrif; setMeshThicknessOn2D</a>"},{"title":"Niivue#setModulationImage","link":"<a href=\"Niivue.html#setModulationImage\">Niivue &rtrif; setModulationImage</a>"},{"title":"Niivue#setOpacity","link":"<a href=\"Niivue.html#setOpacity\">Niivue &rtrif; setOpacity</a>"},{"title":"Niivue#setPan2Dxyzmm","link":"<a href=\"Niivue.html#setPan2Dxyzmm\">Niivue &rtrif; setPan2Dxyzmm</a>"},{"title":"Niivue#setPenValue","link":"<a href=\"Niivue.html#setPenValue\">Niivue &rtrif; setPenValue</a>"},{"title":"Niivue#setRadiologicalConvention","link":"<a href=\"Niivue.html#setRadiologicalConvention\">Niivue &rtrif; setRadiologicalConvention</a>"},{"title":"Niivue#setRenderAzimuthElevation","link":"<a href=\"Niivue.html#setRenderAzimuthElevation\">Niivue &rtrif; setRenderAzimuthElevation</a>"},{"title":"Niivue#setScale","link":"<a href=\"Niivue.html#setScale\">Niivue &rtrif; setScale</a>"},{"title":"Niivue#setSelectionBoxColor","link":"<a href=\"Niivue.html#setSelectionBoxColor\">Niivue &rtrif; setSelectionBoxColor</a>"},{"title":"Niivue#setSliceMM","link":"<a href=\"Niivue.html#setSliceMM\">Niivue &rtrif; setSliceMM</a>"},{"title":"Niivue#setSliceMosaicString","link":"<a href=\"Niivue.html#setSliceMosaicString\">Niivue &rtrif; setSliceMosaicString</a>"},{"title":"Niivue#setSliceType","link":"<a href=\"Niivue.html#setSliceType\">Niivue &rtrif; setSliceType</a>"},{"title":"Niivue#setVolume","link":"<a href=\"Niivue.html#setVolume\">Niivue &rtrif; setVolume</a>"},{"title":"Niivue#sph2cartDeg","link":"<a href=\"Niivue.html#sph2cartDeg\">Niivue &rtrif; sph2cartDeg</a>"},{"title":"Niivue#syncWith","link":"<a href=\"Niivue.html#syncWith\">Niivue &rtrif; syncWith</a>"},{"title":"Niivue#updateGLVolume","link":"<a href=\"Niivue.html#updateGLVolume\">Niivue &rtrif; updateGLVolume</a>"},{"title":"NiivueObject3D","link":"<a href=\"NiivueObject3D.html\">NiivueObject3D</a>"},{"title":"NVImage","link":"<a href=\"NVImage.html\">NVImage</a>"},{"title":"NVImage.zerosLike","link":"<a href=\"NVImage.html#.zerosLike\">NVImage &rtrif; zerosLike</a>"},{"title":"NVImage#applyOptionsUpdate","link":"<a href=\"NVImage.html#applyOptionsUpdate\">NVImage &rtrif; applyOptionsUpdate</a>"},{"title":"NVImage#clone","link":"<a href=\"NVImage.html#clone\">NVImage &rtrif; clone</a>"},{"title":"NVImage#colorMaps","link":"<a href=\"NVImage.html#colorMaps\">NVImage &rtrif; colorMaps</a>"},{"title":"NVImage#getImageMetadata","link":"<a href=\"NVImage.html#getImageMetadata\">NVImage &rtrif; getImageMetadata</a>"},{"title":"NVImage#toNiivueObject3D","link":"<a href=\"NVImage.html#toNiivueObject3D\">NVImage &rtrif; toNiivueObject3D</a>"},{"title":"NVImage#zeroImage","link":"<a href=\"NVImage.html#zeroImage\">NVImage &rtrif; zeroImage</a>"},{"title":"NVImageFromUrlOptions","link":"<a href=\"global.html#NVImageFromUrlOptions\">NVImageFromUrlOptions</a>"},{"title":"NVMesh","link":"<a href=\"NVMesh.html\">NVMesh</a>"},{"title":"NVMesh.loadFromBase64","link":"<a href=\"NVMesh.html#.loadFromBase64\">NVMesh &rtrif; loadFromBase64</a>"},{"title":"NVMesh.loadFromFile","link":"<a href=\"NVMesh.html#.loadFromFile\">NVMesh &rtrif; loadFromFile</a>"},{"title":"NVMesh.loadFromUrl","link":"<a href=\"NVMesh.html#.loadFromUrl\">NVMesh &rtrif; loadFromUrl</a>"},{"title":"NVMeshFromUrlOptions","link":"<a href=\"global.html#NVMeshFromUrlOptions\">NVMeshFromUrlOptions</a>"},{"title":"NVMessage","link":"<a href=\"NVMessage.html\">NVMessage</a>"},{"title":"NVMessageSet4DVolumeIndexData","link":"<a href=\"NVMessageSet4DVolumeIndexData.html\">NVMessageSet4DVolumeIndexData</a>"},{"title":"NVMesssageUpdateData","link":"<a href=\"NVMesssageUpdateData.html\">NVMesssageUpdateData</a>"},{"title":"Shader","link":"<a href=\"Shader.html\">Shader</a>"},{"title":"getExtents","link":"<a href=\"global.html#getExtents\">getExtents</a>"},{"title":"NiivueOptions","link":"<a href=\"global.html#NiivueOptions\">NiivueOptions</a>"},{"title":"NVImageFromUrlOptions","link":"<a href=\"global.html#NVImageFromUrlOptions\">NVImageFromUrlOptions</a>"},{"title":"NVImageMetadata","link":"<a href=\"global.html#NVImageMetadata\">NVImageMetadata</a>"},{"title":"NVMeshFromUrlOptions","link":"<a href=\"global.html#NVMeshFromUrlOptions\">NVMeshFromUrlOptions</a>"},{"title":"NVMeshLayer","link":"<a href=\"global.html#NVMeshLayer\">NVMeshLayer</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
