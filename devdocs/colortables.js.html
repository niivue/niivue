<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>colortables.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColorTables_ColorTables.html">ColorTables</a></li><li><a href="NVConnectome.html">NVConnectome</a><ul class='methods'><li data-type='method'><a href="NVConnectome.html#findClosestConnectomeNode">findClosestConnectomeNode</a></li><li data-type='method'><a href="NVConnectome.html#.loadConnectomeFromUrl">loadConnectomeFromUrl</a></li></ul></li><li><a href="NVController.html">NVController</a><ul class='methods'><li data-type='method'><a href="NVController.html#connectToSession">connectToSession</a></li><li data-type='method'><a href="NVController.html#onAzimuthElevationChangeHandler">onAzimuthElevationChangeHandler</a></li><li data-type='method'><a href="NVController.html#onClipPlaneChangeHandler">onClipPlaneChangeHandler</a></li><li data-type='method'><a href="NVController.html#onColormapChangeHandler">onColormapChangeHandler</a></li><li data-type='method'><a href="NVController.html#onCustomMeshShaderAddedHandler">onCustomMeshShaderAddedHandler</a></li><li data-type='method'><a href="NVController.html#onFrameChangeHandler">onFrameChangeHandler</a></li><li data-type='method'><a href="NVController.html#onImageLoadedHandler">onImageLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshAddedFromUrlHandler">onMeshAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onMeshLoadedHandler">onMeshLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshPropertyChanged">onMeshPropertyChanged</a></li><li data-type='method'><a href="NVController.html#onMeshShaderChanged">onMeshShaderChanged</a></li><li data-type='method'><a href="NVController.html#onOpacityChangeHandler">onOpacityChangeHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeAddedFromUrlHandler">onVolumeAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeWithUrlRemovedHandler">onVolumeWithUrlRemovedHandler</a></li><li data-type='method'><a href="NVController.html#onZoom3DChangeHandler">onZoom3DChangeHandler</a></li></ul></li><li><a href="NVDocument.html">NVDocument</a><ul class='methods'><li data-type='method'><a href="NVDocument.html#addImageOptions">addImageOptions</a></li><li data-type='method'><a href="NVDocument.html#download">download</a></li><li data-type='method'><a href="NVDocument.html#getImageOptions">getImageOptions</a></li><li data-type='method'><a href="NVDocument.html#hasImage">hasImage</a></li><li data-type='method'><a href="NVDocument.html#hasImageFromUrl">hasImageFromUrl</a></li><li data-type='method'><a href="NVDocument.html#json">json</a></li><li data-type='method'><a href="NVDocument.html#removeImage">removeImage</a></li><li data-type='method'><a href="NVDocument.html#.deserializeMeshDataObjects">deserializeMeshDataObjects</a></li><li data-type='method'><a href="NVDocument.html#.loadFromJSON">loadFromJSON</a></li></ul></li><li></li><li></li><li><a href="NVLabel3D_NVLabel3D.html">NVLabel3D</a></li><li><a href="NVLabel3DStyle.html">NVLabel3DStyle</a></li><li><a href="NVMesh.html">NVMesh</a><ul class='methods'><li data-type='method'><a href="NVMesh.html#.loadFromBase64">loadFromBase64</a></li><li data-type='method'><a href="NVMesh.html#.loadFromFile">loadFromFile</a></li><li data-type='method'><a href="NVMesh.html#.loadFromUrl">loadFromUrl</a></li></ul></li><li><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li><a href="NVMeshLoaders.html">NVMeshLoaders</a></li><li><a href="NVMeshUtilities.html">NVMeshUtilities</a></li><li><a href="NVMessage.html">NVMessage</a></li><li><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li><a href="NVUtilities.html">NVUtilities</a></li><li><a href="NiivueObject3D.html">NiivueObject3D</a></li><li><a href="SessionBus.html">SessionBus</a></li><li><a href="SessionUser.html">SessionUser</a></li><li><a href="Shader.html">Shader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAG_MODE">DRAG_MODE</a></li><li><a href="global.html#LabelLineTerminator">LabelLineTerminator</a></li><li><a href="global.html#LabelTextAlignment">LabelTextAlignment</a></li><li><a href="global.html#MULTIPLANAR_TYPE">MULTIPLANAR_TYPE</a></li><li><a href="global.html#MeshType">MeshType</a></li><li><a href="global.html#NVMESSAGE">NVMESSAGE</a></li><li><a href="global.html#SLICE_TYPE">SLICE_TYPE</a></li><li><a href="global.html#storageAvailable">storageAvailable</a></li><li><a href="global.html#utiltiesLogger">utiltiesLogger</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">colortables.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as cmaps from './cmaps'

export class ColorTables {
  gamma = 1.0
  version = 0.1
  cluts = {}

  /**
   * Sets cluts to alphabetically sorted cmaps
   */
  constructor() {
    const cmapKeys = Object.keys(cmaps)

    const cmapsSorted = cmapKeys
      .filter((k) => !k.startsWith('$')) // ignore drawing maps
      .sort(new Intl.Collator('en').compare) // case insensitive, e.g. "ROI_i256" > "actc"

    for (const key of cmapsSorted) {
      this.cluts[key] = cmaps[key]
    }
  }

  addColormap(key, cmap) {
    this.cluts[key] = cmap
  }

  colormaps() {
    return Object.keys(this.cluts)
  }

  // for backward compatibility: prior to v0.34 "colormaps" used to be "colorMaps"
  colorMaps() {
    return this.colormaps()
  }

  // returns key name if it exists, otherwise returns default "gray"
  colormapFromKey(name) {
    let cmap = this.cluts[name]
    if (cmap !== undefined) {
      return cmap
    }

    cmap = this.cluts[name.toLowerCase()]
    if (cmap !== undefined) {
      return cmap
    }

    if (name.length > 0) {
      console.log('No color map named ' + name)
    }
    return {
      min: 0,
      max: 0,
      R: [0, 255],
      G: [0, 255],
      B: [0, 255],
      A: [0, 255],
      I: [0, 255]
    }
  }

  // not included in public docs
  colormap(key = '', isInvert = false) {
    const cmap = this.colormapFromKey(key)
    return this.makeLut(cmap.R, cmap.G, cmap.B, cmap.A, cmap.I, isInvert)
  }

  makeLabelLut(cm, alphaFill = 64) {
    if (cm.R === undefined || cm.G === undefined || cm.B === undefined) {
      console.log('Invalid colormap table.', cm)
      return []
    }
    const nLabels = cm.R.length

    // if indices are not provided, indices default to 0..(nLabels-1)
    const idxs = cm.I ?? [...Array(nLabels).keys()]

    if (nLabels !== cm.G.length || nLabels !== cm.B.length || nLabels !== idxs.length) {
      console.log('colormap does not make sense.', cm)
      return []
    }

    let As = new Uint8ClampedArray(nLabels).fill(alphaFill)
    As[0] = 0
    if (cm.A !== undefined) {
      As = cm.A
    }

    const mnIdx = Math.min(...idxs)
    const mxIdx = Math.max(...idxs)

    // n.b. number of input labels can be sparse: I:[0,3,4] output is dense [0,1,2,3,4]
    const nLabelsDense = mxIdx - mnIdx + 1
    const lut = new Uint8ClampedArray(nLabelsDense * 4).fill(0)
    for (let i = 0; i &lt; nLabels; i++) {
      let k = (idxs[i] - mnIdx) * 4
      lut[k++] = cm.R[i] // Red
      lut[k++] = cm.G[i] // Green
      lut[k++] = cm.B[i] // Blue
      lut[k++] = As[i] // Alpha
    }

    const cmap = []
    // labels are optional
    if (cm.labels) {
      const nL = cm.labels.length
      if (nL === nLabelsDense) {
        cmap.labels = cm.labels
      } else if (nL === nLabels) {
        cmap.labels = Array(nLabelsDense).fill('?')
        for (let i = 0; i &lt; nLabels; i++) {
          const idx = idxs[i]
          cmap.labels[idx] = cm.labels[i]
        }
      }
    }
    cmap.lut = lut
    cmap.min = mnIdx
    cmap.max = mxIdx
    return cmap
  }

  async makeLabelLutFromUrl(name) {
    const response = await fetch(name)
    const cm = await response.json()
    return this.makeLabelLut(cm)
  }

  // not included in public docs
  // The drawing colormap is a variant of the label colormap with precisely 256 colors
  makeDrawLut(name) {
    let cmap = typeof name === 'object' ? name : cmaps[name]

    if (cmap === undefined) {
      cmap = {
        min: 0,
        max: 0,
        R: [0, 255, 0, 0, 255, 0, 255],
        G: [0, 0, 255, 0, 255, 255, 0],
        B: [0, 0, 0, 255, 0, 255, 255],
        A: [0, 255, 255, 255, 255, 255, 255]
      }
    }

    const cm = this.makeLabelLut(cmap, 255)

    if (cm.labels === undefined) {
      cm.labels = []
    }
    if (cm.labels.length &lt; 256) {
      const j = cm.labels.length
      for (let i = j; i &lt; 256; i++) {
        // make all unused slots opaque red
        cm.labels.push(i.toString())
      }
    }

    const lut = new Uint8ClampedArray(256 * 4)
    let k = 0
    for (let i = 0; i &lt; 256; i++) {
      lut[k++] = 255 // Red
      lut[k++] = 0 // Green
      lut[k++] = 0 // Blue
      lut[k++] = 255 // Alpha
    }
    lut[3] = 0 // make first alpha transparent: not part of drawing

    // drawings can have no more than 256 colors
    const explicitLUTbytes = Math.min(cm.lut.length, 256 * 4)
    if (explicitLUTbytes > 0) {
      for (let i = 0; i &lt; explicitLUTbytes; i++) {
        lut[i] = cm.lut[i]
      }
    }

    return {
      lut,
      labels: cm.labels
    }
  }

  // not included in public docs
  makeLut(Rsi, Gsi, Bsi, Asi, Isi, isInvert) {
    // create color lookup table provided arrays of reds, greens, blues, alphas and intensity indices
    // intensity indices should be in increasing order with the first value 0 and the last 255.
    // this.makeLut([0, 255], [0, 0], [0,0], [0,128],[0,255]); //red gradient
    const nIdx = Rsi.length
    const Rs = [...Rsi]
    const Gs = [...Gsi]
    const Bs = [...Bsi]
    let As = [...Asi]
    let Is = [...Isi]
    if (isInvert) {
      for (let i = 0; i &lt; nIdx; i++) {
        Rs[i] = Rsi[nIdx - 1 - i]
        Gs[i] = Gsi[nIdx - 1 - i]
        Bs[i] = Bsi[nIdx - 1 - i]
        As[i] = 255 - Asi[nIdx - 1 - i]
        Is[i] = 255 - Isi[nIdx - 1 - i]
      }
    }
    const lut = new Uint8ClampedArray(256 * 4)
    if (typeof Is === 'undefined') {
      Is = new Uint8ClampedArray(nIdx).fill(0)
      for (let i = 0; i &lt; nIdx; i++) {
        Is[i] = Math.round((i * 255.0) / (nIdx - 1))
      }
    }
    if (typeof As === 'undefined') {
      As = new Uint8ClampedArray(nIdx).fill(64)
      As[0] = 0
    }
    for (let i = 0; i &lt; nIdx - 1; i++) {
      const idxLo = Is[i]
      let idxHi = Is[i + 1]
      if (i === 0 &amp;&amp; idxLo !== 0) {
        console.log('colormap issue: indices expected to start with 0 not ', idxLo)
      }
      if (i === Is.length - 2 &amp;&amp; idxHi !== 255) {
        console.log('padding colormap: indices expected end with 255 not ', idxHi)
        idxHi = 255
      }
      const idxRng = idxHi - idxLo
      let k = idxLo * 4
      for (let j = idxLo; j &lt;= idxHi; j++) {
        const f = (j - idxLo) / idxRng
        lut[k++] = Rs[i] + f * (Rs[i + 1] - Rs[i]) // Red
        lut[k++] = Gs[i] + f * (Gs[i + 1] - Gs[i]) // Green
        lut[k++] = Bs[i] + f * (Bs[i + 1] - Bs[i]) // Blue
        lut[k++] = As[i] + f * (As[i + 1] - As[i]) // Alpha
      }
    }
    if (this.gamma === 1.0) {
      return lut
    }
    for (let i = 0; i &lt; 255 * 4; i++) {
      if (i % 4 === 3) {
        continue
      } // gamma changes RGB, not Alpha
      lut[i] = Math.pow(lut[i] / 255, 1 / this.gamma) * 255
    }
    return lut
  }
}

export const cmapper = new ColorTables()
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Tue Nov 28 2023 09:04:36 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
